"use strict";
//
// Wallet Object
// BitGo accessor for a specific wallet
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var unspents_1 = require("@bitgo/unspents");
var TransactionBuilder = require('./transactionBuilder');
var bitcoin = require("./bitcoin");
// TODO: switch to bitcoinjs-lib eventually once we upgrade it to version 3.x.x
var prova = require("prova-lib");
var PendingApproval = require('./pendingapproval');
var common = require("./common");
var Promise = require("bluebird");
var co = Promise.coroutine;
var _ = require("lodash");
var request = require('superagent');
//
// Constructor
//
var Wallet = function (bitgo, wallet) {
    this.bitgo = bitgo;
    this.wallet = wallet;
    this.keychains = [];
    if (wallet.private) {
        this.keychains = wallet.private.keychains;
    }
};
Wallet.prototype.toJSON = function () {
    return this.wallet;
};
//
// id
// Get the id of this wallet.
//
Wallet.prototype.id = function () {
    return this.wallet.id;
};
//
// label
// Get the label of this wallet.
//
Wallet.prototype.label = function () {
    return this.wallet.label;
};
//
// balance
// Get the balance of this wallet.
//
Wallet.prototype.balance = function () {
    return this.wallet.balance;
};
//
// balance
// Get the spendable balance of this wallet.
// This is the total of all unspents except those that are unconfirmed and external
//
Wallet.prototype.spendableBalance = function () {
    return this.wallet.spendableBalance;
};
//
// confirmedBalance
// Get the confirmedBalance of this wallet.
//
Wallet.prototype.confirmedBalance = function () {
    return this.wallet.confirmedBalance;
};
//
// canSendInstant
// Returns if the wallet can send instant transactions
// This is impacted by the choice of backup key provider
//
Wallet.prototype.canSendInstant = function () {
    return this.wallet && this.wallet.canSendInstant;
};
//
// instant balance
// Get the instant balance of this wallet.
// This is the total of all unspents that may be spent instantly.
//
Wallet.prototype.instantBalance = function () {
    if (!this.canSendInstant()) {
        throw new Error('not an instant wallet');
    }
    return this.wallet.instantBalance;
};
//
// unconfirmedSends
// Get the balance of unconfirmedSends of this wallet.
//
Wallet.prototype.unconfirmedSends = function () {
    return this.wallet.unconfirmedSends;
};
//
// unconfirmedReceives
// Get the balance of unconfirmedReceives balance of this wallet.
//
Wallet.prototype.unconfirmedReceives = function () {
    return this.wallet.unconfirmedReceives;
};
//
// type
// Get the type of this wallet, e.g. 'safehd'
//
Wallet.prototype.type = function () {
    return this.wallet.type;
};
Wallet.prototype.url = function (extra) {
    extra = extra || '';
    return this.bitgo.url('/wallet/' + this.id() + extra);
};
//
// pendingApprovals
// returns the pending approvals list for this wallet as pending approval objects
//
Wallet.prototype.pendingApprovals = function () {
    var self = this;
    return this.wallet.pendingApprovals.map(function (p) {
        return new PendingApproval(self.bitgo, p, self);
    });
};
//
// approvalsRequired
// returns the number of approvals required to approve pending approvals involving this wallet
//
Wallet.prototype.approvalsRequired = function () {
    return this.wallet.approvalsRequired || 1;
};
//
// get
// Refetches this wallet and returns it
//
Wallet.prototype.get = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var self = this;
    return this.bitgo.get(this.url())
        .result()
        .then(function (res) {
        self.wallet = res;
        return self;
    })
        .nodeify(callback);
};
//
// updateApprovalsRequired
// Updates the number of approvals required on a pending approval involving this wallet.
// The approvals required is by default 1, but this function allows you to update the
// number such that 1 <= approvalsRequired <= walletAdmins.length - 1
//
Wallet.prototype.updateApprovalsRequired = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (params.approvalsRequired === undefined ||
        !_.isInteger(params.approvalsRequired) ||
        params.approvalsRequired < 1) {
        throw new Error('invalid approvalsRequired: must be a nonzero positive number');
    }
    var self = this;
    var currentApprovalsRequired = this.approvalsRequired();
    if (currentApprovalsRequired === params.approvalsRequired) {
        // no-op, just return the current wallet
        return Promise.try(function () {
            return self.wallet;
        })
            .nodeify(callback);
    }
    return this.bitgo.put(this.url())
        .send(params)
        .result()
        .nodeify(callback);
};
/**
 * Returns the correct chain for change, taking into consideration segwit
 */
Wallet.prototype.getChangeChain = function (params) {
    var useSegwitChange = !!this.bitgo.getConstants().enableSegwit;
    if (!_.isUndefined(params.segwitChange)) {
        if (!_.isBoolean(params.segwitChange)) {
            throw new Error('segwitChange must be a boolean');
        }
        // if segwit is disabled through the constants, segwit change should still not be created
        useSegwitChange = this.bitgo.getConstants().enableSegwit && params.segwitChange;
    }
    return useSegwitChange ? unspents_1.Codes.internal.p2shP2wsh : unspents_1.Codes.internal.p2sh;
};
//
// createAddress
// Creates a new address for use with this wallet.
//
Wallet.prototype.createAddress = function (params, callback) {
    var self = this;
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (this.type() === 'safe') {
        throw new Error('You are using a legacy wallet that cannot create a new address');
    }
    // Default to client-side address validation on, for safety. Use validate=false to disable.
    var shouldValidate = params.validate !== undefined ? params.validate : this.bitgo.getValidate();
    var allowExisting = params.allowExisting;
    if (typeof allowExisting !== 'boolean') {
        params.allowExisting = (allowExisting === 'true');
    }
    var isSegwit = this.bitgo.getConstants().enableSegwit;
    var defaultChain = isSegwit ? unspents_1.Codes.external.p2shP2wsh : unspents_1.Codes.external.p2sh;
    var chain = params.chain;
    if (chain === null || chain === undefined) {
        chain = defaultChain;
    }
    return this.bitgo.post(this.url('/address/' + chain))
        .send(params)
        .result()
        .then(function (addr) {
        if (shouldValidate) {
            self.validateAddress(addr);
        }
        return addr;
    })
        .nodeify(callback);
};
/**
 * Generate address locally without calling server
 * @param params
 *
 */
Wallet.prototype.generateAddress = function (_a) {
    var segwit = _a.segwit, path = _a.path, keychains = _a.keychains, threshold = _a.threshold;
    var isSegwit = !!segwit;
    var signatureThreshold = 2;
    if (_.isInteger(threshold)) {
        signatureThreshold = threshold;
        if (signatureThreshold <= 0) {
            throw new Error('threshold has to be positive');
        }
    }
    var pathRegex = /^\/1?[01]\/\d+$/;
    if (!path.match(pathRegex)) {
        throw new Error('unsupported path: ' + path);
    }
    var rootKeys = this.keychains;
    if (Array.isArray(keychains)) {
        rootKeys = keychains;
    }
    var derivedKeys = rootKeys.map(function (k) {
        var hdnode = prova.HDNode.fromBase58(k.xpub);
        var derivationPath = k.path + path;
        if (k.walletSubPath) {
            // if a keychain has a wallet subpath, it should be used as an infix
            derivationPath = k.path + k.walletSubPath + path;
        }
        if (!derivationPath.startsWith('m')) {
            // all derivation paths need to start with m, but k.path may already contain that
            derivationPath = "m/" + derivationPath;
        }
        return hdnode.hdPath().deriveKey(derivationPath).getPublicKeyBuffer();
    });
    var pathComponents = path.split('/');
    var normalizedPathComponents = _.map(pathComponents, function (component) {
        if (component && component.length > 0) {
            return parseInt(component, 10);
        }
    });
    var pathDetails = _.filter(normalizedPathComponents, _.isInteger);
    var addressDetails = {
        chainPath: path,
        path: path,
        chain: pathDetails[0],
        index: pathDetails[1],
        wallet: this.id()
    };
    // redeem script normally, witness script for segwit
    var inputScript = bitcoin.script.multisig.output.encode(signatureThreshold, derivedKeys);
    var inputScriptHash = bitcoin.crypto.hash160(inputScript);
    var outputScript = bitcoin.script.scriptHash.output.encode(inputScriptHash);
    addressDetails.redeemScript = inputScript.toString('hex');
    if (isSegwit) {
        var witnessScriptHash = bitcoin.crypto.sha256(inputScript);
        var redeemScript = bitcoin.script.witnessScriptHash.output.encode(witnessScriptHash);
        var redeemScriptHash = bitcoin.crypto.hash160(redeemScript);
        outputScript = bitcoin.script.scriptHash.output.encode(redeemScriptHash);
        addressDetails.witnessScript = inputScript.toString('hex');
        addressDetails.redeemScript = redeemScript.toString('hex');
    }
    addressDetails.outputScript = outputScript.toString('hex');
    addressDetails.address = bitcoin.address.fromOutputScript(outputScript, bitcoin.getNetwork());
    return addressDetails;
};
//
// validateAddress
// Validates an address and path by calculating it locally from the keychain xpubs
//
Wallet.prototype.validateAddress = function (params) {
    common.validateParams(params, ['address', 'path'], []);
    var isSegwit = !!params.witnessScript && params.witnessScript.length > 0;
    var generatedAddress = this.generateAddress({ path: params.path, segwit: isSegwit });
    if (generatedAddress.address !== params.address) {
        throw new Error('address validation failure: ' + params.address + ' vs. ' + generatedAddress.address);
    }
};
//
// addresses
// Gets the addresses of a HD wallet.
// Options include:
//  limit: the number of addresses to get
//
Wallet.prototype.addresses = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var query = {};
    if (params.details) {
        query.details = 1;
    }
    var chain = params.chain;
    if (chain !== null && chain !== undefined) {
        if (Array.isArray(chain)) {
            query.chain = _.uniq(_.filter(chain, _.isInteger));
        }
        else {
            if (chain !== 0 && chain !== 1) {
                throw new Error('invalid chain argument, expecting 0 or 1');
            }
            query.chain = chain;
        }
    }
    if (params.limit) {
        if (!_.isInteger(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        query.limit = params.limit;
    }
    if (params.skip) {
        if (!_.isInteger(params.skip)) {
            throw new Error('invalid skip argument, expecting number');
        }
        query.skip = params.skip;
    }
    if (params.sort) {
        if (!_.isNumber(params.sort)) {
            throw new Error('invalid sort argument, expecting number');
        }
        query.sort = params.sort;
    }
    var url = this.url('/addresses');
    return this.bitgo.get(url)
        .query(query)
        .result()
        .nodeify(callback);
};
Wallet.prototype.stats = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var args = [];
    if (params.limit) {
        if (!_.isInteger(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        args.push('limit=' + params.limit);
    }
    var query = '';
    if (args.length) {
        query = '?' + args.join('&');
    }
    var url = this.url('/stats' + query);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
/**
 * Refresh the wallet object by syncing with the back-end
 * @param callback
 * @returns {Wallet}
 */
Wallet.prototype.refresh = function (params, callback) {
    return co(function () {
        var query, res;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    query = _.extend({}, _.pick(params, ['gpk']));
                    return [4 /*yield*/, this.bitgo.get(this.url()).query(query).result()];
                case 1:
                    res = _a.sent();
                    this.wallet = res;
                    return [2 /*return*/, this];
            }
        });
    }).call(this).asCallback(callback);
};
//
// address
// Gets information about a single address on a HD wallet.
// Information includes index, path, redeemScript, sent, received, txCount and balance
// Options include:
//  address: the address on this wallet to get
//
Wallet.prototype.address = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address'], [], callback);
    var url = this.url('/addresses/' + params.address);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
/**
 * Freeze the wallet for a duration of choice, stopping BitGo from signing any transactions.
 * @param {number} limit The duration to freeze the wallet for in seconds, defaults to 3600.
 */
Wallet.prototype.freeze = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (params.duration) {
        if (!_.isNumber(params.duration)) {
            throw new Error('invalid duration - should be number of seconds');
        }
    }
    return this.bitgo.post(this.url('/freeze'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// delete
// Deletes the wallet
//
Wallet.prototype.delete = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.del(this.url())
        .result()
        .nodeify(callback);
};
//
// labels
// List the labels for the addresses in a given wallet
//
Wallet.prototype.labels = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var url = this.bitgo.url('/labels/' + this.id());
    return this.bitgo.get(url)
        .result('labels')
        .nodeify(callback);
};
/**
 * Rename a wallet
 * @param params
 *  - label: the wallet's intended new name
 * @param callback
 * @returns {*}
 */
Wallet.prototype.setWalletName = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['label'], [], callback);
    var url = this.bitgo.url('/wallet/' + this.id());
    return this.bitgo.put(url)
        .send({ label: params.label })
        .result()
        .nodeify(callback);
};
//
// setLabel
// Sets a label on the provided address
//
Wallet.prototype.setLabel = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address', 'label'], [], callback);
    var self = this;
    if (!self.bitgo.verifyAddress({ address: params.address })) {
        throw new Error('Invalid bitcoin address: ' + params.address);
    }
    var url = this.bitgo.url('/labels/' + this.id() + '/' + params.address);
    return this.bitgo.put(url)
        .send({ label: params.label })
        .result()
        .nodeify(callback);
};
//
// deleteLabel
// Deletes the label associated with the provided address
//
Wallet.prototype.deleteLabel = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address'], [], callback);
    var self = this;
    if (!self.bitgo.verifyAddress({ address: params.address })) {
        throw new Error('Invalid bitcoin address: ' + params.address);
    }
    var url = this.bitgo.url('/labels/' + this.id() + '/' + params.address);
    return this.bitgo.del(url)
        .result()
        .nodeify(callback);
};
//
// unspents
// List ALL the unspents for a given wallet
// This method will return a paged list of all unspents
//
// Parameters include:
//   limit:  the optional limit of unspents to collect in BTC
//   minConf: only include results with this number of confirmations
//   target: the amount of btc to find to spend
//   instant: only find instant transactions (must specify a target)
//
Wallet.prototype.unspents = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var allUnspents = [];
    var self = this;
    var getUnspentsBatch = function (skip, limit) {
        var queryObject = _.cloneDeep(params);
        if (skip > 0) {
            queryObject.skip = skip;
        }
        if (limit && limit > 0) {
            queryObject.limit = limit;
        }
        return self.unspentsPaged(queryObject)
            .then(function (result) {
            // The API has its own limit handling. For example, the API does not support limits bigger than 500. If the limit
            // specified here is bigger than that, we will have to do multiple requests with necessary limit adjustment.
            for (var i = 0; i < result.unspents.length; i++) {
                var unspent = result.unspents[i];
                allUnspents.push(unspent);
            }
            // Our limit adjustment makes sure that we never fetch more unspents than we need, meaning that if we hit the
            // limit, we hit it precisely
            if (allUnspents.length >= params.limit) {
                return allUnspents; // we aren't interested in any further unspents
            }
            var totalUnspentCount = result.total;
            // if no target is specified and the SDK indicates that there has been a limit, we need to fetch another batch
            if (!params.target && totalUnspentCount && totalUnspentCount > allUnspents.length) {
                // we need to fetch the next batch
                // let's just offset the current skip by the count
                var newSkip = skip + result.count;
                var newLimit = null;
                if (limit > 0) {
                    // we set the new limit to be precisely the number of missing unspents to hit our own limit
                    newLimit = limit - allUnspents.length;
                }
                return getUnspentsBatch(newSkip, newLimit);
            }
            return allUnspents;
        });
    };
    return getUnspentsBatch(0, params.limit)
        .nodeify(callback);
};
/**
 * List the unspents (paged) for a given wallet, returning the result as an object of unspents, count, skip and total
 * This method may not return all the unspents as the list is paged by the API
 * @param params
 * @param params.limit the optional limit of unspents to collect in BTC
 * @param params.skip index in list of unspents to start paging from
 * @param params.minConfirms only include results with this number of confirmations
 * @param params.target the amount of btc to find to spend
 * @param params.instant only find instant transactions (must specify a target)
 * @param params.targetWalletUnspents desired number of unspents to have in the wallet after the tx goes through (requires target)
 * @param params.minSize minimum unspent size in satoshis
 * @param params.segwit request segwit unspents (defaults to true if undefined)
 * @param params.allowLedgerSegwit allow segwit unspents for ledger devices (defaults to false if undefined)
 * @param callback
 * @returns {*}
 */
Wallet.prototype.unspentsPaged = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (!_.isUndefined(params.limit) && !_.isInteger(params.limit)) {
        throw new Error('invalid limit - should be number');
    }
    if (!_.isUndefined(params.skip) && !_.isInteger(params.skip)) {
        throw new Error('invalid skip - should be number');
    }
    if (!_.isUndefined(params.minConfirms) && !_.isInteger(params.minConfirms)) {
        throw new Error('invalid minConfirms - should be number');
    }
    if (!_.isUndefined(params.target) && !_.isNumber(params.target)) {
        throw new Error('invalid target - should be number');
    }
    if (!_.isUndefined(params.instant) && !_.isBoolean(params.instant)) {
        throw new Error('invalid instant flag - should be boolean');
    }
    if (!_.isUndefined(params.segwit) && !_.isBoolean(params.segwit)) {
        throw new Error('invalid segwit flag - should be boolean');
    }
    if (!_.isUndefined(params.targetWalletUnspents) && !_.isInteger(params.targetWalletUnspents)) {
        throw new Error('invalid targetWalletUnspents flag - should be number');
    }
    if (!_.isUndefined(params.minSize) && !_.isNumber(params.minSize)) {
        throw new Error('invalid argument: minSize must be a number');
    }
    if (!_.isUndefined(params.instant) && !_.isUndefined(params.minConfirms)) {
        throw new Error('only one of instant and minConfirms may be defined');
    }
    if (!_.isUndefined(params.targetWalletUnspents) && _.isUndefined(params.target)) {
        throw new Error('targetWalletUnspents can only be specified in conjunction with a target');
    }
    if (!_.isUndefined(params.allowLedgerSegwit) && !_.isBoolean(params.allowLedgerSegwit)) {
        throw new Error('invalid argument: allowLedgerSegwit must be a boolean');
    }
    var queryObject = _.cloneDeep(params);
    if (!_.isUndefined(params.target)) {
        // skip and limit are unavailable when a target is specified
        delete queryObject.skip;
        delete queryObject.limit;
    }
    queryObject.segwit = true;
    if (!_.isUndefined(params.segwit)) {
        queryObject.segwit = params.segwit;
    }
    if (!_.isUndefined(params.allowLedgerSegwit)) {
        queryObject.allowLedgerSegwit = params.allowLedgerSegwit;
    }
    return this.bitgo.get(this.url('/unspents'))
        .query(queryObject)
        .result()
        .nodeify(callback);
};
//
// transactions
// List the transactions for a given wallet
// Options include:
//     TODO:  Add iterators for start/count/etc
Wallet.prototype.transactions = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var args = [];
    if (params.limit) {
        if (!_.isInteger(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        args.push('limit=' + params.limit);
    }
    if (params.skip) {
        if (!_.isInteger(params.skip)) {
            throw new Error('invalid skip argument, expecting number');
        }
        args.push('skip=' + params.skip);
    }
    if (params.minHeight) {
        if (!_.isInteger(params.minHeight)) {
            throw new Error('invalid minHeight argument, expecting number');
        }
        args.push('minHeight=' + params.minHeight);
    }
    if (params.maxHeight) {
        if (!_.isInteger(params.maxHeight) || params.maxHeight < 0) {
            throw new Error('invalid maxHeight argument, expecting positive integer');
        }
        args.push('maxHeight=' + params.maxHeight);
    }
    if (params.minConfirms) {
        if (!_.isInteger(params.minConfirms) || params.minConfirms < 0) {
            throw new Error('invalid minConfirms argument, expecting positive integer');
        }
        args.push('minConfirms=' + params.minConfirms);
    }
    if (!_.isUndefined(params.compact)) {
        if (!_.isBoolean(params.compact)) {
            throw new Error('invalid compact argument, expecting boolean');
        }
        args.push('compact=' + params.compact);
    }
    var query = '';
    if (args.length) {
        query = '?' + args.join('&');
    }
    var url = this.url('/tx' + query);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
//
// transaction
// Get a transaction by ID for a given wallet
Wallet.prototype.getTransaction = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    var url = this.url('/tx/' + params.id);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
//
// pollForTransaction
// Poll a transaction until successful or times out
// Parameters:
//   id: the txid
//   delay: delay between polls in ms (default: 1000)
//   timeout: timeout in ms (default: 10000)
Wallet.prototype.pollForTransaction = function (params, callback) {
    var self = this;
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    if (params.delay && !_.isNumber(params.delay)) {
        throw new Error('invalid delay parameter');
    }
    if (params.timeout && !_.isNumber(params.timeout)) {
        throw new Error('invalid timeout parameter');
    }
    params.delay = params.delay || 1000;
    params.timeout = params.timeout || 10000;
    var start = new Date();
    var doNextPoll = function () {
        return self.getTransaction(params)
            .then(function (res) {
            return res;
        })
            .catch(function (err) {
            if (err.status !== 404 || new Date().valueOf() - start.valueOf() > params.timeout) {
                throw err;
            }
            return Promise.delay(params.delay)
                .then(function () {
                return doNextPoll();
            });
        });
    };
    return doNextPoll();
};
//
// transaction by sequence id
// Get a transaction by sequence id for a given wallet
Wallet.prototype.getWalletTransactionBySequenceId = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['sequenceId'], [], callback);
    var url = this.url('/tx/sequence/' + params.sequenceId);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
//
// Key chains
// Gets the user key chain for this wallet
// The user key chain is typically the first keychain of the wallet and has the encrypted xpriv stored on BitGo.
// Useful when trying to get the users' keychain from the server before decrypting to sign a transaction.
Wallet.prototype.getEncryptedUserKeychain = function (params, callback) {
    return co(function () {
        var self, tryKeyChain;
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, [], [], callback);
            self = this;
            tryKeyChain = co(function (index) {
                var error, params, keychain;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!self.keychains || index >= self.keychains.length) {
                                error = new Error('No encrypted keychains on this wallet.');
                                error.code = 'no_encrypted_keychain_on_wallet';
                                throw error;
                            }
                            params = { xpub: self.keychains[index].xpub };
                            return [4 /*yield*/, self.bitgo.keychains().get(params)];
                        case 1:
                            keychain = _a.sent();
                            // If we find the xprv, then this is probably the user keychain we're looking for
                            keychain.walletSubPath = self.keychains[index].path;
                            if (keychain.encryptedXprv) {
                                return [2 /*return*/, keychain];
                            }
                            return [2 /*return*/, tryKeyChain(index + 1)];
                    }
                });
            });
            return [2 /*return*/, tryKeyChain(0)];
        });
    }).call(this).asCallback(callback);
};
//
// createTransaction
// Create a transaction (unsigned). To sign it, do signTransaction
// Parameters:
//   recipients - object of recipient addresses and the amount to send to each e.g. {address:1500, address2:1500}
//   fee      - the blockchain fee to send (optional)
//   feeRate  - the fee per kb to send (optional)
//   minConfirms - minimum number of confirms to use when gathering unspents
//   forceChangeAtEnd - force change address to be last output (optional)
//   noSplitChange - disable automatic change splitting for purposes of unspent management
//   changeAddress - override the change address (optional)
//   validate - extra verification of change addresses (which are always verified server-side) (defaults to global config)
// Returns:
//   callback(err, { transactionHex: string, unspents: [inputs], fee: satoshis })
Wallet.prototype.createTransaction = function (params, callback) {
    params = _.extend({}, params);
    common.validateParams(params, [], [], callback);
    if ((!_.isNumber(params.fee) && !_.isUndefined(params.fee)) ||
        (!_.isNumber(params.feeRate) && !_.isUndefined(params.feeRate)) ||
        (!_.isNumber(params.minConfirms) && !_.isUndefined(params.minConfirms)) ||
        (!_.isBoolean(params.forceChangeAtEnd) && !_.isUndefined(params.forceChangeAtEnd)) ||
        (!_.isString(params.changeAddress) && !_.isUndefined(params.changeAddress)) ||
        (!_.isBoolean(params.validate) && !_.isUndefined(params.validate)) ||
        (!_.isBoolean(params.instant) && !_.isUndefined(params.instant))) {
        throw new Error('invalid argument');
    }
    if (!_.isObject(params.recipients)) {
        throw new Error('expecting recipients object');
    }
    params.validate = params.validate !== undefined ? params.validate : this.bitgo.getValidate();
    params.wallet = this;
    return TransactionBuilder.createTransaction(params)
        .nodeify(callback);
};
//
// signTransaction
// Sign a previously created transaction with a keychain
// Parameters:
// transactionHex - serialized form of the transaction in hex
// unspents - array of unspent information, where each unspent is a chainPath
//            and redeemScript with the same index as the inputs in the
//            transactionHex
// keychain - Keychain containing the xprv to sign with.
// signingKey - For legacy safe wallets, the private key string.
// validate - extra verification of signatures (which are always verified server-side) (defaults to global config)
// Returns:
//   callback(err, transaction)
Wallet.prototype.signTransaction = function (params, callback) {
    params = _.extend({}, params);
    common.validateParams(params, ['transactionHex'], [], callback);
    if (!Array.isArray(params.unspents)) {
        throw new Error('expecting the unspents array');
    }
    if ((!_.isObject(params.keychain) || !params.keychain.xprv) && !_.isString(params.signingKey)) {
        // allow passing in a WIF private key for legacy safe wallet support
        var error = new Error('expecting keychain object with xprv or signingKey WIF');
        error.code = 'missing_keychain_or_signingKey';
        throw error;
    }
    params.validate = params.validate !== undefined ? params.validate : this.bitgo.getValidate();
    return TransactionBuilder.signTransaction(params)
        .then(function (result) {
        return {
            tx: result.transactionHex
        };
    })
        .nodeify(callback);
};
//
// send
// Send a transaction to the Bitcoin network via BitGo.
// One of the keys is typically signed, and BitGo will sign the other (if approved) and relay it to the P2P network.
// Parameters:
//   tx  - the hex encoded, signed transaction to send
// Returns:
//
Wallet.prototype.sendTransaction = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['tx'], ['message', 'otp'], callback);
    return this.bitgo.post(this.bitgo.url('/tx/send'))
        .send(params)
        .result()
        .then(function (body) {
        if (body.pendingApproval) {
            return _.extend(body, { status: 'pendingApproval' });
        }
        if (body.otp) {
            return _.extend(body, { status: 'otp' });
        }
        return {
            status: 'accepted',
            tx: body.transaction,
            hash: body.transactionHash,
            instant: body.instant,
            instantId: body.instantId
        };
    })
        .nodeify(callback);
};
/**
 * Share the wallet with an existing BitGo user.
 * @param {string} user The recipient's user id, must have a corresponding user record in our database.
 * @param {keychain} keychain The keychain to be shared with the recipient.
 * @param {string} permissions A comma-separated value string that specifies the recipient's permissions if the share is accepted.
 * @param {string} message The message to be used for this share.
 */
Wallet.prototype.createShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['user', 'permissions'], [], callback);
    if (params.keychain && !_.isEmpty(params.keychain)) {
        if (!params.keychain.xpub || !params.keychain.encryptedXprv || !params.keychain.fromPubKey || !params.keychain.toPubKey || !params.keychain.path) {
            throw new Error('requires keychain parameters - xpub, encryptedXprv, fromPubKey, toPubKey, path');
        }
    }
    return this.bitgo.post(this.url('/share'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// createInvite
// invite a non BitGo customer to join a wallet
// Parameters:
//   email - the recipient's email address
//   permissions - the recipient's permissions if the share is accepted
// Returns:
//
Wallet.prototype.createInvite = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['email', 'permissions'], ['message'], callback);
    var options = {
        toEmail: params.email,
        permissions: params.permissions
    };
    if (params.message) {
        options.message = params.message;
    }
    return this.bitgo.post(this.url('/invite'))
        .send(options)
        .result()
        .nodeify(callback);
};
//
// confirmInviteAndShareWallet
// confirm my invite on this wallet to a recipient who has
// subsequently signed up by creating the actual wallet share
// Parameters:
//   walletInviteId - the wallet invite id
//   walletPassphrase - required if the wallet share success is expected
// Returns:
//
Wallet.prototype.confirmInviteAndShareWallet = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletInviteId'], ['walletPassphrase'], callback);
    var self = this;
    return this.bitgo.wallets().listInvites()
        .then(function (invites) {
        var outgoing = invites.outgoing;
        var invite = _.find(outgoing, function (out) {
            return out.id === params.walletInviteId;
        });
        if (!invite) {
            throw new Error('wallet invite not found');
        }
        var options = {
            email: invite.toEmail,
            permissions: invite.permissions,
            message: invite.message,
            walletPassphrase: params.walletPassphrase
        };
        return self.shareWallet(options);
    })
        .then(function () {
        return this.bitgo.put(this.bitgo.url('/walletinvite/' + params.walletInviteId));
    })
        .nodeify(callback);
};
//
// sendCoins
// Send coins to a destination address from this wallet using the user key.
// 1. Gets the user keychain by checking the wallet for a key which has an encrypted xpriv
// 2. Decrypts user key
// 3. Creates the transaction with default fee
// 4. Signs transaction with decrypted user key
// 3. Sends the transaction to BitGo
//
// Parameters:
//   address - the destination address
//   amount - the amount in satoshis to be sent
//   message - optional message to attach to transaction
//   walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
//   xprv - the private key in string form, if walletPassphrase is not available
//   (See transactionBuilder.createTransaction for other passthrough params)
// Returns:
//
Wallet.prototype.sendCoins = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address'], ['message'], callback);
    if (!_.isNumber(params.amount)) {
        throw new Error('invalid argument for amount - number expected');
    }
    params.recipients = {};
    params.recipients[params.address] = params.amount;
    return this.sendMany(params)
        .nodeify(callback);
};
//
// sendMany
// Send coins to multiple destination addresses from this wallet using the user key.
// 1. Gets the user keychain by checking the wallet for a key which has an encrypted xpriv
// 2. Decrypts user key
// 3. Creates the transaction with default fee
// 4. Signs transaction with decrypted user key
// 3. Sends the transaction to BitGo
//
// Parameters:
//   recipients - array of { address: string, amount: number, travelInfo: object } to send to
//   walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
//   xprv - the private key in string form, if walletPassphrase is not available
//   (See transactionBuilder.createTransaction for other passthrough params)
// Returns:
//
Wallet.prototype.sendMany = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['message', 'otp'], callback);
    var self = this;
    if (!_.isObject(params.recipients)) {
        throw new Error('expecting recipients object');
    }
    if (params.fee && !_.isNumber(params.fee)) {
        throw new Error('invalid argument for fee - number expected');
    }
    if (params.feeRate && !_.isNumber(params.feeRate)) {
        throw new Error('invalid argument for feeRate - number expected');
    }
    if (params.instant && !_.isBoolean(params.instant)) {
        throw new Error('invalid argument for instant - boolean expected');
    }
    var bitgoFee;
    var travelInfos;
    var finalResult;
    var unspentsUsed;
    var acceptedBuildParams = [
        'numBlocks', 'feeRate', 'minConfirms', 'enforceMinConfirmsForChange',
        'targetWalletUnspents', 'message', 'minValue', 'maxValue',
        'noSplitChange', 'comment'
    ];
    var preservedBuildParams = _.pick(params, acceptedBuildParams);
    // Get the user keychain
    return this.createAndSignTransaction(params)
        .then(function (transaction) {
        // Send the transaction
        bitgoFee = transaction.bitgoFee;
        travelInfos = transaction.travelInfos;
        unspentsUsed = transaction.unspents;
        return self.sendTransaction({
            tx: transaction.tx,
            message: params.message,
            sequenceId: params.sequenceId,
            instant: params.instant,
            otp: params.otp,
            // The below params are for logging only, and do not impact the API call
            estimatedSize: transaction.estimatedSize,
            buildParams: preservedBuildParams
        });
    })
        .then(function (result) {
        var tx = bitcoin.Transaction.fromHex(result.tx);
        var inputsSum = _.sumBy(unspentsUsed, 'value');
        var outputsSum = _.sumBy(tx.outs, 'value');
        var feeUsed = inputsSum - outputsSum;
        if (isNaN(feeUsed)) {
            throw new Error('invalid feeUsed');
        }
        result.fee = feeUsed,
            result.feeRate = feeUsed * 1000 / tx.virtualSize();
        result.travelInfos = travelInfos;
        if (bitgoFee) {
            result.bitgoFee = bitgoFee;
        }
        finalResult = result;
        // Handle sending travel infos if they exist, but make sure we never fail here.
        // Error or result (with possible sub-errors) will be provided in travelResult
        if (travelInfos && travelInfos.length) {
            try {
                return self.pollForTransaction({ id: result.hash })
                    .then(function () {
                    return self.bitgo.travelRule().sendMany(result);
                })
                    .then(function (res) {
                    finalResult.travelResult = res;
                })
                    .catch(function (err) {
                    // catch async errors
                    finalResult.travelResult = { error: err.message };
                });
            }
            catch (err) {
                // catch synchronous errors
                finalResult.travelResult = { error: err.message };
            }
        }
    })
        .then(function () {
        return finalResult;
    })
        .nodeify(callback);
};
/**
 * Accelerate a stuck transaction using Child-Pays-For-Parent (CPFP).
 *
 * This should only be used for stuck transactions which have no unconfirmed inputs.
 *
 * @param {Object} params - Input parameters
 * @param {String} params.transactionID - ID of transaction to accelerate
 * @param {Number} params.feeRate - New effective fee rate for stuck transaction (sat per 1000 bytes)
 * @param {Number} params.maxAdditionalUnspents - Maximum additional unspents to use from the wallet to cover any child fees that the parent unspent output cannot cover. Defaults to 100.
 * @param {String} params.walletPassphrase - The passphrase which should be used to decrypt the wallet private key. One of either walletPassphrase or xprv is required.
 * @param {String} params.xprv - The private key for the wallet. One of either walletPassphrase or xprv is required.
 * @param {Function} callback
 * @returns Result of sendTransaction() on the child transaction
 */
Wallet.prototype.accelerateTransaction = function accelerateTransaction(params, callback) {
    var _this = this;
    /**
     * Helper function to estimate a transactions size in virtual bytes.
     * Actual transactions may be slightly fewer virtual bytes, due to
     * the fact that valid ECSDA signatures have a variable length
     * between 8 and 73 virtual bytes.
     *
     * @param inputs.segwit The number of segwit inputs to the transaction
     * @param inputs.P2SH The number of P2SH inputs to the transaction
     * @param inputs.P2PKH The number of P2PKH inputs to the transaction
     */
    var estimateTxVSize = function (inputs) {
        var segwit = inputs.segwit || 0;
        var P2SH = inputs.P2SH || 0;
        var P2PKH = inputs.P2PKH || 0;
        var childFeeInfo = TransactionBuilder.calculateMinerFeeInfo({
            nP2shInputs: P2SH,
            nP2pkhInputs: P2PKH,
            nP2shP2wshInputs: segwit,
            nOutputs: 1,
            feeRate: 1
        });
        return childFeeInfo.size;
    };
    /**
     * Calculate the number of satoshis that should be paid in fees by the child transaction
     *
     * @param inputs Inputs to the child transaction which are passed to estimateTxVSize
     * @param parentFee The number of satoshis the parent tx originally paid in fees
     * @param parentVSize The number of virtual bytes in the parent tx
     * @param feeRate The new fee rate which should be paid by the combined CPFP transaction
     * @returns {number} The number of satoshis the child tx should pay in fees
     */
    var estimateChildFee = function (_a) {
        var inputs = _a.inputs, parentFee = _a.parentFee, parentVSize = _a.parentVSize, feeRate = _a.feeRate;
        // calculate how much more we *should* have paid in parent fees,
        // had the parent been originally sent with the new fee rate
        var additionalParentFee = _.ceil(parentVSize * feeRate / 1000) - parentFee;
        // calculate how much we would pay in fees for the child,
        // if it were only paying for itself at the new fee rate
        var childFee = estimateTxVSize(inputs) * feeRate / 1000;
        return _.ceil(childFee + additionalParentFee);
    };
    /**
     * Helper function to find additional unspents to use to pay the child tx fees.
     * This function is called when the the parent tx output is not sufficient to
     * cover the total fees which should be paid by the child tx.
     *
     * @param inputs Inputs to the child transaction which are passed to estimateTxVSize
     * @param parentOutputValue The value of the output from the parent tx which we are using as an input to the child tx
     * @param parentFee The number of satoshis the parent tx originally paid in fees
     * @param parentVSize The number of virtual bytes in the parent tx
     * @param maxUnspents The maximum number of additional unspents which should be used to cover the remaining child fees
     * @returns An object with the additional unspents to use, the updated number of satoshis which should be paid by
     *          the child tx, and the updated inputs for the child tx.
     */
    var findAdditionalUnspents = function (_a) {
        var inputs = _a.inputs, parentOutputValue = _a.parentOutputValue, parentFee = _a.parentFee, parentVSize = _a.parentVSize, maxUnspents = _a.maxUnspents;
        return co(function coFindAdditionalUnspents() {
            var additionalUnspents, currentChildFeeEstimate, uncoveredChildFee, _loop_1, this_1, state_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        additionalUnspents = [];
                        currentChildFeeEstimate = estimateChildFee({ inputs: inputs, parentFee: parentFee, parentVSize: parentVSize, feeRate: params.feeRate });
                        uncoveredChildFee = currentChildFeeEstimate - parentOutputValue;
                        _loop_1 = function () {
                            var unspents, additionalUnspentValue;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this_1.unspents({
                                            minConfirms: 1,
                                            target: uncoveredChildFee,
                                            limit: maxUnspents - additionalUnspents.length
                                        })];
                                    case 1:
                                        unspents = _a.sent();
                                        if (unspents.length === 0) {
                                            return [2 /*return*/, "break"];
                                        }
                                        additionalUnspentValue = 0;
                                        // consume all unspents returned by the server, even if we don't need
                                        // all of them to cover the child fee. This is because the server will
                                        // return enough unspent value to ensure that the minimum change amount
                                        // is achieved for the child tx, and we can't leave out those unspents
                                        // or else the minimum change amount constraint could be violated
                                        _.forEach(unspents, function (unspent) {
                                            // update the child tx inputs
                                            var unspentChain = getChain(unspent);
                                            if (unspentChain === unspents_1.Codes.p2shP2wsh.external || unspentChain === unspents_1.Codes.p2shP2wsh.internal) {
                                                inputs.segwit++;
                                            }
                                            else {
                                                inputs.P2SH++;
                                            }
                                            additionalUnspents.push(unspent);
                                            additionalUnspentValue += unspent.value;
                                        });
                                        currentChildFeeEstimate = estimateChildFee({ inputs: inputs, parentFee: parentFee, parentVSize: parentVSize, feeRate: params.feeRate });
                                        uncoveredChildFee = currentChildFeeEstimate - parentOutputValue - additionalUnspentValue;
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _a.label = 1;
                    case 1:
                        if (!(uncoveredChildFee > 0 && additionalUnspents.length < maxUnspents)) return [3 /*break*/, 3];
                        return [5 /*yield**/, _loop_1()];
                    case 2:
                        state_1 = _a.sent();
                        if (state_1 === "break")
                            return [3 /*break*/, 3];
                        return [3 /*break*/, 1];
                    case 3:
                        if (uncoveredChildFee > 0) {
                            // Unable to find enough unspents to cover the child fee
                            throw new Error("Insufficient confirmed unspents available to cover the child fee");
                        }
                        // found enough unspents
                        return [2 /*return*/, {
                                additional: additionalUnspents,
                                newChildFee: currentChildFeeEstimate,
                                newInputs: inputs
                            }];
                }
            });
        }).call(_this);
    };
    /**
     * Helper function to get a full copy (including witness data) of an arbitrary tx using only the tx id.
     *
     * We have to use an external service for this (currently smartbit.com.au), since
     * the v1 indexer service (based on bitcoinj) does not have segwit support and
     * does not return any segwit related fields in the tx hex.
     *
     * @param parentTxId The ID of the transaction to get the full hex of
     * @returns {Bluebird<any>} The full hex for the specified transaction
     */
    var getParentTxHex = function (_a) {
        var parentTxId = _a.parentTxId;
        return co(function coGetParentTxHex() {
            var smartBitApiUrl, txUrl, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        smartBitApiUrl = common.Environments[this.bitgo.getEnv()].smartBitApiBaseUrl + '/blockchain/tx/';
                        txUrl = smartBitApiUrl + parentTxId + '/hex';
                        return [4 /*yield*/, request.get(txUrl)];
                    case 1:
                        result = _a.sent();
                        if (!_.isBoolean(result.body.success) || !result.body.success) {
                            throw new Error('Did not successfully receive parent tx hex');
                        }
                        return [2 /*return*/, result.body.hex[0].hex];
                }
            });
        }).call(_this);
    };
    /**
     * Helper function to get the chain from an unspent or tx output.
     *
     * @param outputOrUnspent The output or unspent whose chain should be determined
     * @returns {number} The chain for the given output or unspent
     */
    var getChain = function (outputOrUnspent) {
        if (outputOrUnspent.chain !== undefined) {
            return outputOrUnspent.chain;
        }
        if (outputOrUnspent.chainPath !== undefined) {
            return _.toNumber(outputOrUnspent.chainPath.split('/')[1]);
        }
        // no way to tell the chain, let's just blow up now instead
        // of blowing up later when the undefined return value is used.
        // Note: for unspents the field to use is 'address', but for outputs
        // the field to use is 'account'
        throw Error("Could not get chain for output on account " + (outputOrUnspent.account || outputOrUnspent.address));
    };
    /**
     * Helper function to calculate the actual value contribution an output or unspent will
     * contribute to a transaction, were it to be used. Each type of output or unspent
     * will have a different value contribution since each type has a different number
     * of virtual bytes, and thus will cause a different fee to be paid.
     *
     * @param outputOrUnspent Output or unspent whose effective value should be determined
     * @returns {number} The actual number of satoshis that this unspent or output
     *                   would contribute to a transaction, were it to be used.
     */
    var effectiveValue = function (outputOrUnspent) {
        var chain = getChain(outputOrUnspent);
        if (chain === unspents_1.Codes.p2shP2wsh.external || chain === unspents_1.Codes.p2shP2wsh.internal) {
            // VirtualSizes.txP2shP2wshInputSize is in bytes, so we need to convert to kB
            return outputOrUnspent.value - (unspents_1.VirtualSizes.txP2shP2wshInputSize * params.feeRate / 1000);
        }
        // VirtualSizes.txP2shInputSize is in bytes, so we need to convert to kB
        return outputOrUnspent.value - (unspents_1.VirtualSizes.txP2shInputSize * params.feeRate / 1000);
    };
    /**
     * Coroutine which actually implements the accelerateTransaction algorithm
     *
     * Described at a high level, the algorithm is as follows:
     * 1) Find appropriate output from parent transaction to use as child transaction input
     * 2) Find unspent corresponding to parent transaction output. If not found, return to step 1.
     * 3) Determine if parent transaction unspent can cover entire child fee, plus minimum change
     * 4) If yes, go to step 6
     * 5) Otherwise, find additional unspents from the wallet to use to cover the remaining child fee
     * 6) Create and sign the child transaction, using the parent transaction output
     *    (and, if necessary, additional wallet unspents) as inputs
     * 7) Broadcast the new child transaction
     */
    return co(function coAccelerateTransaction() {
        var parentTx, walletOutputs, sortedOutputs, parentUnspentToUse, outputToUse, unspentsResult, parentTxHex, decodedParent, parentVSize, parentRate, isParentOutputSegwit, childInputs, childFee, unspentsToUse, minChangeSize, _a, additional, newChildFee, newInputs, maxFeeRate, childVSize, combinedVSize, combinedFee, combinedFeeRate, changeAmount, changeChain, changeAddress, tx, childFeeRate;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    params = params || {};
                    common.validateParams(params, ['transactionID'], [], callback);
                    // validate fee rate
                    if (params.feeRate === undefined) {
                        throw new Error('Missing parameter: feeRate');
                    }
                    if (!_.isFinite(params.feeRate) || params.feeRate <= 0) {
                        throw new Error('Expecting positive finite number for parameter: feeRate');
                    }
                    // validate maxUnspents
                    if (params.maxAdditionalUnspents === undefined) {
                        // by default, use at most 100 additional unspents (not including the unspent output from the parent tx)
                        params.maxAdditionalUnspents = 100;
                    }
                    if (!_.isInteger(params.maxAdditionalUnspents) || params.maxAdditionalUnspents <= 0) {
                        throw Error('Expecting positive integer for parameter: maxAdditionalUnspents');
                    }
                    return [4 /*yield*/, this.getTransaction({ id: params.transactionID })];
                case 1:
                    parentTx = _b.sent();
                    if (parentTx.confirmations > 0) {
                        throw new Error("Transaction " + params.transactionID + " is already confirmed and cannot be accelerated");
                    }
                    walletOutputs = _.filter(parentTx.outputs, function (output) { return output.isMine; });
                    if (walletOutputs.length === 0) {
                        throw new Error("Transaction " + params.transactionID + " contains no outputs to this wallet, and thus cannot be accelerated");
                    }
                    sortedOutputs = _.sortBy(walletOutputs, effectiveValue);
                    _b.label = 2;
                case 2:
                    if (!(sortedOutputs.length > 0 && parentUnspentToUse === undefined)) return [3 /*break*/, 4];
                    outputToUse = sortedOutputs.pop();
                    return [4 /*yield*/, this.unspents({
                            minSize: outputToUse.value,
                            maxSize: outputToUse.value
                        })];
                case 3:
                    unspentsResult = _b.sent();
                    parentUnspentToUse = _.find(unspentsResult, function (unspent) {
                        // make sure unspent belongs to the given txid
                        if (unspent.tx_hash !== params.transactionID) {
                            return false;
                        }
                        // make sure unspent has correct v_out index
                        return unspent.tx_output_n === outputToUse.vout;
                    });
                    return [3 /*break*/, 2];
                case 4:
                    if (parentUnspentToUse === undefined) {
                        throw new Error("Could not find unspent output from parent tx to use as child input");
                    }
                    return [4 /*yield*/, getParentTxHex({ parentTxId: params.transactionID })];
                case 5:
                    parentTxHex = _b.sent();
                    decodedParent = bitcoin.Transaction.fromHex(parentTxHex);
                    parentVSize = decodedParent.virtualSize();
                    // make sure id from decoded tx and given tx id match
                    // this should catch problems emanating from the use of an external service
                    // for getting the complete parent tx hex
                    if (decodedParent.getId() !== params.transactionID) {
                        throw new Error("Decoded transaction id is " + decodedParent.getId() + ", which does not match given txid " + params.transactionID);
                    }
                    parentRate = 1000 * parentTx.fee / parentVSize;
                    if (params.feeRate <= parentRate) {
                        throw new Error("Cannot lower fee rate! (Parent tx fee rate is " + parentRate + " sat/kB, and requested fee rate was " + params.feeRate + " sat/kB)");
                    }
                    isParentOutputSegwit = outputToUse.chain === unspents_1.Codes.p2shP2wsh.external ||
                        outputToUse.chain === unspents_1.Codes.p2shP2wsh.internal;
                    childInputs = {
                        segwit: isParentOutputSegwit ? 1 : 0,
                        P2SH: isParentOutputSegwit ? 0 : 1
                    };
                    childFee = estimateChildFee({
                        inputs: childInputs,
                        parentFee: parentTx.fee,
                        feeRate: params.feeRate,
                        parentVSize: parentVSize
                    });
                    unspentsToUse = [parentUnspentToUse];
                    minChangeSize = this.bitgo.getConstants().minChangeSize || 1e7;
                    if (!(outputToUse.value < childFee + minChangeSize)) return [3 /*break*/, 7];
                    return [4 /*yield*/, findAdditionalUnspents({
                            inputs: childInputs,
                            parentOutputValue: outputToUse.value,
                            parentFee: parentTx.fee,
                            maxUnspents: params.maxAdditionalUnspents,
                            parentVSize: parentVSize
                        })];
                case 6:
                    _a = _b.sent(), additional = _a.additional, newChildFee = _a.newChildFee, newInputs = _a.newInputs;
                    childFee = newChildFee;
                    childInputs = newInputs;
                    unspentsToUse.push.apply(unspentsToUse, additional);
                    _b.label = 7;
                case 7:
                    maxFeeRate = this.bitgo.getConstants().maxFeeRate;
                    childVSize = estimateTxVSize(childInputs);
                    combinedVSize = childVSize + parentVSize;
                    combinedFee = parentTx.fee + childFee;
                    combinedFeeRate = 1000 * combinedFee / combinedVSize;
                    if (combinedFeeRate > maxFeeRate) {
                        throw new Error("Transaction cannot be accelerated. Combined fee rate of " + combinedFeeRate + " sat/kB exceeds maximum fee rate of " + maxFeeRate + " sat/kB");
                    }
                    changeAmount = _.sumBy(unspentsToUse, function (unspent) { return unspent.value; }) - childFee;
                    changeChain = this.getChangeChain({});
                    return [4 /*yield*/, this.createAddress({ chain: changeChain })];
                case 8:
                    changeAddress = _b.sent();
                    return [4 /*yield*/, this.createAndSignTransaction({
                            unspents: unspentsToUse,
                            recipients: [{
                                    address: changeAddress.address,
                                    amount: changeAmount
                                }],
                            fee: childFee,
                            bitgoFee: {
                                amount: 0,
                                address: ''
                            },
                            xprv: params.xprv,
                            walletPassphrase: params.walletPassphrase
                        })];
                case 9:
                    tx = _b.sent();
                    childFeeRate = 1000 * childFee / childVSize;
                    if (childFeeRate > maxFeeRate) {
                        // combined tx is within max fee rate limits, but the child tx is not.
                        // in this case, we need to use the ignoreMaxFeeRate flag to get the child tx to be accepted
                        tx.ignoreMaxFeeRate = true;
                    }
                    return [2 /*return*/, this.sendTransaction(tx)];
            }
        });
    }).call(this).asCallback(callback);
};
//
// createAndSignTransaction
// INTERNAL function to create and sign a transaction
//
// Parameters:
//   recipients - array of { address, amount } to send to
//   walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
//   (See transactionBuilder.createTransaction for other passthrough params)
// Returns:
//
Wallet.prototype.createAndSignTransaction = function (params, callback) {
    return co(function () {
        var transaction, fee, feeRate, estimatedSize, bitgoFee, travelInfos, unspents, keychain, e_1, safeUserKey, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    params = params || {};
                    common.validateParams(params, [], [], callback);
                    if (!_.isObject(params.recipients)) {
                        throw new Error('expecting recipients object');
                    }
                    if (params.fee && !_.isNumber(params.fee)) {
                        throw new Error('invalid argument for fee - number expected');
                    }
                    if (params.feeRate && !_.isNumber(params.feeRate)) {
                        throw new Error('invalid argument for feeRate - number expected');
                    }
                    if (params.dynamicFeeConfirmTarget && !_.isNumber(params.dynamicFeeConfirmTarget)) {
                        throw new Error('invalid argument for confirmTarget - number expected');
                    }
                    if (params.instant && !_.isBoolean(params.instant)) {
                        throw new Error('invalid argument for instant - boolean expected');
                    }
                    return [4 /*yield*/, this.createTransaction(params)];
                case 1:
                    transaction = _a.sent();
                    fee = transaction.fee;
                    feeRate = transaction.feeRate;
                    estimatedSize = transaction.estimatedSize;
                    bitgoFee = transaction.bitgoFee;
                    travelInfos = transaction.travelInfos;
                    unspents = transaction.unspents;
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 6]);
                    return [4 /*yield*/, this.getAndPrepareSigningKeychain(params)];
                case 3:
                    keychain = _a.sent();
                    transaction.keychain = keychain;
                    return [3 /*break*/, 6];
                case 4:
                    e_1 = _a.sent();
                    if (e_1.code !== 'no_encrypted_keychain_on_wallet') {
                        throw e_1;
                    }
                    // this might be a safe wallet, so let's retrieve the private key info
                    return [4 /*yield*/, this.refresh({ gpk: true })];
                case 5:
                    // this might be a safe wallet, so let's retrieve the private key info
                    _a.sent();
                    safeUserKey = _.get(this.wallet, 'private.userPrivKey');
                    if (_.isString(safeUserKey) && _.isString(params.walletPassphrase)) {
                        transaction.signingKey = this.bitgo.decrypt({ password: params.walletPassphrase, input: safeUserKey });
                    }
                    else {
                        throw e_1;
                    }
                    return [3 /*break*/, 6];
                case 6:
                    transaction.feeSingleKeyWIF = params.feeSingleKeyWIF;
                    return [4 /*yield*/, this.signTransaction(transaction)];
                case 7:
                    result = _a.sent();
                    return [2 /*return*/, _.extend(result, {
                            fee: fee,
                            feeRate: feeRate,
                            instant: params.instant,
                            bitgoFee: bitgoFee,
                            travelInfos: travelInfos,
                            estimatedSize: estimatedSize,
                            unspents: unspents
                        })];
            }
        });
    }).call(this).asCallback(callback);
};
//
// getAndPrepareSigningKeychain
// INTERNAL function to get the user keychain for signing.
// Caller must provider either a keychain, or walletPassphrase or xprv as a string
// If the caller provides the keychain with xprv, it is simply returned.
// If the caller provides the encrypted xprv (walletPassphrase), then fetch the keychain object and decrypt
// Otherwise if the xprv is provided, fetch the keychain object and augment it with the xprv.
//
// Parameters:
//   keychain - keychain with xprv
//   xprv - the private key in string form
//   walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
// Returns:
//   Keychain object containing xprv, xpub and paths
//
Wallet.prototype.getAndPrepareSigningKeychain = function (params, callback) {
    params = params || {};
    // If keychain with xprv is already provided, use it
    if (_.isObject(params.keychain) && params.keychain.xprv) {
        return Promise.resolve(params.keychain);
    }
    common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
    if ((params.walletPassphrase && params.xprv) || (!params.walletPassphrase && !params.xprv)) {
        throw new Error('must provide exactly one of xprv or walletPassphrase');
    }
    var self = this;
    // Caller provided a wallet passphrase
    if (params.walletPassphrase) {
        return self.getEncryptedUserKeychain()
            .then(function (keychain) {
            // Decrypt the user key with a passphrase
            try {
                keychain.xprv = self.bitgo.decrypt({ password: params.walletPassphrase, input: keychain.encryptedXprv });
            }
            catch (e) {
                throw new Error('Unable to decrypt user keychain');
            }
            return keychain;
        });
    }
    // Caller provided an xprv - validate and construct keychain object
    var xpub;
    try {
        xpub = bitcoin.HDNode.fromBase58(params.xprv).neutered().toBase58();
    }
    catch (e) {
        throw new Error('Unable to parse the xprv');
    }
    if (xpub === params.xprv) {
        throw new Error('xprv provided was not a private key (found xpub instead)');
    }
    var walletXpubs = _.map(self.keychains, 'xpub');
    if (!_.includes(walletXpubs, xpub)) {
        throw new Error('xprv provided was not a keychain on this wallet!');
    }
    // get the keychain object from bitgo to find the path and (potential) wallet structure
    return self.bitgo.keychains().get({ xpub: xpub })
        .then(function (keychain) {
        keychain.xprv = params.xprv;
        return keychain;
    });
};
/**
 * Takes a wallet's unspents and fans them out into a larger number of equally sized unspents
 * @param params
 *  target: set how many unspents you want to have in the end
 *  minConfirms: minimum number of confirms the unspents must have
 *  xprv: private key to sign transaction
 *  walletPassphrase: wallet passphrase to decrypt the wallet's private key
 * @param callback
 * @returns {*}
 */
Wallet.prototype.fanOutUnspents = function (params, callback) {
    var self = this;
    return Promise.coroutine(function () {
        var MAX_FANOUT_INPUT_COUNT, MAX_FANOUT_OUTPUT_COUNT, validate, target, minConfirms, splitNumberIntoCloseNaturalNumbers, allUnspents, grossAmount, txParams, newAddressPromises, newAddresses, splitAmounts, error_1, debugParams, baseFee, totalFee, netAmount, remainingSplitAmounts, fanoutTx, e_2, debugParams;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    MAX_FANOUT_INPUT_COUNT = 80;
                    MAX_FANOUT_OUTPUT_COUNT = 300;
                    params = params || {};
                    common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
                    validate = params.validate === undefined ? true : params.validate;
                    target = params.target;
                    // the target must be defined, be a number, be at least two, and be a natural number
                    if (!_.isNumber(target) || target < 2 || (target % 1) !== 0) {
                        throw new Error('Target needs to be a positive integer');
                    }
                    if (target > MAX_FANOUT_OUTPUT_COUNT) {
                        throw new Error('Fan out target too high');
                    }
                    minConfirms = params.minConfirms;
                    if (minConfirms === undefined) {
                        minConfirms = 1;
                    }
                    if (!_.isNumber(minConfirms) || minConfirms < 0) {
                        throw new Error('minConfirms needs to be an integer >= 0');
                    }
                    splitNumberIntoCloseNaturalNumbers = function (total, partCount) {
                        var partSize = Math.floor(total / partCount);
                        var remainder = total - partSize * partCount;
                        // initialize placeholder array
                        var almostEqualParts = new Array(partCount);
                        // fill the first remainder parts with the value partSize+1
                        _.fill(almostEqualParts, partSize + 1, 0, remainder);
                        // fill the remaining parts with the value partSize
                        _.fill(almostEqualParts, partSize, remainder);
                        // assert the correctness of the almost equal parts
                        // TODO: add check for the biggest deviation between any two parts and make sure it's <= 1
                        if (_(almostEqualParts).sum() !== total || _(almostEqualParts).size() !== partCount) {
                            throw new Error('part sum or part count mismatch');
                        }
                        return almostEqualParts;
                    };
                    return [4 /*yield*/, self.unspents({ minConfirms: minConfirms })];
                case 1:
                    allUnspents = _a.sent();
                    if (allUnspents.length < 1) {
                        throw new Error('No unspents to branch out');
                    }
                    // this consolidation is essentially just a waste of money
                    if (allUnspents.length >= target) {
                        throw new Error('Fan out target has to be bigger than current number of unspents');
                    }
                    // we have at the very minimum 81 inputs, and 81 outputs. That transaction will be big
                    // in the medium run, this algorithm could be reworked to only work with a subset of the transactions
                    if (allUnspents.length > MAX_FANOUT_INPUT_COUNT) {
                        throw new Error('Too many unspents');
                    }
                    grossAmount = _(allUnspents).map('value').sum();
                    txParams = _.extend({}, params);
                    txParams.unspents = allUnspents;
                    txParams.recipients = {};
                    newAddressPromises = _.range(target)
                        .map(function () { return self.createAddress({ chain: self.getChangeChain(params), validate: validate }); });
                    return [4 /*yield*/, Promise.all(newAddressPromises)];
                case 2:
                    newAddresses = _a.sent();
                    splitAmounts = splitNumberIntoCloseNaturalNumbers(grossAmount, target);
                    // map the newly created addresses to the almost components amounts we just calculated
                    txParams.recipients = _.zipObject(_.map(newAddresses, 'address'), splitAmounts);
                    txParams.noSplitChange = true;
                    _a.label = 3;
                case 3:
                    _a.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, self.sendMany(txParams)];
                case 4:
                    _a.sent();
                    return [3 /*break*/, 6];
                case 5:
                    error_1 = _a.sent();
                    // as expected, the transaction creation did indeed fail due to insufficient fees
                    // the error suggests a fee value which we then use for the transaction
                    // however, let's make sure it wasn't something else
                    if (!error_1.fee && (!error_1.result || !error_1.result.fee)) {
                        debugParams = _.omit(txParams, ['walletPassphrase', 'xprv']);
                        error_1.message += "\n\nTX PARAMS:\n " + JSON.stringify(debugParams, null, 4);
                        throw error_1;
                    }
                    baseFee = error_1.fee || error_1.result.fee;
                    totalFee = baseFee;
                    if (error_1.result.bitgoFee && error_1.result.bitgoFee.amount) {
                        totalFee += error_1.result.bitgoFee.amount;
                        txParams.bitgoFee = error_1.result.bitgoFee;
                    }
                    // Need to clear these out since only 1 may be set
                    delete txParams.fee;
                    txParams.originalFeeRate = txParams.feeRate;
                    delete txParams.feeRate;
                    delete txParams.feeTxConfirmTarget;
                    txParams.fee = baseFee;
                    netAmount = error_1.result.available - totalFee;
                    remainingSplitAmounts = splitNumberIntoCloseNaturalNumbers(netAmount, target);
                    // and the distribution again mapped to the new addresses
                    txParams.recipients = _.zipObject(_.map(newAddresses, 'address'), remainingSplitAmounts);
                    return [3 /*break*/, 6];
                case 6:
                    _a.trys.push([6, 8, , 9]);
                    return [4 /*yield*/, self.sendMany(txParams)];
                case 7:
                    fanoutTx = _a.sent();
                    return [3 /*break*/, 9];
                case 8:
                    e_2 = _a.sent();
                    debugParams = _.omit(txParams, ['walletPassphrase', 'xprv']);
                    e_2.message += "\n\nTX PARAMS:\n " + JSON.stringify(debugParams, null, 4);
                    throw e_2;
                case 9: return [2 /*return*/, Promise.resolve(fanoutTx).asCallback(callback)];
            }
        });
    })().asCallback(callback);
};
/**
 * Determine whether to fan out or coalesce a wallet's unspents
 * @param params
 * @param callback
 * @returns {Request|Promise.<T>|*}
 */
Wallet.prototype.regroupUnspents = function (params, callback) {
    params = params || {};
    var target = params.target;
    if (!_.isNumber(target) || target < 1 || (target % 1) !== 0) {
        // the target must be defined, be a number, be at least one, and be a natural number
        throw new Error('Target needs to be a positive integer');
    }
    var minConfirms = params.minConfirms;
    if (minConfirms === undefined) {
        minConfirms = 1;
    }
    if ((!_.isNumber(minConfirms) || minConfirms < 0)) {
        throw new Error('minConfirms needs to be an integer equal to or bigger than 0');
    }
    var self = this;
    return self.unspents({ minConfirms: minConfirms })
        .then(function (unspents) {
        if (unspents.length === target) {
            return unspents;
        }
        else if (unspents.length > target) {
            return self.consolidateUnspents(params, callback);
        }
        else if (unspents.length < target) {
            return self.fanOutUnspents(params, callback);
        }
    });
};
/**
 * Consolidate a wallet's unspents into fewer unspents
 * @param params
 *  target: set how many unspents you want to have in the end
 *  maxInputCountPerConsolidation: set how many maximum inputs are to be permitted per consolidation batch
 *  xprv: private key to sign transaction
 *  walletPassphrase: wallet passphrase to decrypt the wallet's private key
 *  maxIterationCount: maximum number of iterations to be performed until function stops
 *  progressCallback: method to be called with object outlining current progress details
 * @param callback
 * @returns {*}
 */
Wallet.prototype.consolidateUnspents = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
    var validate = params.validate === undefined ? true : params.validate;
    var target = params.target;
    if (target === undefined) {
        target = 1;
    }
    else if (!_.isNumber(target) || target < 1 || (target % 1) !== 0) {
        // the target must be defined, be a number, be at least one, and be a natural number
        throw new Error('Target needs to be a positive integer');
    }
    if (params.maxSize && !_.isNumber(params.maxSize)) {
        throw new Error('maxSize should be a number');
    }
    if (params.minSize && !_.isNumber(params.minSize)) {
        throw new Error('minSize should be a number');
    }
    // maximum number of inputs per transaction for consolidation
    var MAX_INPUT_COUNT = 200;
    var maxInputCount = params.maxInputCountPerConsolidation;
    if (maxInputCount === undefined) { // null or unidentified, because equality to zero returns true in if(! clause
        maxInputCount = MAX_INPUT_COUNT;
    }
    if (typeof (maxInputCount) !== 'number' || maxInputCount < 2 || (maxInputCount % 1) !== 0) {
        throw new Error('Maximum consolidation input count needs to be an integer equal to or bigger than 2');
    }
    else if (maxInputCount > MAX_INPUT_COUNT) {
        throw new Error('Maximum consolidation input count cannot be bigger than ' + MAX_INPUT_COUNT);
    }
    var maxIterationCount = params.maxIterationCount || -1;
    if (params.maxIterationCount && (!_.isNumber(maxIterationCount) || maxIterationCount < 1) || (maxIterationCount % 1) !== 0) {
        throw new Error('Maximum iteration count needs to be an integer equal to or bigger than 1');
    }
    var minConfirms = params.minConfirms;
    if (minConfirms === undefined) {
        minConfirms = 1;
    }
    if ((!_.isNumber(minConfirms) || minConfirms < 0)) {
        throw new Error('minConfirms needs to be an integer equal to or bigger than 0');
    }
    var minSize = params.minSize || 0;
    if (params.feeRate) {
        // fee rate is in satoshis per kB, input size in bytes
        var feeBasedMinSize = Math.ceil(unspents_1.VirtualSizes.txP2shInputSize * params.feeRate / 1000);
        if (params.minSize && minSize < feeBasedMinSize) {
            throw new Error('provided minSize too low due to too high fee rate');
        }
        minSize = Math.max(feeBasedMinSize, minSize);
        if (!params.minSize) {
            // fee rate-based min size needs no logging if it was set explicitly
            console.log('Only consolidating unspents larger than ' + minSize + ' satoshis to avoid wasting money on fees. To consolidate smaller unspents, use a lower fee rate.');
        }
    }
    var iterationCount = 0;
    var self = this;
    var consolidationIndex = 0;
    /**
     * Consolidate one batch of up to MAX_INPUT_COUNT unspents.
     * @returns {*}
     */
    var runNextConsolidation = co(function () {
        var consolidationTransactions, isFinalConsolidation, queryParams, allUnspents, allUnspentsCount, targetInputCount, inputCount, currentChunk, changeChain, newAddress, txParams, currentAddress, grossAmount, error_2, debugParams, baseFee, bitgoFee, totalFee, netAmount, sentTx, e_3, debugParams, _a, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    consolidationTransactions = [];
                    isFinalConsolidation = false;
                    iterationCount++;
                    queryParams = {
                        limit: target + maxInputCount,
                        minConfirms: minConfirms,
                        minSize: minSize
                    };
                    if (params.maxSize) {
                        queryParams.maxSize = params.maxSize;
                    }
                    return [4 /*yield*/, self.unspents(queryParams)];
                case 1:
                    allUnspents = _d.sent();
                    // this consolidation is essentially just a waste of money
                    if (allUnspents.length <= target) {
                        if (iterationCount <= 1) {
                            // this is the first iteration, so the method is incorrect
                            throw new Error('Fewer unspents than consolidation target. Use fanOutUnspents instead.');
                        }
                        else {
                            // it's a later iteration, so the target may have been surpassed (due to confirmations in the background)
                            throw new Error('Done');
                        }
                    }
                    allUnspentsCount = allUnspents.length;
                    targetInputCount = allUnspentsCount - target + 1;
                    targetInputCount = Math.min(targetInputCount, allUnspents.length);
                    inputCount = Math.min(targetInputCount, maxInputCount);
                    // if either the number of inputs left to coalesce equals the number we will coalesce in this iteration
                    // or if the number of iterations matches the maximum permitted number
                    isFinalConsolidation = (inputCount === targetInputCount || iterationCount === maxIterationCount);
                    currentChunk = allUnspents.splice(0, inputCount);
                    changeChain = self.getChangeChain(params);
                    return [4 /*yield*/, self.createAddress({ chain: changeChain, validate: validate })];
                case 2:
                    newAddress = _d.sent();
                    txParams = _.extend({}, params);
                    currentAddress = newAddress;
                    grossAmount = _(currentChunk).map('value').sum();
                    txParams.unspents = currentChunk;
                    txParams.recipients = {};
                    txParams.recipients[newAddress.address] = grossAmount;
                    txParams.noSplitChange = true;
                    if (txParams.unspents.length <= 1) {
                        throw new Error('Done');
                    }
                    _d.label = 3;
                case 3:
                    _d.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, self.sendMany(txParams)];
                case 4:
                    _d.sent();
                    return [3 /*break*/, 6];
                case 5:
                    error_2 = _d.sent();
                    // this error should occur due to insufficient funds
                    // however, let's make sure it wasn't something else
                    if (!error_2.fee && (!error_2.result || !error_2.result.fee)) {
                        debugParams = _.omit(txParams, ['walletPassphrase', 'xprv']);
                        error_2.message += "\n\nTX PARAMS:\n " + JSON.stringify(debugParams, null, 4);
                        throw error_2;
                    }
                    baseFee = error_2.fee || error_2.result.fee;
                    bitgoFee = 0;
                    totalFee = baseFee;
                    if (error_2.result.bitgoFee && error_2.result.bitgoFee.amount) {
                        bitgoFee = error_2.result.bitgoFee.amount;
                        totalFee += bitgoFee;
                        txParams.bitgoFee = error_2.result.bitgoFee;
                    }
                    netAmount = Math.max(error_2.result.available - totalFee, self.bitgo.getConstants().minOutputSize);
                    // Need to clear these out since only 1 may be set
                    delete txParams.fee;
                    txParams.originalFeeRate = txParams.feeRate;
                    delete txParams.feeRate;
                    delete txParams.feeTxConfirmTarget;
                    // we set the fee explicitly
                    txParams.fee = error_2.result.available - netAmount - bitgoFee;
                    txParams.recipients[newAddress.address] = netAmount;
                    return [3 /*break*/, 6];
                case 6:
                    _d.trys.push([6, 8, , 9]);
                    return [4 /*yield*/, self.sendMany(txParams)];
                case 7:
                    sentTx = _d.sent();
                    return [3 /*break*/, 9];
                case 8:
                    e_3 = _d.sent();
                    debugParams = _.omit(txParams, ['walletPassphrase', 'xprv']);
                    e_3.message += "\n\nTX PARAMS:\n " + JSON.stringify(debugParams, null, 4);
                    throw e_3;
                case 9:
                    consolidationTransactions.push(sentTx);
                    if (_.isFunction(params.progressCallback)) {
                        params.progressCallback({
                            txid: sentTx.hash,
                            destination: currentAddress,
                            amount: grossAmount,
                            fee: sentTx.fee,
                            inputCount: inputCount,
                            index: consolidationIndex
                        });
                    }
                    consolidationIndex++;
                    if (!!isFinalConsolidation) return [3 /*break*/, 12];
                    // this last consolidation has not yet brought the unspents count down to the target unspent count
                    // therefore, we proceed by consolidating yet another batch
                    // before we do that, we wait 1 second so that the newly created unspent will be fetched in the next batch
                    return [4 /*yield*/, Promise.delay(1000)];
                case 10:
                    // this last consolidation has not yet brought the unspents count down to the target unspent count
                    // therefore, we proceed by consolidating yet another batch
                    // before we do that, we wait 1 second so that the newly created unspent will be fetched in the next batch
                    _d.sent();
                    _b = (_a = consolidationTransactions.push).apply;
                    _c = [consolidationTransactions];
                    return [4 /*yield*/, runNextConsolidation()];
                case 11:
                    _b.apply(_a, _c.concat([_d.sent()]));
                    _d.label = 12;
                case 12: 
                // this is the final consolidation transaction. We return all the ones we've had so far
                return [2 /*return*/, consolidationTransactions];
            }
        });
    });
    return runNextConsolidation(this, target)
        .catch(function (err) {
        if (err.message === 'Done') {
            return;
        }
        throw err;
    })
        .nodeify(callback);
};
Wallet.prototype.shareWallet = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['email', 'permissions'], ['walletPassphrase', 'message'], callback);
    if (params.reshare !== undefined && !_.isBoolean(params.reshare)) {
        throw new Error('Expected reshare to be a boolean.');
    }
    if (params.skipKeychain !== undefined && !_.isBoolean(params.skipKeychain)) {
        throw new Error('Expected skipKeychain to be a boolean. ');
    }
    var needsKeychain = !params.skipKeychain && params.permissions.indexOf('spend') !== -1;
    if (params.disableEmail !== undefined && !_.isBoolean(params.disableEmail)) {
        throw new Error('Expected disableEmail to be a boolean.');
    }
    var self = this;
    var sharing;
    var sharedKeychain;
    return this.bitgo.getSharingKey({ email: params.email.toLowerCase() })
        .then(function (result) {
        sharing = result;
        if (needsKeychain) {
            return self.getEncryptedUserKeychain({})
                .then(function (keychain) {
                // Decrypt the user key with a passphrase
                if (keychain.encryptedXprv) {
                    if (!params.walletPassphrase) {
                        throw new Error('Missing walletPassphrase argument');
                    }
                    try {
                        keychain.xprv = self.bitgo.decrypt({ password: params.walletPassphrase, input: keychain.encryptedXprv });
                    }
                    catch (e) {
                        throw new Error('Unable to decrypt user keychain');
                    }
                    var eckey = bitcoin.makeRandomKey();
                    var secret = self.bitgo.getECDHSecret({ eckey: eckey, otherPubKeyHex: sharing.pubkey });
                    var newEncryptedXprv = self.bitgo.encrypt({ password: secret, input: keychain.xprv });
                    sharedKeychain = {
                        xpub: keychain.xpub,
                        encryptedXprv: newEncryptedXprv,
                        fromPubKey: eckey.getPublicKeyBuffer().toString('hex'),
                        toPubKey: sharing.pubkey,
                        path: sharing.path
                    };
                }
            });
        }
    })
        .then(function () {
        var options = {
            user: sharing.userId,
            permissions: params.permissions,
            reshare: params.reshare,
            message: params.message,
            disableEmail: params.disableEmail
        };
        if (sharedKeychain) {
            options.keychain = sharedKeychain;
        }
        else if (params.skipKeychain) {
            options.keychain = {};
        }
        return self.createShare(options);
    })
        .nodeify(callback);
};
Wallet.prototype.removeUser = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['user'], [], callback);
    return this.bitgo.del(this.url('/user/' + params.user))
        .send()
        .result()
        .nodeify(callback);
};
Wallet.prototype.getPolicy = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.url('/policy'))
        .send()
        .result()
        .nodeify(callback);
};
Wallet.prototype.getPolicyStatus = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.url('/policy/status'))
        .send()
        .result()
        .nodeify(callback);
};
Wallet.prototype.setPolicyRule = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id', 'type'], ['message'], callback);
    if (!_.isObject(params.condition)) {
        throw new Error('missing parameter: conditions object');
    }
    if (!_.isObject(params.action)) {
        throw new Error('missing parameter: action object');
    }
    return this.bitgo.put(this.url('/policy/rule'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.removePolicyRule = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], ['message'], callback);
    return this.bitgo.del(this.url('/policy/rule'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.listWebhooks = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.url('/webhooks'))
        .send()
        .result()
        .nodeify(callback);
};
/**
 * Simulate wallet webhook, currently for webhooks of type transaction and pending approval
 * @param params
 * - webhookId (required): id of the webhook to be simulated
 * - txHash (optional but required for transaction webhooks) hash of the simulated transaction
 * - pendingApprovalId (optional but required for pending approval webhooks) id of the simulated pending approval
 * @param callback
 * @returns {*}
 */
Wallet.prototype.simulateWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['webhookId'], ['txHash', 'pendingApprovalId'], callback);
    var hasTxHash = !!params.txHash;
    var hasPendingApprovalId = !!params.pendingApprovalId;
    if ((hasTxHash && hasPendingApprovalId) || (!hasTxHash && !hasPendingApprovalId)) {
        throw new Error('must supply either txHash or pendingApprovalId, but not both');
    }
    // depending on the coin type of the wallet, the txHash has to adhere to its respective format
    // but the server takes care of that
    // only take the txHash and pendingApprovalId properties
    var filteredParams = _.pick(params, ['txHash', 'pendingApprovalId']);
    var webhookId = params.webhookId;
    return this.bitgo.post(this.url('/webhooks/' + webhookId + '/simulate'))
        .send(filteredParams)
        .result()
        .nodeify(callback);
};
Wallet.prototype.addWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['url', 'type'], [], callback);
    return this.bitgo.post(this.url('/webhooks'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.removeWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['url', 'type'], [], callback);
    return this.bitgo.del(this.url('/webhooks'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.estimateFee = function (params, callback) {
    common.validateParams(params, [], [], callback);
    if (params.amount && params.recipients) {
        throw new Error('cannot specify both amount as well as recipients');
    }
    if (params.recipients && !_.isObject(params.recipients)) {
        throw new Error('recipients must be array of { address: abc, amount: 100000 } objects');
    }
    if (params.amount && !_.isNumber(params.amount)) {
        throw new Error('invalid amount argument, expecting number');
    }
    var recipients = params.recipients || [];
    if (params.amount) {
        // only the amount was passed in, so we need to make a false recipient to run createTransaction with
        recipients.push({
            address: common.Environments[this.bitgo.env].signingAddress,
            amount: params.amount
        });
    }
    var transactionParams = _.extend({}, params);
    transactionParams.amount = undefined;
    transactionParams.recipients = recipients;
    return this.createTransaction(transactionParams)
        .then(function (tx) {
        return {
            estimatedSize: tx.estimatedSize,
            fee: tx.fee,
            feeRate: tx.feeRate
        };
    });
};
// Not fully implemented / released on SDK. Testing for now.
Wallet.prototype.updatePolicyRule = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id', 'type'], [], callback);
    return this.bitgo.put(this.url('/policy/rule'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.deletePolicyRule = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    return this.bitgo.del(this.url('/policy/rule'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// getBitGoFee
// Get the required on-transaction BitGo fee
//
Wallet.prototype.getBitGoFee = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (!_.isNumber(params.amount)) {
        throw new Error('invalid amount argument');
    }
    if (params.instant && !_.isBoolean(params.instant)) {
        throw new Error('invalid instant argument');
    }
    return this.bitgo.get(this.url('/billing/fee'))
        .query(params)
        .result()
        .nodeify(callback);
};
module.exports = Wallet;
//# sourceMappingURL=wallet.js.map