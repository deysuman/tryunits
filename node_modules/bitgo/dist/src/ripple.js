"use strict";
var rippleKeypairs = require('ripple-keypairs');
var ripple = require('ripple-lib');
var prova = require('./prova');
var keypairs = require('ripple-keypairs');
var binary = require('ripple-binary-codec');
var computeBinaryTransactionHash = require('ripple-hashes').computeBinaryTransactionHash;
function computeSignature(tx, privateKey, signAs) {
    var signingData = signAs ?
        binary.encodeForMultisigning(tx, signAs) : binary.encodeForSigning(tx);
    return keypairs.sign(signingData, privateKey);
}
/**
 * Sign Ripple transaction with a secp256k1 private key
 * @param txHex
 * @param privateKey
 * @param options
 * @returns {{signedTransaction: *, id}}
 */
var signWithPrivateKey = function (txHex, privateKey, options) {
    var privateKeyBuffer = new Buffer(privateKey, 'hex');
    if (privateKeyBuffer.length === 33 && privateKeyBuffer[0] === 0) {
        privateKeyBuffer = privateKeyBuffer.slice(1, 33);
    }
    var privateKeyObject = prova.ECPair.fromPrivateKeyBuffer(privateKeyBuffer);
    var publicKey = privateKeyObject.getPublicKeyBuffer().toString('hex').toUpperCase();
    var tx;
    try {
        tx = binary.decode(txHex);
    }
    catch (e) {
        try {
            tx = JSON.parse(txHex);
        }
        catch (e) {
            throw new Error('txHex needs to be either hex or JSON string for XRP');
        }
    }
    if (tx.TxnSignature || tx.Signers) {
        throw new Error('transaction must not contain "TxnSignature" or "Signers" properties');
    }
    tx.SigningPubKey = (options && options.signAs) ? '' : publicKey;
    if (options && options.signAs) {
        var expectedSigner = rippleKeypairs.deriveAddress(publicKey);
        if (options.signAs !== expectedSigner) {
            throw new Error('signAs does not match private key');
        }
        var signer = {
            Account: options.signAs,
            SigningPubKey: publicKey,
            TxnSignature: computeSignature(tx, privateKey, options.signAs)
        };
        tx.Signers = [{ Signer: signer }];
    }
    else {
        tx.TxnSignature = computeSignature(tx, privateKey, undefined);
    }
    var serialized = binary.encode(tx);
    return {
        signedTransaction: serialized,
        id: computeBinaryTransactionHash(serialized)
    };
};
module.exports = function (params) {
    var rippleLib = new ripple.RippleAPI(params);
    rippleLib.signWithPrivateKey = signWithPrivateKey;
    return rippleLib;
};
//# sourceMappingURL=ripple.js.map