"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var express = require("express");
var httpProxy = require("http-proxy");
var url = require("url");
var morgan = require('morgan');
var Promise = require('bluebird');
var fs = Promise.promisifyAll(require('fs'));
var path = require('path');
var _ = require('lodash');
var debugLib = require('debug');
var debug = debugLib('bitgo:express');
var https = require('https');
var http = require('http');
var co = Promise.coroutine;
var ArgumentParser = require('argparse').ArgumentParser;
var SSL_OP_NO_TLSv1 = require('constants').SSL_OP_NO_TLSv1;
var common = require('./common');
var pjson = require('../package.json');
var _a = require('./errors'), TlsConfigurationError = _a.TlsConfigurationError, NodeEnvironmentError = _a.NodeEnvironmentError;
var BITGOEXPRESS_USER_AGENT = 'BitGoExpress/' + pjson.version;
var DEFAULT_TIMEOUT = 305 * 1000;
/**
 * Do some additional argument validation which can't easily be done in argparse
 *
 * @param args
 * @return {*}
 */
function validateArgs(args) {
    var env = args.env, bind = args.bind, disablessl = args.disablessl, crtpath = args.crtpath, keypath = args.keypath, disableenvcheck = args.disableenvcheck;
    var needsTLS = env === 'prod' && bind !== 'localhost' && !disablessl;
    if (needsTLS && !(keypath && crtpath)) {
        throw new TlsConfigurationError('Must enable TLS when running against prod and listening on external interfaces!');
    }
    if (Boolean(keypath) !== Boolean(crtpath)) {
        throw new TlsConfigurationError('Must provide both keypath and crtpath when running in TLS mode!');
    }
    if (env === 'prod' && process.env.NODE_ENV !== 'production') {
        if (!disableenvcheck) {
            throw new NodeEnvironmentError('NODE_ENV should be set to production when running against prod environment. Use --disableenvcheck if you really want to run in a non-production node configuration.');
        }
        else {
            console.warn("warning: unsafe NODE_ENV '" + process.env.NODE_ENV + "'. NODE_ENV must be set to 'production' when running against BitGo production environment.");
        }
    }
    return args;
}
/**
 * Set up the logging middleware provided by morgan
 *
 * @param logfile
 * @param app
 */
function setupLogging(_a, app) {
    var logfile = _a.logfile;
    // Set up morgan for logging, with optional logging into a file
    var middleware;
    if (logfile) {
        // create a write stream (in append mode)
        var accessLogPath = path.resolve(logfile);
        var accessLogStream = fs.createWriteStream(accessLogPath, { flags: 'a' });
        console.log('Log location: ' + accessLogPath);
        // setup the logger
        middleware = morgan('combined', { stream: accessLogStream });
    }
    else {
        middleware = morgan('combined');
    }
    app.use(middleware);
    morgan.token('remote-user', function (req) { return req.isProxy ? 'proxy' : 'local_express'; });
}
/**
 * If we're running in a custom env, set the appropriate environment URI and network properties
 *
 * @param args
 */
function configureEnvironment(args) {
    var customrooturi = args.customrooturi, custombitcoinnetwork = args.custombitcoinnetwork;
    if (customrooturi || custombitcoinnetwork) {
        args.env = 'custom';
    }
    if (customrooturi) {
        common.Environments['custom'].uri = customrooturi;
    }
    if (custombitcoinnetwork) {
        common.Environments['custom'].network = custombitcoinnetwork;
    }
}
/**
 * Create and configure the proxy middleware and add it to the app middleware stack
 *
 * @param app bitgo-express Express app
 * @param env BitGo environment name
 * @param timeout Request timeout delay in milliseconds
 */
function configureProxy(app, _a) {
    var env = _a.env, _b = _a.timeout, timeout = _b === void 0 ? DEFAULT_TIMEOUT : _b;
    // Mount the proxy middleware
    var options = {
        timeout: timeout,
        proxyTimeout: timeout,
        secure: null
    };
    if (common.Environments[env].network === 'testnet') {
        // Need to do this to make supertest agent pass (set rejectUnauthorized to false)
        options.secure = false;
    }
    var proxy = httpProxy.createProxyServer(options);
    proxy.on('proxyReq', function (proxyReq, req) {
        // Need to rewrite the host, otherwise cross-site protection kicks in
        proxyReq.setHeader('host', url.parse(common.Environments[env].uri).hostname);
        var userAgent = req.headers['user-agent'] ? BITGOEXPRESS_USER_AGENT + ' ' + req.headers['user-agent'] : BITGOEXPRESS_USER_AGENT;
        proxyReq.setHeader('User-Agent', userAgent);
    });
    proxy.on('error', function (err, _, res) {
        debug('Proxy server error: ', err);
        res.status(500).send({
            error: 'BitGo Express encountered an error while attempting to proxy your request to BitGo. Please try again.'
        });
    });
    proxy.on('econnreset', function (err, _, res) {
        debug('Proxy server connection reset error: ', err);
        res.status(500).send({
            error: 'BitGo Express encountered a connection reset error while attempting to proxy your request to BitGo. Please try again.'
        });
    });
    app.use(function (req, res) {
        if (req.url && (/^\/api\/v[12]\/.*$/.test(req.url) || /^\/oauth\/token.*$/.test(req.url))) {
            req.isProxy = true;
            proxy.web(req, res, { target: common.Environments[env].uri, changeOrigin: true });
            return;
        }
        // user tried to access a url which is not an api route, do not proxy
        res.status(404).send('bitgo-express can only proxy BitGo API requests');
    });
}
/**
 * Create an HTTP server configured for accepting HTTPS connections
 *
 * @param keypath
 * @param crtpath
 * @param app
 * @return {Server}
 */
function createHttpsServer(_a, app) {
    var keypath = _a.keypath, crtpath = _a.crtpath;
    return co(function createHttpsServer() {
        var privateKeyPromise, certificatePromise, _a, key, cert;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    privateKeyPromise = fs.readFileAsync(keypath, 'utf8');
                    certificatePromise = fs.readFileAsync(crtpath, 'utf8');
                    return [4 /*yield*/, Promise.all([privateKeyPromise, certificatePromise])];
                case 1:
                    _a = _b.sent(), key = _a[0], cert = _a[1];
                    return [2 /*return*/, https.createServer({ secureOptions: SSL_OP_NO_TLSv1, key: key, cert: cert }, app)];
            }
        });
    }).call(this);
}
/**
 * Create an HTTP server configured for accepting plain old HTTP connections
 *
 * @param app
 * @return {Server}
 */
function createHttpServer(app) {
    return http.createServer(app);
}
/**
 * Configure argparse with all possible command line arguments
 * @return {*}
 */
module.exports.parseArgs = function () {
    var parser = new ArgumentParser({
        version: pjson.version,
        addHelp: true,
        description: 'BitGo-Express'
    });
    parser.addArgument(['-p', '--port'], {
        defaultValue: 3080,
        type: 'int',
        help: 'Port to listen on'
    });
    parser.addArgument(['-b', '--bind'], {
        defaultValue: 'localhost',
        help: 'Bind to given address to listen for connections (default: localhost)'
    });
    parser.addArgument(['-e', '--env'], {
        defaultValue: 'test',
        help: 'BitGo environment to proxy against (prod, test)'
    });
    parser.addArgument(['-d', '--debug'], {
        action: 'appendConst',
        dest: 'debugnamespace',
        constant: 'bitgo:express',
        help: 'Enable basic debug logging for incoming requests'
    });
    parser.addArgument(['-D', '--debugnamespace'], {
        action: 'append',
        help: 'Enable a specific debugging namespace for more fine-grained debug output. May be given more than once.'
    });
    parser.addArgument(['-k', '--keypath'], {
        help: 'Path to the SSL Key file (required if running production)'
    });
    parser.addArgument(['-c', '--crtpath'], {
        help: 'Path to the SSL Crt file (required if running production)'
    });
    parser.addArgument(['-u', '--customrooturi'], {
        defaultValue: process.env.BITGO_CUSTOM_ROOT_URI,
        help: 'Force custom root BitGo URI (e.g. https://test.bitgo.com)'
    });
    parser.addArgument(['-n', '--custombitcoinnetwork'], {
        defaultValue: process.env.BITGO_CUSTOM_BITCOIN_NETWORK,
        help: 'Force custom bitcoin network (e.g. testnet)'
    });
    parser.addArgument(['-l', '--logfile'], {
        help: 'Filepath to write the access log'
    });
    parser.addArgument(['--disablessl'], {
        action: 'storeTrue',
        help: 'Allow running against production in non-SSL mode (at your own risk!)'
    });
    parser.addArgument(['--disableproxy'], {
        action: 'storeTrue',
        help: 'disable the proxy, not routing any non-express routes'
    });
    parser.addArgument(['--disableenvcheck'], {
        action: 'storeTrue',
        defaultValue: true,
        help: 'disable checking for proper NODE_ENV when running in prod environment'
    });
    parser.addArgument(['-t', '--timeout'], {
        defaultValue: process.env.BITGO_TIMEOUT * 1000 || DEFAULT_TIMEOUT,
        help: 'Proxy server timeout in milliseconds'
    });
    return parser.parseArgs();
};
/**
 * Create a startup function which will be run upon server initialization
 *
 * @param env
 * @param customrooturi
 * @param custombitcoinnetwork
 * @param baseUri
 * @return {Function}
 */
module.exports.startup = function (_a, baseUri) {
    var _b = _a === void 0 ? {} : _a, env = _b.env, customrooturi = _b.customrooturi, custombitcoinnetwork = _b.custombitcoinnetwork;
    return function () {
        console.log('BitGo-Express running');
        console.log("Environment: " + env);
        console.log("Base URI: " + baseUri);
        if (customrooturi) {
            console.log("Custom root URI: " + customrooturi);
        }
        if (custombitcoinnetwork) {
            console.log("Custom bitcoin network: " + custombitcoinnetwork);
        }
    };
};
/**
 * Create either a HTTP or HTTPS server
 * @param args
 * @param tls
 * @param app
 * @return {Server}
 */
module.exports.createServer = co(function (args, tls, app) {
    var _a;
    if (args === void 0) { args = {}; }
    if (tls === void 0) { tls = false; }
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (!tls) return [3 /*break*/, 2];
                return [4 /*yield*/, createHttpsServer(args, app)];
            case 1:
                _a = _b.sent();
                return [3 /*break*/, 3];
            case 2:
                _a = createHttpServer(app);
                _b.label = 3;
            case 3: return [2 /*return*/, _a];
        }
    });
});
/**
 * Create the base URI where the BitGoExpress server will be available once started
 * @param bind
 * @param port
 * @param tls
 * @return {string}
 */
module.exports.createBaseUri = function (_a, tls) {
    var bind = _a.bind, port = _a.port;
    var isStandardPort = (port === 80 && !tls) || (port === 443 && tls);
    return "http" + (tls ? 's' : '') + "://" + bind + (!isStandardPort ? ':' + port : '');
};
module.exports.app = function (args) {
    debug('app is initializing');
    validateArgs(args);
    // Create express app
    var app = express();
    setupLogging(args, app);
    // Be more robust about accepting URLs with double slashes
    app.use(function (req, res, next) {
        req.url = req.url.replace(/\/\//g, '/');
        next();
    });
    // enable specified debug namespaces
    if (_.isArray(args.debugnamespace)) {
        _.forEach(args.debugnamespace, function (ns) { return debugLib.enable(ns); });
    }
    // Decorate the client routes
    require('./clientRoutes')(app, args);
    configureEnvironment(args);
    if (!args.disableproxy) {
        configureProxy(app, args);
    }
    return app;
};
//# sourceMappingURL=expressApp.js.map