"use strict";
//
// BitGo JavaScript SDK
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var superagent = require('superagent');
var bitcoin = require("./bitcoin");
var bitcoinMessage = require("bitcoinjs-message");
var sanitizeHtml = require("sanitize-html");
var eol = require("eol");
var BaseCoin = require('./v2/baseCoin');
var Blockchain = require('./blockchain');
var Keychains = require('./keychains');
var TravelRule = require('./travelRule');
var Wallet = require("./wallet");
var Wallets = require('./wallets');
var Markets = require('./markets');
var PendingApprovals = require('./pendingapprovals');
var shamir = require("secrets.js-grempe");
var sjcl = require("./vendor/sjcl.min.js");
var bs58 = require("bs58");
var common = require("./common");
var Util = require("./util");
var Promise = require("bluebird");
var co = Promise.coroutine;
var pjson = require("../package.json");
var moment = require("moment");
var _ = require("lodash");
var url = require("url");
var querystring = require("querystring");
var config = require("./config");
var crypto = require("crypto");
var debugLib = require("debug");
var internal = require('./v2/internal');
var debug = debugLib('bitgo:index');
var bytesToWord = internal.bytesToWord;
if (!process.browser) {
    require('superagent-proxy')(superagent);
}
// Patch superagent to return promises
var _end = superagent.Request.prototype.end;
superagent.Request.prototype.end = function (cb) {
    var self = this;
    if (typeof cb === 'function') {
        return _end.call(self, cb);
    }
    return new Promise.Promise(function (resolve, reject) {
        var error;
        try {
            return _end.call(self, function (error, response) {
                if (error) {
                    return reject(error);
                }
                return resolve(response);
            });
        }
        catch (_error) {
            error = _error;
            return reject(error);
        }
    });
};
// Handle HTTP errors appropriately, returning the result body, or a named
// field from the body, if the optionalField parameter is provided.
superagent.Request.prototype.result = function (optionalField) {
    return this.then(handleResponseResult(optionalField), handleResponseError);
};
var handleResponseResult = function (optionalField) {
    if (optionalField === void 0) { optionalField = false; }
    return function (res) {
        if (_.isNumber(res.status) && res.status >= 200 && res.status < 300) {
            return optionalField ? res.body[optionalField] : res.body;
        }
        throw errFromResponse(res);
    };
};
var errFromResponse = function (res) {
    var errString = createResponseErrorString(res);
    var err = new Error(errString);
    err.status = res.status;
    if (res.body) {
        err.result = res.body;
    }
    if (_.has(res.headers, 'x-auth-required') && (res.headers['x-auth-required'] === 'true')) {
        err.invalidToken = true;
    }
    if (res.body.needsOTP) {
        err.needsOTP = true;
    }
    return err;
};
var handleResponseError = function (e) {
    if (e.response) {
        throw errFromResponse(e.response);
    }
    throw e;
};
/**
 * There are many ways a request can fail, and may ways information on that failure can be
 * communicated to the client. This function tries to handle those cases and create a sane error string
 * @param res Response from an HTTP request
 * @returns {String}
 */
var createResponseErrorString = function (res) {
    var errString = res.statusCode.toString(); // at the very least we'll have the status code
    if (res.body.error) {
        // this is the case we hope for, where the server gives us a nice error from the JSON body
        errString = res.body.error;
    }
    else {
        // things get messy from here on, we try different parts of the response, salvaging what we can
        if (res.res && res.res.statusMessage) {
            errString = errString + '\n' + res.res.statusMessage;
        }
        if (res.text) {
            // if the response came back as text, we try to parse it as HTML and remove all tags, leaving us
            // just the bare text, which we then trim of excessive newlines and limit to a certain length
            try {
                var sanitizedText = sanitizeHtml(res.text, { allowedTags: [] });
                sanitizedText = sanitizedText.trim();
                sanitizedText = eol.lf(sanitizedText); // use '\n' for all newlines
                sanitizedText = _.replace(sanitizedText, /\n[ |\t]{1,}\n/g, '\n\n'); // remove the spaces/tabs between newlines
                sanitizedText = _.replace(sanitizedText, /[\n]{3,}/g, '\n\n'); // have at most 2 consecutive newlines
                sanitizedText = sanitizedText.substring(0, 5000); // prevent message from getting too large
                errString = errString + '\n' + sanitizedText; // add it to our existing errString (at this point the more info the better!)
            }
            catch (e) {
                // do nothing, the response's HTML was too wacky to be parsed cleanly
            }
        }
    }
    return errString;
};
//
// Constructor for BitGo Object
// arguments:
//   @useProduction: flag to use the production bitcoin network rather than the
//                   testnet network.
//
var testNetWarningMessage = false;
var BitGo = function (params) {
    params = params || {};
    if (!common.validateParams(params, [], ['clientId', 'clientSecret', 'refreshToken', 'accessToken', 'userAgent', 'customRootURI', 'customBitcoinNetwork', 'serverXpub']) ||
        (params.useProduction && !_.isBoolean(params.useProduction))) {
        throw new Error('invalid argument');
    }
    if ((!params.clientId) !== (!params.clientSecret)) {
        throw new Error('invalid argument - must provide both client id and secret');
    }
    // By default, we operate on the test server.
    // Deprecate useProduction in the future
    var env;
    if (params.useProduction) {
        if (params.env && params.env !== 'prod') {
            throw new Error('cannot use useProduction when env=' + params.env);
        }
        env = 'prod';
    }
    else if (params.customRootURI ||
        params.customBitcoinNetwork ||
        params.customSigningAddress ||
        params.serverXpub ||
        process.env.BITGO_CUSTOM_ROOT_URI ||
        process.env.BITGO_CUSTOM_BITCOIN_NETWORK) {
        env = 'custom';
        if (params.customRootURI) {
            common.Environments['custom'].uri = params.customRootURI;
        }
        if (params.customBitcoinNetwork) {
            common.Environments['custom'].network = params.customBitcoinNetwork;
        }
        if (params.customSigningAddress) {
            common.Environments['custom'].customSigningAddress = params.customSigningAddress;
        }
        if (params.serverXpub) {
            common.Environments['custom'].serverXpub = params.serverXpub;
        }
    }
    else {
        env = params.env || process.env.BITGO_ENV;
    }
    if (env === 'production') {
        env = 'prod'; // make life easier
    }
    if (env === 'custom' && _.isUndefined(common.Environments[env].uri)) {
        throw new Error('must use --customrooturi or set the BITGO_CUSTOM_ROOT_URI environment variable when using the custom environment');
    }
    if (env) {
        if (common.Environments[env]) {
            this._baseUrl = common.Environments[env].uri;
        }
        else {
            throw new Error('invalid environment ' + env + '. Supported environments: test, prod');
        }
    }
    else {
        env = 'test';
        if (!testNetWarningMessage) {
            testNetWarningMessage = true;
            console.log('BitGo SDK env not set - defaulting to test at test.bitgo.com.');
        }
    }
    this.env = env;
    common.setNetwork(common.Environments[env].network);
    common.setRmgNetwork(common.Environments[env].rmgNetwork);
    if (!this._baseUrl) {
        this._baseUrl = common.Environments[env].uri;
    }
    this._microservicesUrl = params.microservicesUri;
    this._baseApiUrl = this._baseUrl + '/api/v1';
    this._baseApiUrlV2 = this._baseUrl + '/api/v2';
    this._user = null;
    this._keychains = null;
    this._wallets = null;
    this._clientId = params.clientId;
    this._clientSecret = params.clientSecret;
    this._token = params.accessToken || null;
    this._refreshToken = params.refreshToken || null;
    this._userAgent = params.userAgent || 'BitGoJS/' + this.version();
    this._promise = Promise;
    // whether to perform extra client-side validation for some things, such as
    // address validation or signature validation. defaults to true, but can be
    // turned off by setting to false. can also be overridden individually in the
    // functions that use it.
    this._validate = params.validate === undefined ? true : params.validate;
    // Create superagent methods specific to this BitGo instance.
    this.request = {};
    var methods = ['get', 'post', 'put', 'del', 'patch'];
    if (!params.proxy && process.env.BITGO_USE_PROXY) {
        params.proxy = process.env.BITGO_USE_PROXY;
    }
    if (process.browser && params.proxy) {
        throw new Error('cannot use https proxy params while in browser');
    }
    this.proxy = params.proxy;
    var self = this;
    // This is a patching function which can apply our authorization
    // headers to any outbound request.
    var createPatch = function (method) {
        return function () {
            var req = superagent[method].apply(null, arguments);
            if (self.proxy) {
                req = req.proxy(self.proxy);
            }
            // Patch superagent to return promises
            req.prototypicalEnd = req.end;
            req.end = function () {
                // intercept a request before it's submitted to the server for v2 authentication (based on token)
                var bitgo = self;
                this.set('BitGo-SDK-Version', bitgo.version());
                if (!_.isUndefined(bitgo._reqId)) {
                    this.set('Request-ID', bitgo._reqId.toString());
                    // increment after setting the header so the sequence numbers start at 0
                    bitgo._reqId.inc();
                    // request ids must be set before each request instead of being kept
                    // inside the bitgo object. This is to prevent reentrancy issues where
                    // multiple simultaneous requests could cause incorrect reqIds to be used
                    delete bitgo._reqId;
                }
                // if there is no token, and we're not logged in, the request cannot be v2 authenticated
                this.isV2Authenticated = true;
                this.authenticationToken = bitgo._token;
                // some of the older tokens appear to be only 40 characters long
                if ((bitgo._token && bitgo._token.length !== 67 && bitgo._token.indexOf('v2x') !== 0)
                    || req.forceV1Auth) {
                    // use the old method
                    this.isV2Authenticated = false;
                    this.set('Authorization', 'Bearer ' + bitgo._token);
                    return this.prototypicalEnd.apply(this, arguments);
                }
                this.set('BitGo-Auth-Version', '2.0');
                // prevent IE from caching requests
                this.set('If-Modified-Since', 'Mon, 26 Jul 1997 05:00:00 GMT');
                if (bitgo._token) {
                    // do a localized data serialization process
                    var data = this._data;
                    if (typeof data !== 'string') {
                        var contentType = this.getHeader('Content-Type');
                        // Parse out just the content type from the header (ignore the charset)
                        if (contentType) {
                            contentType = contentType.split(';')[0];
                        }
                        var serialize = superagent.serialize[contentType];
                        if (!serialize && /[\/+]json\b/.test(contentType)) {
                            serialize = superagent.serialize['application/json'];
                        }
                        if (serialize) {
                            data = serialize(data);
                        }
                    }
                    this._data = data;
                    var urlDetails = url.parse(req.url);
                    var queryString = null;
                    if (req._query && req._query.length > 0) {
                        // browser version
                        queryString = req._query.join('&');
                        req._query = [];
                    }
                    else if (req.qs) {
                        // node version
                        queryString = querystring.stringify(req.qs);
                        req.qs = null;
                    }
                    if (queryString) {
                        if (urlDetails.search) {
                            urlDetails.search += '&' + queryString;
                        }
                        else {
                            urlDetails.search = '?' + queryString;
                        }
                        req.url = urlDetails.format();
                    }
                    var requestProperties = bitgo.calculateRequestHeaders({ url: req.url, token: bitgo._token, text: data });
                    this.set('Auth-Timestamp', requestProperties.timestamp);
                    // we're not sending the actual token, but only its hash
                    this.set('Authorization', 'Bearer ' + requestProperties.tokenHash);
                    // set the HMAC
                    this.set('HMAC', requestProperties.hmac);
                }
                return this.prototypicalEnd.apply(this, arguments);
            };
            // verify that the response received from the server is signed correctly
            // right now, it is very permissive with the timestamp variance
            req.verifyResponse = function (response) {
                var bitgo = self;
                if (!req.isV2Authenticated || !req.authenticationToken) {
                    return response;
                }
                var verificationResponse = bitgo.verifyResponse({
                    url: req.url,
                    hmac: response.headers.hmac,
                    statusCode: response.statusCode,
                    text: response.text,
                    timestamp: response.headers.timestamp,
                    token: req.authenticationToken
                });
                if (!verificationResponse.isValid) {
                    // calculate the HMAC
                    var receivedHmac = response.headers.hmac;
                    var expectedHmac = verificationResponse.expectedHmac;
                    var signatureSubject = verificationResponse.signatureSubject;
                    // Log only the first 10 characters of the token to ensure the full token isn't logged.
                    var partialBitgoToken = bitgo._token.substring(0, 10);
                    var errorDetails = {
                        expectedHmac: expectedHmac,
                        receivedHmac: receivedHmac,
                        hmacInput: signatureSubject,
                        requestToken: req.authenticationToken,
                        bitgoToken: partialBitgoToken
                    };
                    debug('Invalid response HMAC: %O', errorDetails);
                    var error = new Error('invalid response HMAC, possible man-in-the-middle-attack');
                    error.result = errorDetails;
                    error.status = 511;
                    throw error;
                }
                return response;
            };
            var lastPromise = null;
            req.then = function () {
                if (!lastPromise) {
                    var reference = req.end()
                        .then(req.verifyResponse);
                    lastPromise = reference.then.apply(reference, arguments);
                }
                else {
                    lastPromise = lastPromise.then.apply(lastPromise, arguments);
                }
                return lastPromise;
            };
            if (!process.browser) {
                // If not in the browser, set the User-Agent. Browsers don't allow
                // setting of User-Agent, so we must disable this when run in the
                // browser (browserify sets process.browser).
                req.set('User-Agent', self._userAgent);
            }
            // Set the request timeout to just above 5 minutes by default
            req.timeout(process.env.BITGO_TIMEOUT * 1000 || 305 * 1000);
            return req;
        };
    };
    for (var index in methods) {
        var method = methods[index];
        self[method] = createPatch(method);
    }
    // capture outer stack so we have useful debug information if fetch constants fails
    var e = new Error();
    // Kick off first load of constants
    this.fetchConstants({}, function (err) {
        if (err) {
            // make sure an error does not terminate the entire script
            console.error('failed to fetch initial client constants from BitGo');
            debug(e.stack);
        }
    });
};
/**
 * Calculate the HMAC for the given key and message
 * @param key {String} - the key to use for the HMAC
 * @param message {String} - the actual message to HMAC
 * @returns {*} - the result of the HMAC operation
 */
BitGo.prototype.calculateHMAC = function (key, message) {
    return crypto.createHmac('sha256', key).update(message).digest('hex');
};
/**
 * Create a basecoin object
 * @param coinName
 */
BitGo.prototype.coin = function (coinName) {
    return BaseCoin.getInstance(this, coinName);
};
/**
 * Create a basecoin object for a virtual token
 * @param tokenName
 */
BitGo.prototype.token = function (tokenName, callback) {
    return co(function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, this.fetchConstants()];
                case 1:
                    _a.sent();
                    return [2 /*return*/, this.coin(tokenName)];
            }
        });
    }).call(this).asCallback(callback);
};
BitGo.prototype.getValidate = function () {
    return this._validate;
};
BitGo.prototype.setValidate = function (validate) {
    if (!_.isBoolean(validate)) {
        throw new Error('invalid argument');
    }
    this._validate = validate;
};
// Return the current BitGo environment
BitGo.prototype.getEnv = function () {
    return this.env;
};
BitGo.prototype.clear = function () {
    // TODO: are there any other fields which should be cleared?
    this._user = undefined;
    this._token = undefined;
    this._refreshToken = undefined;
    this._ecdhXprv = undefined;
};
// Helper function to return a rejected promise or call callback with error
BitGo.prototype.reject = function (msg, callback) {
    return Promise.reject(new Error(msg)).nodeify(callback);
};
//
// version
// Gets the version of the BitGoJS API
//
BitGo.prototype.version = function () {
    return pjson.version;
};
BitGo.prototype.toJSON = function () {
    return {
        user: this._user,
        token: this._token,
        extensionKey: this._extensionKey ? this._extensionKey.toWIF() : null
    };
};
BitGo.prototype.fromJSON = function (json) {
    this._user = json.user;
    this._token = json.token;
    if (json.extensionKey) {
        this._extensionKey = bitcoin.ECPair.fromWIF(json.extensionKey, bitcoin.getNetwork());
    }
};
BitGo.prototype.user = function () {
    return this._user;
};
BitGo.prototype.verifyAddress = function (params) {
    params = params || {};
    common.validateParams(params, ['address'], []);
    var address;
    try {
        address = bitcoin.address.fromBase58Check(params.address);
    }
    catch (e) {
        return false;
    }
    var network = bitcoin.getNetwork();
    return address.version === network.pubKeyHash || address.version === network.scriptHash;
};
BitGo.prototype.verifyPassword = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['password'], []);
    if (!this._user || !this._user.username) {
        throw new Error('no current user');
    }
    var hmacPassword = this.calculateHMAC(this._user.username, params.password);
    return this.post(this.url('/user/verifypassword'))
        .send({ password: hmacPassword })
        .result('valid')
        .nodeify(callback);
};
//
// encrypt
// Utility function to encrypt locally.
//
BitGo.prototype.encrypt = function (params) {
    params = params || {};
    common.validateParams(params, ['input', 'password'], []);
    var randomSalt = crypto.randomBytes(8);
    var randomIV = crypto.randomBytes(16);
    var encryptOptions = {
        iter: 10000,
        ks: 256,
        salt: [
            bytesToWord(randomSalt.slice(0, 4)),
            bytesToWord(randomSalt.slice(4))
        ],
        iv: [
            bytesToWord(randomIV.slice(0, 4)),
            bytesToWord(randomIV.slice(4, 8)),
            bytesToWord(randomIV.slice(8, 12)),
            bytesToWord(randomIV.slice(12, 16))
        ]
    };
    return sjcl.encrypt(params.password, params.input, encryptOptions);
};
/**
 *
 * @param params.password The password
 * @param params.input The input
 * @returns {*}
 */
BitGo.prototype.decrypt = function (params) {
    params = params || {};
    common.validateParams(params, ['input', 'password'], []);
    try {
        return sjcl.decrypt(params.password, params.input);
    }
    catch (error) {
        if (error.message.includes('ccm: tag doesn\'t match')) {
            error.message = 'password error - ' + error.message;
        }
        throw error;
    }
};
/**
 * Generate a random password on the client
 * @param   {Number} numWords     Number of 32-bit words
 * @returns {String}          base58 random password
 */
BitGo.prototype.generateRandomPassword = function (numWords) {
    if (numWords === void 0) { numWords = 5; }
    var bytes = sjcl.codec.bytes.fromBits(sjcl.random.randomWords(numWords));
    return bs58.encode(bytes);
};
/**
 *
 * @param seed A hexadecimal secret to split
 * @param passwords An array of the passwords used to encrypt each share
 * @param m The threshold number of shards necessary to reconstitute the secret
 * @returns {{xpub: *, xprv: *}}
 */
BitGo.prototype.splitSecret = function (_a) {
    var _this = this;
    var seed = _a.seed, passwords = _a.passwords, m = _a.m;
    if (!Array.isArray(passwords)) {
        throw new Error('passwords must be an array');
    }
    if (!_.isInteger(m) || m < 2) {
        throw new Error('m must be a positive integer greater than or equal to 2');
    }
    if (passwords.length < m) {
        throw new Error('passwords array length cannot be less than m');
    }
    var n = passwords.length;
    var secrets = shamir.share(seed, n, m);
    var shards = _.zipWith(secrets, passwords, function (shard, password) {
        return _this.encrypt({ input: shard, password: password });
    });
    var node = bitcoin.HDNode.fromSeedHex(seed);
    return {
        xpub: node.neutered().toBase58(),
        m: m,
        n: n,
        seedShares: shards
    };
};
/**
 *
 * @param shards
 * @param passwords
 * @returns {{xpub: *, xprv: *}}
 */
BitGo.prototype.reconstituteSecret = function (_a) {
    var _this = this;
    var shards = _a.shards, passwords = _a.passwords;
    if (!Array.isArray(shards)) {
        throw new Error('shards must be an array');
    }
    if (!Array.isArray(passwords)) {
        throw new Error('passwords must be an array');
    }
    if (shards.length !== passwords.length) {
        throw new Error('shards and passwords arrays must have same length');
    }
    var secrets = _.zipWith(shards, passwords, function (shard, password) {
        return _this.decrypt({ input: shard, password: password });
    });
    var seed = shamir.combine(secrets);
    var node = bitcoin.HDNode.fromSeedHex(seed);
    return {
        xpub: node.neutered().toBase58(),
        xprv: node.toBase58(),
        seed: seed
    };
};
/**
 *
 * @param shards
 * @param passwords
 * @param m
 * @param xpub Optional xpub to verify the results against
 */
BitGo.prototype.verifyShards = function (_a) {
    var _this = this;
    var shards = _a.shards, passwords = _a.passwords, m = _a.m, xpub = _a.xpub;
    /**
     * Generate all possible combinations of a given array's values given subset size m
     * @param array The array whose values are to be arranged in all combinations
     * @param m The size of each subset
     * @param entryIndices Recursively trailing set of currently chosen array indices for the combination subset under construction
     * @returns {Array}
     */
    var generateCombinations = function (array, m, entryIndices) {
        if (entryIndices === void 0) { entryIndices = []; }
        var combinations = [];
        if (entryIndices.length === m) {
            var currentCombination = _.at(array, entryIndices);
            return [currentCombination];
        }
        // The highest index
        var entryIndex = _.last(entryIndices);
        // If there are currently no indices, assume -1
        if (_.isUndefined(entryIndex)) {
            entryIndex = -1;
        }
        for (var i = entryIndex + 1; i < array.length; i++) {
            // append the current index to the trailing indices
            var currentEntryIndices = entryIndices.concat([i]);
            var newCombinations = generateCombinations(array, m, currentEntryIndices);
            combinations = combinations.concat(newCombinations);
        }
        return combinations;
    };
    if (!Array.isArray(shards)) {
        throw new Error('shards must be an array');
    }
    if (!Array.isArray(passwords)) {
        throw new Error('passwords must be an array');
    }
    if (shards.length !== passwords.length) {
        throw new Error('shards and passwords arrays must have same length');
    }
    var secrets = _.zipWith(shards, passwords, function (shard, password) {
        return _this.decrypt({ input: shard, password: password });
    });
    var secretCombinations = generateCombinations(secrets, m);
    var seeds = secretCombinations.map(function (currentCombination) {
        return shamir.combine(currentCombination);
    });
    var uniqueSeeds = _.uniq(seeds);
    if (uniqueSeeds.length !== 1) {
        return false;
    }
    var seed = _.first(uniqueSeeds);
    var node = bitcoin.HDNode.fromSeedHex(seed);
    var restoredXpub = node.neutered().toBase58();
    if (!_.isUndefined(xpub)) {
        if (!_.isString(xpub)) {
            throw new Error('xpub must be a string');
        }
        if (restoredXpub !== xpub) {
            return false;
        }
    }
    return true;
};
//
// ecdhSecret
// Construct an ECDH secret from a private key and other user's public key
//
BitGo.prototype.getECDHSecret = function (params) {
    params = params || {};
    common.validateParams(params, ['otherPubKeyHex'], []);
    if (!_.isObject(params.eckey)) {
        throw new Error('eckey object required');
    }
    var otherKeyPub = bitcoin.ECPair.fromPublicKeyBuffer(new Buffer(params.otherPubKeyHex, 'hex'));
    var secretPoint = otherKeyPub.Q.multiply(params.eckey.d);
    var secret = Util.bnToByteArrayUnsigned(secretPoint.affineX);
    return new Buffer(secret).toString('hex');
};
//
// user sharing keychain
// Gets the user's private keychain, used for receiving shares
BitGo.prototype.getECDHSharingKeychain = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], []);
    var self = this;
    return this.get(this.url('/user/settings'))
        .result()
        .then(function (result) {
        if (!result.settings.ecdhKeychain) {
            return self.reject('ecdh keychain not found for user', callback);
        }
        return self.keychains().get({ xpub: result.settings.ecdhKeychain });
    })
        .nodeify(callback);
};
/**
 * Get bitcoin market data
 */
BitGo.prototype.markets = function () {
    if (!this._markets) {
        this._markets = new Markets(this);
    }
    return this._markets;
};
//
// (Deprecated: Will be removed in the future) use bitgo.markets().latest()
// market
// Get the latest bitcoin prices.
//
BitGo.prototype.market = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.get(this.url('/market/latest'))
        .result()
        .nodeify(callback);
};
//
// (Deprecated: Will be removed in the future) use bitgo.markets().yesterday()
// market data yesterday
// Get market data from yesterday
//
BitGo.prototype.yesterday = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.get(this.url('/market/yesterday'))
        .result()
        .nodeify(callback);
};
/**
 * Synchronous method for activating an access token.
 * @param params
 *  - accessToken: the token to be used
 * @param callback
 */
BitGo.prototype.authenticateWithAccessToken = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['accessToken'], [], callback);
    this._token = params.accessToken;
};
/**
 *
 * @param responseBody Response body object
 * @param password Password for the symmetric decryption
 */
BitGo.prototype.handleTokenIssuance = function (responseBody, password) {
    // make sure the response body contains the necessary properties
    common.validateParams(responseBody, ['derivationPath'], ['encryptedECDHXprv']);
    var environment = this.env;
    var environmentConfig = common.Environments[environment];
    var serverXpub = environmentConfig.serverXpub;
    var ecdhXprv = this._ecdhXprv;
    if (!ecdhXprv) {
        if (!password || !responseBody.encryptedECDHXprv) {
            throw new Error('ecdhXprv property must be set or password and encrypted encryptedECDHXprv must be provided');
        }
        try {
            ecdhXprv = this.decrypt({ input: responseBody.encryptedECDHXprv, password: password });
        }
        catch (e) {
            e.errorCode = 'ecdh_xprv_decryption_failure';
            console.error('Failed to decrypt encryptedECDHXprv.');
            throw e;
        }
    }
    // construct HDNode objects for client's xprv and server's xpub
    var clientHDNode = bitcoin.HDNode.fromBase58(ecdhXprv);
    var serverHDNode = bitcoin.HDNode.fromBase58(serverXpub);
    // BIP32 derivation path is applied to both client and server master keys
    var derivationPath = responseBody.derivationPath;
    var clientDerivedNode = bitcoin.hdPath(clientHDNode).derive(derivationPath);
    var serverDerivedNode = bitcoin.hdPath(serverHDNode).derive(derivationPath);
    // calculating one-time ECDH key
    var secretPoint = serverDerivedNode.keyPair.__Q.multiply(clientDerivedNode.keyPair.d);
    var secret = secretPoint.getEncoded().toString('hex');
    // decrypt token with symmetric ECDH key
    var response = {};
    try {
        response.token = this.decrypt({ input: responseBody.encryptedToken, password: secret });
    }
    catch (e) {
        e.errorCode = 'token_decryption_failure';
        console.error('Failed to decrypt token.');
        throw e;
    }
    if (!this._ecdhXprv) {
        response.ecdhXprv = ecdhXprv;
    }
    return response;
};
/**
 * Calculate the string that is to be HMACed for a certain HTTP request or response
 * @param urlPath
 * @param text
 * @param timestamp
 * @param statusCode Only set for HTTP responses, leave blank for requests
 * @returns {string}
 */
BitGo.prototype.calculateHMACSubject = function (_a) {
    var urlPath = _a.urlPath, text = _a.text, timestamp = _a.timestamp, statusCode = _a.statusCode;
    var urlDetails = url.parse(urlPath);
    var queryPath = (urlDetails.query && urlDetails.query.length > 0) ? urlDetails.path : urlDetails.pathname;
    if (!_.isUndefined(statusCode) && _.isInteger(statusCode) && _.isFinite(statusCode)) {
        return [timestamp, queryPath, statusCode, text].join('|');
    }
    return [timestamp, queryPath, text].join('|');
};
/**
 * Calculate the HMAC for an HTTP request
 * @param urlPath
 * @param text
 * @param timestamp
 * @param token
 * @returns {*}
 */
BitGo.prototype.calculateRequestHMAC = function (_a) {
    var urlPath = _a.url, text = _a.text, timestamp = _a.timestamp, token = _a.token;
    var signatureSubject = this.calculateHMACSubject({ urlPath: urlPath, text: text, timestamp: timestamp });
    // calculate the HMAC
    return this.calculateHMAC(token, signatureSubject);
};
/**
 * Calculate request headers with HMAC
 * @param url
 * @param text
 * @param token
 * @returns {{hmac: *, timestamp: number, tokenHash: *}}
 */
BitGo.prototype.calculateRequestHeaders = function (_a) {
    var url = _a.url, text = _a.text, token = _a.token;
    var timestamp = Date.now();
    var hmac = this.calculateRequestHMAC({ url: url, text: text, timestamp: timestamp, token: token });
    // calculate the SHA256 hash of the token
    var hashDigest = sjcl.hash.sha256.hash(token);
    var tokenHash = sjcl.codec.hex.fromBits(hashDigest);
    return {
        hmac: hmac,
        timestamp: timestamp,
        tokenHash: tokenHash
    };
};
/**
 * Verify the HMAC for an HTTP response
 * @param url
 * @param statusCode
 * @param text
 * @param timestamp
 * @param token Authentication token
 * @param hmac
 * @returns {{isValid: boolean, expectedHmac: *, signatureSubject: *}}
 */
BitGo.prototype.verifyResponse = function (_a) {
    var urlPath = _a.url, statusCode = _a.statusCode, text = _a.text, timestamp = _a.timestamp, token = _a.token, hmac = _a.hmac;
    var signatureSubject = this.calculateHMACSubject({ urlPath: urlPath, text: text, timestamp: timestamp, statusCode: statusCode });
    // calculate the HMAC
    var expectedHmac = this.calculateHMAC(token, signatureSubject);
    // verify the HMAC and timestamp
    return {
        isValid: expectedHmac === hmac,
        expectedHmac: expectedHmac,
        signatureSubject: signatureSubject
    };
};
/**
 *
 * @param params
 * @param callback
 */
BitGo.prototype.preprocessAuthenticationParams = function (params) {
    params = params || {};
    common.validateParams(params, ['username', 'password'], ['otp']);
    var username = params.username.toLowerCase();
    var password = params.password;
    var otp = params.otp;
    var trust = params.trust;
    // Calculate the password HMAC so we don't send clear-text passwords
    var hmacPassword = this.calculateHMAC(username, password);
    var authParams = {
        email: username,
        password: hmacPassword,
        forceSMS: !!params.forceSMS
    };
    if (otp) {
        authParams.otp = otp;
        if (trust) {
            authParams.trust = 1;
        }
    }
    if (params.extensible) {
        this._extensionKey = bitcoin.makeRandomKey();
        authParams.extensible = true;
        authParams.extensionAddress = this._extensionKey.getAddress();
    }
    return authParams;
};
//
// authenticate
// Login to the bitgo system.
// Params:
// - forceV1Auth (boolean)
// Returns:
//   {
//     token: <user's token>,
//     user: <user object
//   }
BitGo.prototype.authenticate = function (params, callback) {
    params = params || {};
    var forceV1Auth = !!params.forceV1Auth;
    if (callback && !_.isFunction(callback)) {
        throw new Error('callback parameter must be a function');
    }
    var authParams = this.preprocessAuthenticationParams(params, callback);
    var password = params.password;
    var self = this;
    if (this._token) {
        return this.reject('already logged in', callback);
    }
    var authUrl = this._microservicesUrl ? this.microservicesUrl('/api/v1/auth/session') : this.url('/user/login');
    var request = this.post(authUrl);
    if (forceV1Auth) {
        request.forceV1Auth = true;
        // tell the server that the client was forced to downgrade the authentication protocol
        authParams.forceV1Auth = true;
    }
    return request.send(authParams)
        .then(function (response) {
        // extract body and user information
        var body = response.body;
        self._user = body.user;
        if (body.access_token) {
            self._token = body.access_token;
            // if the downgrade was forced, adding a warning message might be prudent
        }
        else {
            // check the presence of an encrypted ECDH xprv
            // if not present, legacy account
            var encryptedXprv = body.encryptedECDHXprv;
            if (!encryptedXprv) {
                throw new Error('Keychain needs encryptedXprv property');
            }
            var responseDetails = self.handleTokenIssuance(response.body, password);
            self._token = responseDetails.token;
            self._ecdhXprv = responseDetails.ecdhXprv;
            // verify the response's authenticity
            request.verifyResponse(response);
            // add the remaining component for easier access
            response.body.access_token = self._token;
        }
        return response;
    })
        .then(handleResponseResult(), handleResponseError)
        .nodeify(callback);
};
/**
 *
 * @param params
 * - operatingSystem: one of ios, android
 * - pushToken: hex-formatted token for the respective native push notification service
 * @param callback
 * @returns {*}
 */
BitGo.prototype.registerPushToken = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['pushToken', 'operatingSystem'], [], callback);
    if (!this._token) {
        // this device has to be registered to an extensible session
        return this.reject('not logged in', callback);
    }
    var postParams = _.pick(params, ['pushToken', 'operatingSystem']);
    return this.post(this.url('/devices'))
        .send(postParams)
        .result()
        .nodeify(callback);
};
/**
 *
 * @param params
 * - pushVerificationToken: the token received via push notification to confirm the device's mobility
 * @param callback
 */
BitGo.prototype.verifyPushToken = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['pushVerificationToken'], [], callback);
    if (!this._token) {
        // this device has to be registered to an extensible session
        return this.reject('not logged in', callback);
    }
    var postParams = _.pick(params, 'pushVerificationToken');
    return this.post(this.url('/devices/verify'))
        .send(postParams)
        .result()
        .nodeify(callback);
};
//
// authenticateWithAuthCode
// Login to the bitgo system using an authcode generated via Oauth
// Returns:
//   {
//     authCode: <authentication code sent from the BitGo OAuth redirect>
//   }
BitGo.prototype.authenticateWithAuthCode = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['authCode'], [], callback);
    if (!this._clientId || !this._clientSecret) {
        throw new Error('Need client id and secret set first to use this');
    }
    var authCode = params.authCode;
    var self = this;
    if (this._token) {
        return this.reject('already logged in', callback);
    }
    var token_result;
    var request = this.post(this._baseUrl + '/oauth/token');
    request.forceV1Auth = true; // OAuth currently only supports v1 authentication
    return request
        .send({
        grant_type: 'authorization_code',
        code: authCode,
        client_id: self._clientId,
        client_secret: self._clientSecret
    })
        .result()
        .then(function (body) {
        token_result = body;
        self._token = body.access_token;
        self._refreshToken = body.refresh_token;
        return self.me();
    })
        .then(function (user) {
        self._user = user;
        return token_result;
    })
        .nodeify(callback);
};
//
// refreshToken
// Use refresh token to get new access token.
// If the refresh token is null/defined, then we use the stored token from auth
// Returns:
//   {
//     refreshToken: <optional refresh code sent from a previous authcode>
//   }
BitGo.prototype.refreshToken = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['refreshToken'], callback);
    var refreshToken = params.refreshToken || this._refreshToken;
    if (!refreshToken) {
        throw new Error('Must provide refresh token or have authenticated with Oauth before');
    }
    if (!this._clientId || !this._clientSecret) {
        throw new Error('Need client id and secret set first to use this');
    }
    var self = this;
    return this.post(this._baseUrl + '/oauth/token')
        .send({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: self._clientId,
        client_secret: self._clientSecret
    })
        .result()
        .then(function (body) {
        self._token = body.access_token;
        self._refreshToken = body.refresh_token;
        return body;
    })
        .nodeify(callback);
};
//
// listAccessTokens
// Get information on all of the BitGo access tokens on the user
// Returns:
// {
//    id: <id of the token>
//    label: <the user-provided label for this token>
//    user: <id of the user on the token>
//    enterprise <id of the enterprise this token is valid for>
//    client: <the auth client that this token belongs to>
//    scope: <list of allowed OAuth scope values>
//    created: <date the token was created>
//    expires: <date the token will expire>
//    origin: <the origin for which this token is valid>
//    isExtensible: <flag indicating if the token can be extended>
//    extensionAddress: <address whose private key's signature is necessary for extensions>
//    unlock: <info for actions that require an unlock before firing>
// }
//
BitGo.prototype.listAccessTokens = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.get(this.url('/user/accesstoken'))
        .send()
        .result('accessTokens')
        .nodeify(callback);
};
//
// addAccessToken
// Add a BitGo API Access Token to the current user account
// Params:
// {
//    otp: (required) <valid otp code>
//    label: (required) <label for the token>
//    duration: <length of time in seconds the token will be valid for>
//    ipRestrict: <array of IP address strings to whitelist>
//    txValueLimit: <number of outgoing satoshis allowed on this token>
//    scope: (required) <authorization scope of the requested token>
// }
// Returns:
// {
//    id: <id of the token>
//    token: <access token hex string to be used for BitGo API request verification>
//    label: <user-provided label for this token>
//    user: <id of the user on the token>
//    enterprise <id of the enterprise this token is valid for>
//    client: <the auth client that this token belongs to>
//    scope: <list of allowed OAuth scope values>
//    created: <date the token was created>
//    expires: <date the token will expire>
//    origin: <the origin for which this token is valid>
//    isExtensible: <flag indicating if the token can be extended>
//    extensionAddress: <address whose private key's signature is necessary for extensions>
//    unlock: <info for actions that require an unlock before firing>
// }
//
BitGo.prototype.addAccessToken = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['label'], ['otp'], callback);
    // check non-string params
    if (params.duration) {
        if (!_.isNumber(params.duration) || params.duration < 0) {
            throw new Error('duration must be a non-negative number');
        }
    }
    if (params.ipRestrict) {
        if (!_.isArray(params.ipRestrict)) {
            throw new Error('ipRestrict must be an array');
        }
        _.forEach(params.ipRestrict, function (ipAddr) {
            if (!_.isString(ipAddr)) {
                throw new Error('ipRestrict must be an array of IP address strings');
            }
        });
    }
    if (params.txValueLimit) {
        if (!_.isNumber(params.txValueLimit)) {
            throw new Error('txValueLimit must be a number');
        }
        if (params.txValueLimit < 0) {
            throw new Error('txValueLimit must be a non-negative number');
        }
    }
    if (params.scope && params.scope.length > 0) {
        if (!_.isArray(params.scope)) {
            throw new Error('scope must be an array');
        }
    }
    else {
        throw new Error('must specify scope for token');
    }
    var bitgo = this;
    var authUrl = this._microservicesUrl ? this.microservicesUrl('/api/v1/auth/accesstoken') : this.url('/user/accesstoken');
    var request = this.post(authUrl);
    if (!bitgo._ecdhXprv) {
        // without a private key, the user cannot decrypt the new access token the server will send
        request.forceV1Auth = true;
    }
    return request.send(params)
        .then(function (response) {
        if (request.forceV1Auth) {
            response.body.warning = 'A protocol downgrade has occurred because this is a legacy account.';
            return response;
        }
        // verify the authenticity of the server's response before proceeding any further
        request.verifyResponse(response);
        var responseDetails = bitgo.handleTokenIssuance(response.body);
        response.body.token = responseDetails.token;
        return response;
    })
        .then(handleResponseResult(), handleResponseError)
        .nodeify(callback);
};
//
// removeAccessToken
// Sets the expire time of an access token matching either the id or label to the current date, effectively deleting it
// Params:
// {
//    id: <id of the access token to be deleted>
//    label: <label of the access token to be deleted>
// }
// Returns:
// {
//    id: <id of the token>
//    label: <user-provided label for this token>
//    user: <id of the user on the token>
//    enterprise <id of the enterprise this token is valid for>
//    client: <the auth client that this token belongs to>
//    scope: <list of allowed OAuth scope values>
//    created: <date the token was created>
//    expires: <date the token will expire>
//    origin: <the origin for which this token is valid>
//    isExtensible: <flag indicating if the token can be extended>
//    extensionAddress: <address whose private key's signature is necessary for extensions>
//    unlock: <info for actions that require an unlock before firing>
// }
//
BitGo.prototype.removeAccessToken = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['id', 'label'], callback);
    var labelIdCount = _(params).pick('id', 'label').keys().value();
    if (labelIdCount.length !== 1) {
        throw new Error('must provide exactly one of id or label');
    }
    var self = this;
    return Promise.try(function () {
        if (params.id) {
            return params.id;
        }
        // we have to get the id of the token by using the label before we can delete it
        return self.listAccessTokens()
            .then(function (tokens) {
            if (!tokens) {
                throw new Error('token with this label does not exist');
            }
            var matchingTokens = _.filter(tokens, { label: params.label });
            if (matchingTokens.length > 1) {
                throw new Error('ambiguous call: multiple tokens matching this label');
            }
            if (matchingTokens.length === 0) {
                throw new Error('token with this label does not exist');
            }
            return matchingTokens[0].id;
        });
    })
        .then(function (tokenId) {
        return self.del(self.url('/user/accesstoken/' + tokenId))
            .send()
            .result();
    })
        .nodeify(callback);
};
//
// logout
// Logout of BitGo
//
BitGo.prototype.logout = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var self = this;
    return this.get(this.url('/user/logout'))
        .result()
        .then(function () {
        self.clear();
    })
        .nodeify(callback);
};
//
// getUser
// Get a user by ID (name/email only)
//
BitGo.prototype.getUser = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    return this.get(this.url('/user/' + params.id))
        .result('user')
        .nodeify(callback);
};
/**
 * Change the password of the currently logged in user, also change all v1 and v2 keychain passwords if they match the
 * given oldPassword. Returns nothing on success or throws an error when something went wrong.
 * @param params.oldPassword {String} - the current password
 * @param params.newPassword {String} - the new password
 * @param callback
 */
BitGo.prototype.changePassword = function (params, callback) {
    return co(function coChangePassword() {
        var validation, coin, updateKeychainPasswordParams, v1KeychainUpdatePWResult, v2Keychains, updatePasswordParams;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    params = params || {};
                    common.validateParams(params, ['oldPassword', 'newPassword'], [], callback);
                    return [4 /*yield*/, this.verifyPassword({ password: params.oldPassword })];
                case 1:
                    validation = _a.sent();
                    if (!validation) {
                        throw new Error('the provided oldPassword is incorrect');
                    }
                    coin = common.Environments[this.getEnv()].network === 'bitcoin' ? 'btc' : 'tbtc';
                    updateKeychainPasswordParams = { oldPassword: params.oldPassword, newPassword: params.newPassword };
                    return [4 /*yield*/, this.keychains().updatePassword(updateKeychainPasswordParams)];
                case 2:
                    v1KeychainUpdatePWResult = _a.sent();
                    return [4 /*yield*/, this.coin(coin).keychains().updatePassword(updateKeychainPasswordParams)];
                case 3:
                    v2Keychains = _a.sent();
                    updatePasswordParams = {
                        keychains: v1KeychainUpdatePWResult.keychains,
                        v2_keychains: v2Keychains,
                        version: v1KeychainUpdatePWResult.version,
                        oldPassword: this.calculateHMAC(this.user().username, params.oldPassword),
                        password: this.calculateHMAC(this.user().username, params.newPassword)
                    };
                    return [2 /*return*/, this.post(this.url('/user/changepassword'))
                            .send(updatePasswordParams)
                            .result()];
            }
        });
    }).call(this).asCallback(callback);
};
//
// me
// Get the current logged in user
//
BitGo.prototype.me = function (params, callback) {
    return this.getUser({ id: 'me' }, callback);
};
/**
 * Unlock the session by providing OTP
 * @param {string} otp Required OTP code for the account.
 * @param {number} duration Desired duration of the unlock in seconds (default=600, max=3600).
 */
BitGo.prototype.unlock = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['otp'], callback);
    return this.post(this.url('/user/unlock'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// lock
// Lock the session
//
BitGo.prototype.lock = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.post(this.url('/user/lock'))
        .result()
        .nodeify(callback);
};
//
// me
// Get the current session
//
BitGo.prototype.session = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.get(this.url('/user/session'))
        .result('session')
        .nodeify(callback);
};
/**
 * Trigger a push/sms for the OTP code
 * @param {boolean} forceSMS If set to true, will use SMS to send the OTP to the user even if they have other 2FA method set up.
 */
BitGo.prototype.sendOTP = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.post(this.url('/user/sendotp'))
        .send(params)
        .result()
        .nodeify(callback);
};
/**
 * Extend token, provided the current token is extendable
 * @param params
 * - duration: duration in seconds by which to extend the token, starting at the current time
 * @param callback
 */
BitGo.prototype.extendToken = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var timestamp = Date.now();
    var duration = params.duration;
    var message = timestamp + '|' + this._token + '|' + duration;
    var privateKey = this._extensionKey.d.toBuffer(32);
    var isCompressed = this._extensionKey.compressed;
    var prefix = bitcoin.networks.bitcoin.messagePrefix;
    var signature = bitcoinMessage.sign(message, privateKey, isCompressed, prefix).toString('hex');
    return this.post(this.url('/user/extendtoken'))
        .send(params)
        .set('timestamp', timestamp)
        .set('signature', signature)
        .result()
        .nodeify(callback);
};
//
// getSharingKey
// Get a key for sharing a wallet with a user
//
BitGo.prototype.getSharingKey = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['email'], [], callback);
    return this.post(this.url('/user/sharingkey'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// ping
// Test connectivity to the server
//
BitGo.prototype.ping = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (params.reqId) {
        this._reqId = params.reqId;
    }
    return this.get(this.url('/ping'))
        .result()
        .nodeify(callback);
};
//
// Blockchain
// Get the blockchain object.
//
BitGo.prototype.blockchain = function () {
    if (!this._blockchain) {
        this._blockchain = new Blockchain(this);
    }
    return this._blockchain;
};
//
// keychains
// Get the user's keychains object.
//
BitGo.prototype.keychains = function () {
    if (!this._keychains) {
        this._keychains = new Keychains(this);
    }
    return this._keychains;
};
//
// wallets
// Get the user's wallets object.
//
BitGo.prototype.wallets = function () {
    if (!this._wallets) {
        this._wallets = new Wallets(this);
    }
    return this._wallets;
};
//
// travel rule
// Get the travel rule object
//
BitGo.prototype.travelRule = function () {
    if (!this._travel) {
        this._travelRule = new TravelRule(this);
    }
    return this._travelRule;
};
//
// pendingApprovals
// Get pending approvals that can be approved/ or rejected
//
BitGo.prototype.pendingApprovals = function () {
    if (!this._pendingApprovals) {
        this._pendingApprovals = new PendingApprovals(this);
    }
    return this._pendingApprovals;
};
//
// newWalletObject
// A factory method to create a new Wallet object, initialized with the wallet params
// Can be used to reconstitute a wallet from cached data
//
BitGo.prototype.newWalletObject = function (walletParams) {
    return new Wallet(this, walletParams);
};
BitGo.prototype.url = function (path, version) {
    if (version === void 0) { version = 1; }
    var baseUrl = version === 2 ? this._baseApiUrlV2 : this._baseApiUrl;
    return baseUrl + path;
};
BitGo.prototype.microservicesUrl = function (path) {
    return this._microservicesUrl + path;
};
//
// labels
// Get all the address labels on all of the user's wallets
//
BitGo.prototype.labels = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.get(this.url('/labels'))
        .result('labels')
        .nodeify(callback);
};
/**
* Estimates approximate fee per kb needed for a tx to get into a block
* @param {number} numBlocks target blocks for the transaction to be confirmed
* @param {number} maxFee maximum fee willing to be paid (for safety)
* @param {array[string]} inputs list of unconfirmed txIds from which this transaction uses inputs
* @param {number} txSize estimated transaction size in bytes, optional parameter used for CPFP estimation.
* @param {boolean} cpfpAware flag indicating fee should take into account CPFP
* @returns
*/
BitGo.prototype.estimateFee = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var queryParams = { version: 12 };
    if (params.numBlocks) {
        if (!_.isNumber(params.numBlocks)) {
            throw new Error('invalid argument');
        }
        queryParams.numBlocks = params.numBlocks;
    }
    if (params.maxFee) {
        if (!_.isNumber(params.maxFee)) {
            throw new Error('invalid argument');
        }
        queryParams.maxFee = params.maxFee;
    }
    if (params.inputs) {
        if (!Array.isArray(params.inputs)) {
            throw new Error('invalid argument');
        }
        queryParams.inputs = params.inputs;
    }
    if (params.txSize) {
        if (!_.isNumber(params.txSize)) {
            throw new Error('invalid argument');
        }
        queryParams.txSize = params.txSize;
    }
    if (params.cpfpAware) {
        if (!_.isBoolean(params.cpfpAware)) {
            throw new Error('invalid argument');
        }
        queryParams.cpfpAware = params.cpfpAware;
    }
    return this.get(this.url('/tx/fee'))
        .query(queryParams)
        .result()
        .nodeify(callback);
};
//
// instantGuarantee
// Get BitGo's guarantee using an instant id
//
BitGo.prototype.instantGuarantee = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    var self = this;
    return this.get(this.url('/instant/' + params.id))
        .result()
        .then(function (body) {
        if (!body.guarantee) {
            throw new Error('no guarantee found in response body');
        }
        if (!body.signature) {
            throw new Error('no signature found in guarantee response body');
        }
        var signingAddress = common.Environments[self.env].signingAddress;
        var signatureBuffer = new Buffer(body.signature, 'hex');
        var prefix = bitcoin.getNetwork().messagePrefix;
        var isValidSignature = bitcoinMessage.verify(body.guarantee, signingAddress, signatureBuffer, prefix);
        if (!isValidSignature) {
            throw new Error('incorrect signature');
        }
        return body;
    })
        .nodeify(callback);
};
//
// getBitGoFeeAddress
// Get a target address for payment of a BitGo fee
//
BitGo.prototype.getBitGoFeeAddress = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.post(this.url('/billing/address'))
        .send({})
        .result()
        .nodeify(callback);
};
/**
 * Gets an address object (including the wallet id) for a given address.
 * @param {string} address The address to look up.
 */
BitGo.prototype.getWalletAddress = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address'], [], callback);
    return this.get(this.url('/walletaddress/' + params.address))
        .result()
        .nodeify(callback);
};
/**
 * Fetch list of user webhooks
 *
 * @param callback
 * @returns {*}
 */
BitGo.prototype.listWebhooks = function (callback) {
    return this.get(this.url('/webhooks'))
        .result()
        .nodeify(callback);
};
/**
 * Add new user webhook
 *
 * @param params
 * @param callback
 * @returns {*}
 */
BitGo.prototype.addWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['url', 'type'], [], callback);
    return this.post(this.url('/webhooks'))
        .send(params)
        .result()
        .nodeify(callback);
};
/**
 * Remove user webhook
 *
 * @param params
 * @param callback
 * @returns {*}
 */
BitGo.prototype.removeWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['url', 'type'], [], callback);
    return this.del(this.url('/webhooks'))
        .send(params)
        .result()
        .nodeify(callback);
};
/**
 * Fetch list of webhook notifications for the user
 *
 * @param params
 * @param callback
 * @returns {*}
 */
BitGo.prototype.listWebhookNotifications = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var query = {};
    if (params.prevId) {
        if (!_.isString(params.prevId)) {
            throw new Error('invalid prevId argument, expecting string');
        }
        query.prevId = params.prevId;
    }
    if (params.limit) {
        if (!_.isNumber(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        query.limit = params.limit;
    }
    return this.get(this.url('/webhooks/notifications'))
        .query(query)
        .result()
        .nodeify(callback);
};
/**
 * Simulate a user webhook
 *
 * @param params
 * @param callback
 * @returns {*}
 */
BitGo.prototype.simulateWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['webhookId', 'blockId'], [], callback);
    var webhookId = params.webhookId;
    return this.post(this.url('/webhooks/' + webhookId + '/simulate'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// fetchConstants
// Receives a TTL and refetches as necessary
//
BitGo.prototype.fetchConstants = function (params, callback) {
    return co(function () {
        var env, resultPromise, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    env = this.env;
                    if (!BitGo.prototype._constants) {
                        BitGo.prototype._constants = {};
                    }
                    if (!BitGo.prototype._constantsExpire) {
                        BitGo.prototype._constantsExpire = {};
                    }
                    if (BitGo.prototype._constants[env] && BitGo.prototype._constantsExpire[env] && new Date() < BitGo.prototype._constantsExpire[env]) {
                        return [2 /*return*/, BitGo.prototype._constants[env]];
                    }
                    resultPromise = superagent.get(this.url('/client/constants'));
                    return [4 /*yield*/, (this.proxy ? resultPromise.proxy(this.proxy) : resultPromise)];
                case 1:
                    result = _a.sent();
                    BitGo.prototype._constants[env] = result.body.constants;
                    BitGo.prototype._constantsExpire[env] = moment.utc().add(result.body.ttl, 'second').toDate();
                    return [2 /*return*/, BitGo.prototype._constants[env]];
            }
        });
    }).call(this).asCallback(callback);
};
/**
 * Synchronously get constants which are relevant to the client.
 *
 * Note: This function has a known race condition. It may return different values over time,
 * especially if called shortly after creation of the BitGo object.
 *
 * New code should call fetchConstants() directly instead.
 *
 * @deprecated
 * @param params
 * @return {Object} The client constants object
 */
BitGo.prototype.getConstants = function (params) {
    params = params || {};
    // kick off a fresh request for the client constants
    this.fetchConstants(params, function (err) {
        if (err) {
            // make sure an error does not terminate the entire script
            console.error('failed to fetch client constants from BitGo');
            console.trace(err);
        }
    });
    // use defaultConstants as the backup for keys that are not set in this._constants
    return _.merge({}, config.defaultConstants(this.env), BitGo.prototype._constants[this.env]);
};
module.exports = BitGo;
//# sourceMappingURL=bitgo.js.map