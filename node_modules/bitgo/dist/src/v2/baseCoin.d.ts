declare class BaseCoin {
    bitgo: any;
    static getInstance(bitgo: any, coin: any): any;
    static setupTokens(coins: any, bitgo: any): void;
    static setupOffchainTokens(coins: any, bitgo: any): void;
    /**
     * This feature is mostly for browsers where we don't want to have a build with coins that people don't need
     * In order to specify the coins you want, you must pass the env.coins="csv coins"
     * If nothing is passed, all coins are going to be available.
     * In webpack, we have to define via plugin what we want. to exclude but also we want to include the coins if the
     * user didn't specify anything or in node environments
     * @returns {}
     */
    static getCoinsToInitialize(bitgo: any): any;
    static initializeCoin(coin: any, bitgo: any): any;
    /**
     * Name of the chain which supports this coin (eg, 'btc', 'eth')
     */
    getChain(): void;
    /**
     * Name of the coin family (eg. for tbtc, this would be btc)
     */
    getFamily(): void;
    /**
     * Human readable full name for the coin
     */
    getFullName(): void;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed(): boolean;
    getBaseFactor(): void;
    /**
     * Convert a currency amount represented in base units (satoshi, wei, atoms, drops, stroops)
     * to big units (btc, eth, rmg, xrp, xlm)
     * @param {string|number} baseUnits
     * @returns {string}
     */
    baseUnitsToBigUnits(baseUnits: any): any;
    /**
     * Convert a currency amount represented in big units (btc, eth, rmg, xrp, xlm)
     * to base units (satoshi, wei, atoms, drops, stroops)
     * @param bigUnits
     */
    bigUnitsToBaseUnits(bigUnits: any): any;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    signMessage(key: any, message: any): any;
    /**
     * Verify that a transaction prebuild complies with the original intention
     */
    verifyTransaction(params: any, callback: any): any;
    /**
     * Verify that an address belongs to a wallet
     * @returns {boolean}
     */
    verifyAddress(params: any): any;
    /**
     * Check whether a coin supports blockTarget for transactions to be included in
     * @returns {boolean}
     */
    supportsBlockTarget(): boolean;
    /**
     * If a coin needs to add additional parameters to the wallet generation, it does it in this method
     * @param walletParams
     * @return {*}
     */
    supplementGenerateWallet(walletParams: any): any;
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    postProcessPrebuild(prebuildResponse: any, callback: any): any;
    newWalletObject(walletParams: any): any;
    toJSON(): any;
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Integer} params.numBlocks The number of blocks to target for conformation (Only works for btc)
     * @param callback
     * @returns {Object} The info returned from the merchant server
     */
    feeEstimate(params: any, callback: any): any;
    /**
     * The cold wallet tool uses this function to derive an extended key that is based on the passed key and seed
     * @param key
     * @param seed
     * @returns {{key: *, derivationPath: string}}
     */
    deriveKeyWithSeed({ key, seed }: {
        key: any;
        seed: any;
    }): {
        key: any;
        derivationPath: string;
    };
    /**
     * Perform additional checks before adding a bitgo key. Base controller
     * is a no-op, but coin-specific controller may do something
     * @param params
     */
    preCreateBitGo(params: any): void;
    initiateRecovery(params: any): any;
    verifyRecoveryTransaction(txInfo: any): any;
    parseTransaction(params: any, callback: any): any;
    /**
     * Generate a key pair on the curve used by the coin
     *
     * @param seed
     */
    generateKeyPair(seed: any): void;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: any): void;
    /**
     * Return wether the given m of n wallet signers/ key amounts are valid for the coin
     */
    isValidMofNSetup({ m, n }: {
        m: any;
        n: any;
    }): boolean;
}
export = BaseCoin;
