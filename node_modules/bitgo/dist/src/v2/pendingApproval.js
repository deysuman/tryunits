"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var common = require("../common");
var Promise = require("bluebird");
var co = Promise.coroutine;
var _ = require("lodash");
var PendingApproval = function (bitgo, baseCoin, pendingApprovalData, wallet) {
    this.bitgo = bitgo;
    this.baseCoin = baseCoin;
    this.wallet = wallet;
    this._pendingApproval = pendingApprovalData;
};
//
// id
// Get the id of this pending approval.
//
PendingApproval.prototype.id = function () {
    return this._pendingApproval.id;
};
//
// ownerType
// Get the owner type (wallet or enterprise)
// Pending approvals can be approved or modified by different scopes (depending on how they were created)
// If a pending approval is owned by a wallet, then it can be approved by administrators of the wallet
// If a pending approval is owned by an enterprise, then it can be approved by administrators of the enterprise
//
PendingApproval.prototype.ownerType = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (this._pendingApproval.wallet) {
        return 'wallet';
    }
    else if (this._pendingApproval.enterprise) {
        return 'enterprise';
    }
    else {
        throw new Error('unexpected pending approval owner: neither wallet nor enterprise was present');
    }
};
//
// walletId
// Get the wallet ID that owns / is associated with the pending approval
//
PendingApproval.prototype.walletId = function () {
    return this._pendingApproval.wallet;
};
//
// enterpriseId
// Get the enterprise ID that owns / is associated with the pending approval
//
PendingApproval.prototype.enterpriseId = function () {
    return this._pendingApproval.enterprise;
};
//
// state
// Get the state of the pending approval
//
PendingApproval.prototype.state = function () {
    return this._pendingApproval.state;
};
//
// creator
// Get the id of the user that performed the action resulting in this pending approval
//
PendingApproval.prototype.creator = function () {
    return this._pendingApproval.creator;
};
//
// type
// Get the type of the pending approval (what it approves)
// Example: transactionRequest, tagUpdateRequest, policyRuleRequest
//
PendingApproval.prototype.type = function () {
    if (!this._pendingApproval.info) {
        throw new Error('pending approval info is not available');
    }
    return this._pendingApproval.info.type;
};
//
// type
// Get information about the pending approval
//
PendingApproval.prototype.info = function () {
    return this._pendingApproval.info;
};
//
// approvalsRequired
// get the number of approvals that are required for this pending approval to be approved.
// Defaults to 1 if approvalsRequired doesn't exist on the object
//
PendingApproval.prototype.approvalsRequired = function () {
    return this._pendingApproval.approvalsRequired || 1;
};
//
// url
// Gets the url for this pending approval
//
PendingApproval.prototype.url = function (extra) {
    extra = extra || '';
    return this.baseCoin.url('/pendingapprovals/' + this.id() + extra);
};
//
// get
// Refetches this pending approval and returns it
//
PendingApproval.prototype.get = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var self = this;
    return this.bitgo.get(this.url())
        .result()
        .then(function (res) {
        self.pendingApproval = res;
        return self;
    })
        .nodeify(callback);
};
//
// Helper function to ensure that self.wallet is set
//
PendingApproval.prototype.populateWallet = function () {
    var self = this;
    if (!self.wallet) {
        return self.baseCoin.wallets().get({ id: self.info().transactionRequest.sourceWallet })
            .then(function (wallet) {
            if (!wallet) {
                throw new Error('unexpected - unable to get wallet using sourcewallet');
            }
            self.wallet = wallet;
        });
    }
    if (self.wallet.id() !== self.info().transactionRequest.sourceWallet) {
        throw new Error('unexpected source wallet for pending approval');
    }
    return Promise.resolve(); // otherwise returns undefined
};
//
// approve
// sets the pending approval to an approved state
//
PendingApproval.prototype.approve = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['walletPassphrase', 'otp'], callback);
    var canRecreateTransaction = true;
    // cold wallets cannot recreate transactions if the only thing provided is the wallet passphrase
    /*
      The transaction can be recreated if either
      – there is an xprv
      – there is a walletPassphrase and the wallet is not cold (because if it's cold, the passphrase is of little use)
      Therefore, if neither of these is true, the transaction cannot be recreated, which is reflected in the if
      statement below.
     */
    var isColdWallet = !!_.get(this.wallet, '_wallet.isCold');
    var isOFCWallet = this.baseCoin.getFamily() === 'ofc'; // Off-chain transactions don't need to be rebuilt
    if (!params.xprv && !(params.walletPassphrase && !isColdWallet && !isOFCWallet)) {
        canRecreateTransaction = false;
    }
    var self = this;
    return Promise.try(function () {
        if (self.type() === 'transactionRequest') {
            /*
            If this is a request for approving a transaction, depending on whether this user has a private key to the wallet
            (some admins may not have the spend permission), the transaction could either be rebroadcast as is, or it could
            be reconstructed. It is preferable to reconstruct a tx in order to adhere to the latest network conditions
            such as newer unspents, different fees, or a higher sequence id
             */
            if (params.tx) {
                // the approval tx was reconstructed and explicitly specified - pass it through
                return {
                    txHex: params.tx
                };
            }
            var transaction = _.get(self.info(), "transactionRequest.coinSpecific." + self.baseCoin.type);
            // this user may not have spending privileges or a passphrase may not have been passed in
            if (!canRecreateTransaction) {
                if (!_.isObject(transaction)) {
                    throw new Error('there is neither an original transaction object nor can a new one be recreated');
                }
                return transaction;
            }
            return self.populateWallet()
                .then(function () {
                return self.recreateAndSignTransaction(params);
            });
        }
    })
        .then(function (transaction) {
        var approvalParams = { state: 'approved', otp: params.otp };
        if (transaction) {
            // if the transaction already has a half signed property, we take that directly
            approvalParams.halfSigned = transaction.halfSigned || transaction;
        }
        return self.bitgo.put(self.url())
            .send(approvalParams)
            .result()
            .nodeify(callback);
    })
        .catch(function (error) {
        if (!canRecreateTransaction &&
            (error.message.indexOf('could not find unspent output for input') !== -1 ||
                error.message.indexOf('transaction conflicts with an existing transaction in the send queue') !== -1)) {
            throw new Error('unspents expired, wallet passphrase or xprv required to recreate transaction');
        }
        throw error;
    });
};
//
// rejected
// sets the pending approval to a rejected state
//
PendingApproval.prototype.reject = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.put(this.url())
        .send({ state: 'rejected' })
        .result()
        .nodeify(callback);
};
//
// cancel
// rejects the pending approval
//
PendingApproval.prototype.cancel = function (params, callback) {
    return this.reject(params, callback);
};
/**
 * Recreate a transaction for a pending approval to respond to updated network conditions
 * @param params
 */
PendingApproval.prototype.recreateAndSignTransaction = function (params) {
    return co(function () {
        var transactionRequest, originalPrebuild, recipients, prebuildParams, signedTransaction, originalParsedTransaction, recreatedParsedTransaction;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    params = _.extend({}, params);
                    common.validateParams(params, [], []);
                    transactionRequest = this.info().transactionRequest;
                    if (!transactionRequest) {
                        throw new Error('cannot recreate transaction without transaction request');
                    }
                    originalPrebuild = transactionRequest.coinSpecific[this.baseCoin.type];
                    recipients = transactionRequest.recipients;
                    prebuildParams = _.extend({}, params, { recipients: recipients }, transactionRequest.buildParams);
                    return [4 /*yield*/, this.wallet.prebuildAndSignTransaction(prebuildParams)];
                case 1:
                    signedTransaction = _a.sent();
                    return [4 /*yield*/, this.baseCoin.parseTransaction({
                            txParams: prebuildParams,
                            wallet: this.wallet,
                            txPrebuild: originalPrebuild
                        })];
                case 2:
                    originalParsedTransaction = _a.sent();
                    return [4 /*yield*/, this.baseCoin.parseTransaction({
                            txParams: prebuildParams,
                            wallet: this.wallet,
                            txPrebuild: signedTransaction
                        })];
                case 3:
                    recreatedParsedTransaction = _a.sent();
                    if (_.isUndefined(recreatedParsedTransaction.implicitExternalSpendAmount)) {
                        return [2 /*return*/, signedTransaction];
                    }
                    if (!_.isFinite(recreatedParsedTransaction.implicitExternalSpendAmount)) {
                        throw new Error('implicit external spend amount could not be determined');
                    }
                    if (!_.isUndefined(originalParsedTransaction.implicitExternalSpendAmount) && (recreatedParsedTransaction.implicitExternalSpendAmount > originalParsedTransaction.implicitExternalSpendAmount)) {
                        throw new Error('recreated transaction is using a higher pay-as-you-go-fee');
                    }
                    return [2 /*return*/, signedTransaction];
            }
        });
    }).call(this);
};
module.exports = PendingApproval;
//# sourceMappingURL=pendingApproval.js.map