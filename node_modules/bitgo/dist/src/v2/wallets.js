"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bitcoin = require('../bitcoin');
var common = require("../common");
var Wallet = require('./wallet');
var Promise = require("bluebird");
var co = Promise.coroutine;
var _ = require("lodash");
var RmgCoin = require('./coins/rmg');
var util = require('../util');
var Wallets = function (bitgo, baseCoin) {
    this.bitgo = bitgo;
    this.baseCoin = baseCoin;
    this.coinWallet = Wallet;
};
Wallets.prototype.createWalletInstance = function () {
    return new this.coinWallet(this.bitgo, this.coin);
};
/**
 * Get a wallet by ID (proxy for getWallet)
 * @param params
 * @param callback
 */
Wallets.prototype.get = function (params, callback) {
    return this.getWallet(params, callback);
};
/**
 * List a user's wallets
 * @param params
 * @param callback
 * @returns {*}
 */
Wallets.prototype.list = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var queryObject = {};
    if (params.skip && params.prevId) {
        throw new Error('cannot specify both skip and prevId');
    }
    if (params.getbalances) {
        if (!_.isBoolean(params.getbalances)) {
            throw new Error('invalid getbalances argument, expecting boolean');
        }
        queryObject.getbalances = params.getbalances;
    }
    if (params.prevId) {
        if (!_.isString(params.prevId)) {
            throw new Error('invalid prevId argument, expecting string');
        }
        queryObject.prevId = params.prevId;
    }
    if (params.limit) {
        if (!_.isNumber(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        queryObject.limit = params.limit;
    }
    if (params.allTokens) {
        if (!_.isBoolean(params.allTokens)) {
            throw new Error('invalid allTokens argument, expecting boolean');
        }
        queryObject.allTokens = params.allTokens;
    }
    var self = this;
    return this.bitgo.get(this.baseCoin.url('/wallet'))
        .query(queryObject)
        .result()
        .then(function (body) {
        body.wallets = body.wallets.map(function (w) {
            return new self.coinWallet(self.bitgo, self.baseCoin, w);
        });
        return body;
    })
        .nodeify(callback);
};
/**
* add
* Add a new wallet (advanced mode).
* This allows you to manually submit the keys, type, m and n of the wallet
* Parameters include:
*    "label": label of the wallet to be shown in UI
*    "m": number of keys required to unlock wallet (2)
*    "n": number of keys available on the wallet (3)
*    "keys": array of keychain ids
*/
Wallets.prototype.add = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['label', 'enterprise', 'type'], callback);
    // no need to pass keys for (single) custodial wallets
    if (params.type !== 'custodial') {
        if (Array.isArray(params.keys) === false || !_.isNumber(params.m) || !_.isNumber(params.n)) {
            throw new Error('invalid argument');
        }
        // TODO: support more types of multisig
        if (!this.baseCoin.isValidMofNSetup(params)) {
            throw new Error('unsupported multi-sig type');
        }
    }
    if (params.tags && Array.isArray(params.tags) === false) {
        throw new Error('invalid argument for tags - array expected');
    }
    if (params.clientFlags && Array.isArray(params.clientFlags) === false) {
        throw new Error('invalid argument for clientFlags - array expected');
    }
    if (params.isCold && !_.isBoolean(params.isCold)) {
        throw new Error('invalid argument for isCold - boolean expected');
    }
    if (params.isCustodial && !_.isBoolean(params.isCustodial)) {
        throw new Error('invalid argument for isCustodial - boolean expected');
    }
    var self = this;
    var walletParams = _.pick(params, ['label', 'm', 'n', 'keys', 'enterprise', 'isCold', 'isCustodial', 'tags', 'clientFlags', 'type']);
    // Additional params needed for xrp
    if (params.rootPub) {
        walletParams.rootPub = params.rootPub;
    }
    // In XLM this private key is used only for wallet creation purposes, once the wallet is initialized then we
    // update its weight to 0 making it an invalid key.
    // https://www.stellar.org/developers/guides/concepts/multi-sig.html#additional-signing-keys
    if (params.rootPrivateKey) {
        walletParams.rootPrivateKey = params.rootPrivateKey;
    }
    if (params.initializationTxs) {
        walletParams.initializationTxs = params.initializationTxs;
    }
    if (params.disableTransactionNotifications) {
        walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
    }
    return self.bitgo.post(self.baseCoin.url('/wallet')).send(walletParams).result()
        .then(function (newWallet) {
        return {
            wallet: new self.coinWallet(self.bitgo, self.baseCoin, newWallet)
        };
    })
        .nodeify(callback);
};
/**
 * Generate a new wallet
 * 1. Creates the user keychain locally on the client, and encrypts it with the provided passphrase
 * 2. If no pub was provided, creates the backup keychain locally on the client, and encrypts it with the provided passphrase
 * 3. Uploads the encrypted user and backup keychains to BitGo
 * 4. Creates the BitGo key on the service
 * 5. Creates the wallet on BitGo with the 3 public keys above
 * @param params
 * @param params.label
 * @param params.passphrase
 * @param params.userKey User xpub
 * @param params.backupXpub Backup xpub
 * @param params.backupXpubProvider
 * @param params.enterprise
 * @param params.disableTransactionNotifications
 * @param params.passcodeEncryptionCode
 * @param params.coldDerivationSeed
 * @param params.gasPrice
 * @param params.disableKRSEmail
 * @param callback
 * @returns {*}
 */
Wallets.prototype.generateWallet = function (params, callback) {
    return co(function () {
        var self, label, walletParams, hasBackupXpub, hasBackupXpubProvider, derivationPath, passphrase, canEncrypt, isCold, reqId, userKeychainPromise, backupKeychainPromise, _a, userKeychain, backupKeychain, bitgoKeychain, keychains, newWallet, result;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    params = params || {};
                    common.validateParams(params, ['label'], ['passphrase', 'userKey', 'backupXpub'], callback);
                    self = this;
                    label = params.label;
                    walletParams = {
                        label: label,
                        m: 2,
                        n: 3
                    };
                    hasBackupXpub = !!params.backupXpub;
                    hasBackupXpubProvider = !!params.backupXpubProvider;
                    if (hasBackupXpub && hasBackupXpubProvider) {
                        throw new Error('Cannot provide more than one backupXpub or backupXpubProvider flag');
                    }
                    if (!_.isUndefined(params.passcodeEncryptionCode)) {
                        if (!_.isString(params.passcodeEncryptionCode)) {
                            throw new Error('passcodeEncryptionCode must be a string');
                        }
                    }
                    if (!_.isUndefined(params.enterprise)) {
                        if (!_.isString(params.enterprise)) {
                            throw new Error('invalid enterprise argument, expecting string');
                        }
                        walletParams.enterprise = params.enterprise;
                    }
                    if (!_.isUndefined(params.disableTransactionNotifications)) {
                        if (!_.isBoolean(params.disableTransactionNotifications)) {
                            throw new Error('invalid disableTransactionNotifications argument, expecting boolean');
                        }
                        walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
                    }
                    if (!_.isUndefined(params.gasPrice)) {
                        if (!_.isNumber(params.gasPrice)) {
                            throw new Error('invalid gas price argument, expecting number');
                        }
                        walletParams.gasPrice = params.gasPrice;
                    }
                    if (!_.isUndefined(params.disableKRSEmail)) {
                        if (!_.isBoolean(params.disableKRSEmail)) {
                            throw new Error('invalid disableKRSEmail argument, expecting boolean');
                        }
                    }
                    // Ensure each krsSpecific param is either a string, boolean, or number
                    if (!_.isUndefined(params.krsSpecific)) {
                        Object.keys(params.krsSpecific).forEach(function (key) {
                            var val = params.krsSpecific[key];
                            if (!_.isBoolean(val) && !_.isString(val) && !_.isNumber(val)) {
                                throw new Error('krsSpecific object contains illegal values. values must be strings, booleans, or numbers');
                            }
                        });
                    }
                    derivationPath = undefined;
                    passphrase = params.passphrase;
                    canEncrypt = (!!passphrase && typeof passphrase === 'string');
                    isCold = (!canEncrypt || !!params.userKey);
                    reqId = util.createRequestId();
                    userKeychainPromise = co(function () {
                        var userKeychainParams, userKeychain, derivation, newUserKeychain;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    // User provided user key
                                    if (params.userKey) {
                                        userKeychain = { pub: params.userKey };
                                        userKeychainParams = userKeychain;
                                        if (params.coldDerivationSeed) {
                                            derivation = self.baseCoin.deriveKeyWithSeed({ key: params.userKey, seed: params.coldDerivationSeed });
                                            derivationPath = derivation.derivationPath;
                                            userKeychain.pub = derivation.key;
                                        }
                                    }
                                    else {
                                        if (!canEncrypt) {
                                            throw new Error('cannot generate user keypair without passphrase');
                                        }
                                        // Create the user key.
                                        userKeychain = self.baseCoin.keychains().create();
                                        userKeychain.encryptedPrv = self.bitgo.encrypt({ password: passphrase, input: userKeychain.prv });
                                        userKeychainParams = {
                                            pub: userKeychain.pub,
                                            encryptedPrv: userKeychain.encryptedPrv,
                                            originalPasscodeEncryptionCode: params.passcodeEncryptionCode
                                        };
                                    }
                                    userKeychainParams.reqId = reqId;
                                    return [4 /*yield*/, self.baseCoin.keychains().add(userKeychainParams)];
                                case 1:
                                    newUserKeychain = _a.sent();
                                    return [2 /*return*/, _.extend({}, newUserKeychain, userKeychain)];
                            }
                        });
                    })();
                    backupKeychainPromise = Promise.try(function () {
                        if (params.backupXpubProvider || self.baseCoin instanceof RmgCoin) {
                            // If requested, use a KRS or backup key provider
                            return self.baseCoin.keychains().createBackup({
                                provider: params.backupXpubProvider || 'defaultRMGBackupProvider',
                                disableKRSEmail: params.disableKRSEmail,
                                krsSpecific: params.krsSpecific,
                                type: self.baseCoin.getChain(),
                                reqId: reqId
                            });
                        }
                        // User provided backup xpub
                        if (params.backupXpub) {
                            // user provided backup ethereum address
                            return self.baseCoin.keychains().add({ pub: params.backupXpub, source: 'backup', reqId: reqId });
                        }
                        else {
                            if (!canEncrypt) {
                                throw new Error('cannot generate backup keypair without passphrase');
                            }
                            // No provided backup xpub or address, so default to creating one here
                            return self.baseCoin.keychains().createBackup({ reqId: reqId });
                        }
                    });
                    return [4 /*yield*/, Promise.props({
                            userKeychain: userKeychainPromise,
                            backupKeychain: backupKeychainPromise,
                            bitgoKeychain: self.baseCoin.keychains().createBitGo({ enterprise: params.enterprise, reqId: reqId })
                        })];
                case 1:
                    _a = _b.sent(), userKeychain = _a.userKeychain, backupKeychain = _a.backupKeychain, bitgoKeychain = _a.bitgoKeychain;
                    walletParams.keys = [
                        userKeychain.id,
                        backupKeychain.id,
                        bitgoKeychain.id
                    ];
                    walletParams.isCold = isCold;
                    if (_.isString(userKeychain.prv)) {
                        walletParams.keySignatures = {
                            backup: self.baseCoin.signMessage(userKeychain, backupKeychain.pub).toString('hex'),
                            bitgo: self.baseCoin.signMessage(userKeychain, bitgoKeychain.pub).toString('hex')
                        };
                    }
                    if (_.includes(['xrp', 'xlm'], self.baseCoin.getFamily()) && !_.isUndefined(params.rootPrivateKey)) {
                        walletParams.rootPrivateKey = params.rootPrivateKey;
                    }
                    keychains = {
                        userKeychain: userKeychain,
                        backupKeychain: backupKeychain,
                        bitgoKeychain: bitgoKeychain
                    };
                    return [4 /*yield*/, self.baseCoin.supplementGenerateWallet(walletParams, keychains)];
                case 2:
                    walletParams = _b.sent();
                    self.bitgo._reqId = reqId;
                    return [4 /*yield*/, self.bitgo.post(self.baseCoin.url('/wallet')).send(walletParams).result()];
                case 3:
                    newWallet = _b.sent();
                    result = {
                        wallet: new self.coinWallet(self.bitgo, self.baseCoin, newWallet),
                        userKeychain: userKeychain,
                        backupKeychain: backupKeychain,
                        bitgoKeychain: bitgoKeychain
                    };
                    if (!_.isUndefined(backupKeychain.prv)) {
                        result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
                    }
                    if (!_.isUndefined(derivationPath)) {
                        userKeychain.derivationPath = derivationPath;
                    }
                    return [2 /*return*/, result];
            }
        });
    }).call(this).asCallback(callback);
};
//
// listShares
// List the user's wallet shares
//
Wallets.prototype.listShares = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.baseCoin.url('/walletshare'))
        .result()
        .nodeify(callback);
};
//
// getShare
// Gets a wallet share information, including the encrypted sharing keychain. requires unlock if keychain is present.
// Params:
//    walletShareId - the wallet share to get information on
//
Wallets.prototype.getShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletShareId'], [], callback);
    return this.bitgo.get(this.baseCoin.url('/walletshare/' + params.walletShareId))
        .result()
        .nodeify(callback);
};
//
// updateShare
// updates a wallet share
// Params:
//    walletShareId - the wallet share to update
//    state - the new state of the wallet share
//
Wallets.prototype.updateShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletShareId'], [], callback);
    return this.bitgo.post(this.baseCoin.url('/walletshare/' + params.walletShareId))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// resendShareInvite
// Resends a wallet share invitation email
// Params:
//    walletShareId - the wallet share whose invitiation should be resent
//
Wallets.prototype.resendShareInvite = function (params, callback) {
    return co(function () {
        var urlParts;
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, ['walletShareId'], [], callback);
            urlParts = params.walletShareId + '/resendemail';
            return [2 /*return*/, this.bitgo.post(this.baseCoin.url('/walletshare/' + urlParts))
                    .result()];
        });
    }).call(this).asCallback(callback);
};
//
// cancelShare
// cancels a wallet share
// Params:
//    walletShareId - the wallet share to update
//
Wallets.prototype.cancelShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletShareId'], [], callback);
    return this.bitgo.del(this.baseCoin.url('/walletshare/' + params.walletShareId))
        .send()
        .result()
        .nodeify(callback);
};
//
// acceptShare
// Accepts a wallet share, adding the wallet to the user's list
// Needs a user's password to decrypt the shared key
// Params:
//    walletShareId - the wallet share to accept
//    userPassword - (required if more a keychain was shared) user's password to decrypt the shared wallet
//    newWalletPassphrase - new wallet passphrase for saving the shared wallet prv.
//                          If left blank and a wallet with more than view permissions was shared, then the userpassword is used.
//    overrideEncryptedPrv - set only if the prv was received out-of-band.
//
Wallets.prototype.acceptShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletShareId'], ['overrideEncryptedPrv', 'userPassword', 'newWalletPassphrase'], callback);
    var self = this;
    var encryptedPrv = params.overrideEncryptedPrv;
    return this.getShare({ walletShareId: params.walletShareId })
        .then(function (walletShare) {
        // Return right away if there is no keychain to decrypt, or if explicit encryptedPrv was provided
        if (!walletShare.keychain || !walletShare.keychain.encryptedPrv || encryptedPrv) {
            return walletShare;
        }
        // More than viewing was requested, so we need to process the wallet keys using the shared ecdh scheme
        if (!params.userPassword) {
            throw new Error('userPassword param must be provided to decrypt shared key');
        }
        return self.bitgo.getECDHSharingKeychain()
            .then(function (sharingKeychain) {
            if (!sharingKeychain.encryptedXprv) {
                throw new Error('encryptedXprv was not found on sharing keychain');
            }
            // Now we have the sharing keychain, we can work out the secret used for sharing the wallet with us
            sharingKeychain.prv = self.bitgo.decrypt({ password: params.userPassword, input: sharingKeychain.encryptedXprv });
            var rootExtKey = bitcoin.HDNode.fromBase58(sharingKeychain.prv);
            // Derive key by path (which is used between these 2 users only)
            var privKey = bitcoin.hdPath(rootExtKey).deriveKey(walletShare.keychain.path);
            var secret = self.bitgo.getECDHSecret({ eckey: privKey, otherPubKeyHex: walletShare.keychain.fromPubKey });
            // Yes! We got the secret successfully here, now decrypt the shared wallet prv
            var decryptedSharedWalletPrv = self.bitgo.decrypt({ password: secret, input: walletShare.keychain.encryptedPrv });
            // We will now re-encrypt the wallet with our own password
            var newWalletPassphrase = params.newWalletPassphrase || params.userPassword;
            encryptedPrv = self.bitgo.encrypt({ password: newWalletPassphrase, input: decryptedSharedWalletPrv });
            // Carry on to the next block where we will post the acceptance of the share with the encrypted prv
            return walletShare;
        });
    })
        .then(function () {
        var updateParams = {
            walletShareId: params.walletShareId,
            state: 'accepted'
        };
        if (encryptedPrv) {
            updateParams.encryptedPrv = encryptedPrv;
        }
        return self.updateShare(updateParams);
    })
        .nodeify(callback);
};
/**
 * Get a wallet by its ID
 * @param params
 * @param callback
 * @returns {*}
 */
Wallets.prototype.getWallet = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    var self = this;
    var query = {};
    if (params.allTokens) {
        if (!_.isBoolean(params.allTokens)) {
            throw new Error('invalid allTokens argument, expecting boolean');
        }
        query.allTokens = params.allTokens;
    }
    this.bitgo._reqId = params.reqId || util.createRequestId();
    return this.bitgo.get(this.baseCoin.url('/wallet/' + params.id))
        .query(query)
        .result()
        .then(function (wallet) {
        return new self.coinWallet(self.bitgo, self.baseCoin, wallet);
    })
        .nodeify(callback);
};
/**
 * Get a wallet by its address
 * @param params
 * @param callback
 * @returns {*}
 */
Wallets.prototype.getWalletByAddress = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address'], [], callback);
    var self = this;
    this.bitgo._reqId = params.reqId || util.createRequestId();
    return this.bitgo.get(this.baseCoin.url('/wallet/address/' + params.address))
        .result()
        .then(function (wallet) {
        return new self.coinWallet(self.bitgo, self.baseCoin, wallet);
    })
        .nodeify(callback);
};
/**
 * For any given supported coin, get total balances for all wallets of that
 * coin type on the account.
 * @param params
 * @param callback
 * @returns {*}
 */
Wallets.prototype.getTotalBalances = function (params, callback) {
    return co(function () {
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, [], [], callback);
            return [2 /*return*/, this.bitgo.get(this.baseCoin.url('/wallet/balances'))
                    .result()
                    .nodeify(callback)];
        });
    }).call(this).asCallback(callback);
};
module.exports = Wallets;
//# sourceMappingURL=wallets.js.map