"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var BaseCoin = require("../baseCoin");
var config = require('../../config');
var bitcoin = require('bitgo-utxo-lib');
var bitcoinMessage = require('bitcoinjs-message');
var Promise = require('bluebird');
var co = Promise.coroutine;
var prova = require('prova-lib');
var crypto = require('crypto');
var request = require('superagent');
var _ = require('lodash');
var RecoveryTool = require('../recovery');
var errors = require('../../errors');
var debug = require('debug')('bitgo:v2:utxo');
var _a = require('@bitgo/unspents'), Codes = _a.Codes, VirtualSizes = _a.VirtualSizes;
var AbstractUtxoCoin = /** @class */ (function (_super) {
    __extends(AbstractUtxoCoin, _super);
    function AbstractUtxoCoin(network) {
        var _this = _super.call(this) || this;
        if (!_.isObject(network)) {
            throw new Error('network must be an object');
        }
        _this._network = network;
        return _this;
    }
    Object.defineProperty(AbstractUtxoCoin.prototype, "network", {
        get: function () {
            return this._network;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractUtxoCoin, "validAddressTypes", {
        get: function () {
            var validAddressTypes = [];
            _.forEach(Object.keys(Codes.UnspentTypeTcomb.meta.map), function (addressType) {
                try {
                    Codes.forType(addressType);
                    validAddressTypes.push(addressType);
                }
                catch (e) {
                    // Do nothing. Codes.forType will throw if the address type has no chain codes, meaning it is invalid on the
                    // BitGo platform and should not be added to the validAddressTypes array.
                }
            });
            return validAddressTypes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    AbstractUtxoCoin.prototype.getBaseFactor = function () {
        return 1e8;
    };
    AbstractUtxoCoin.prototype.getCoinLibrary = function () {
        return bitcoin;
    };
    AbstractUtxoCoin.prototype.isValidAddress = function (address, forceAltScriptSupport) {
        if (forceAltScriptSupport === void 0) { forceAltScriptSupport = false; }
        var validVersions = [
            this.network.pubKeyHash,
            this.network.scriptHash
        ];
        if (this.altScriptHash && (forceAltScriptSupport || this.supportAltScriptDestination)) {
            validVersions.push(this.altScriptHash);
        }
        var addressDetails;
        try {
            addressDetails = this.getCoinLibrary().address.fromBase58Check(address);
        }
        catch (e) {
            if (!this.supportsP2wsh()) {
                return false;
            }
            try {
                addressDetails = bitcoin.address.fromBech32(address);
                return addressDetails.prefix === this.network.bech32;
            }
            catch (e) {
                return false;
            }
        }
        // the address version needs to be among the valid ones
        return validVersions.includes(addressDetails.version);
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    AbstractUtxoCoin.prototype.isValidPub = function (pub) {
        try {
            bitcoin.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    AbstractUtxoCoin.prototype.getLatestBlockHeight = function (reqId, callback) {
        return co(function () {
            var chainhead;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (reqId) {
                            this.bitgo._reqId = reqId;
                        }
                        return [4 /*yield*/, this.bitgo.get(this.url('/public/block/latest')).result()];
                    case 1:
                        chainhead = _a.sent();
                        return [2 /*return*/, chainhead.height];
                }
            });
        }).call(this).asCallback(callback);
    };
    AbstractUtxoCoin.prototype.postProcessPrebuild = function (prebuild, callback) {
        return co(function () {
            var _a, transaction;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!_.isUndefined(prebuild.blockHeight)) return [3 /*break*/, 2];
                        _a = prebuild;
                        return [4 /*yield*/, this.getLatestBlockHeight()];
                    case 1:
                        _a.blockHeight = _b.sent();
                        _b.label = 2;
                    case 2:
                        transaction = bitcoin.Transaction.fromHex(prebuild.txHex, this.network);
                        transaction.locktime = prebuild.blockHeight + 1;
                        return [2 /*return*/, _.extend({}, prebuild, { txHex: transaction.toHex() })];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Find outputs that are within expected outputs but not within actual outputs, including duplicates
     * @param expectedOutputs
     * @param actualOutputs
     * @returns {Array}
     */
    AbstractUtxoCoin.findMissingOutputs = function (expectedOutputs, actualOutputs) {
        var keyFunc = function (_a) {
            var address = _a.address, amount = _a.amount;
            return address + ":" + Number(amount);
        };
        var groupedOutputs = _.groupBy(expectedOutputs, keyFunc);
        actualOutputs.forEach(function (output) {
            var group = groupedOutputs[keyFunc(output)];
            if (group) {
                group.pop();
            }
        });
        return _.flatten(_.values(groupedOutputs));
    };
    /**
     * Determine an address' type based on its witness and redeem script presence
     * @param addressDetails
     */
    AbstractUtxoCoin.inferAddressType = function (addressDetails) {
        if (_.isObject(addressDetails.coinSpecific)) {
            if (_.isString(addressDetails.coinSpecific.redeemScript) && _.isString(addressDetails.coinSpecific.witnessScript)) {
                return Codes.UnspentTypeTcomb('p2shP2wsh');
            }
            else if (_.isString(addressDetails.coinSpecific.redeemScript)) {
                return Codes.UnspentTypeTcomb('p2sh');
            }
            else if (_.isString(addressDetails.coinSpecific.witnessScript)) {
                return Codes.UnspentTypeTcomb('p2wsh');
            }
        }
        return null;
    };
    /**
     * Extract and fill transaction details such as internal/change spend, external spend (explicit vs. implicit), etc.
     * @param txParams
     * @param txPrebuild
     * @param wallet
     * @param verification
     * @param callback
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.parseTransaction = function (_a, callback) {
        var txParams = _a.txParams, txPrebuild = _a.txPrebuild, wallet = _a.wallet, _b = _a.verification, verification = _b === void 0 ? {} : _b, reqId = _a.reqId;
        return co(function () {
            var disableNetworking, keychains, keychainArray, keySignatures, explanation, allOutputs, expectedOutputs, missingOutputs, allOutputDetails, changeOutputs, implicitOutputs, explicitOutputs, explicitExternalOutputs, explicitExternalSpendAmount, implicitExternalOutputs, implicitExternalSpendAmount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isUndefined(verification.disableNetworking) && !_.isBoolean(verification.disableNetworking)) {
                            throw new Error('verification.disableNetworking must be a boolean');
                        }
                        disableNetworking = !!verification.disableNetworking;
                        keychains = verification.keychains;
                        if (!(!keychains && disableNetworking)) return [3 /*break*/, 1];
                        throw new Error('cannot fetch keychains without networking');
                    case 1:
                        if (!!keychains) return [3 /*break*/, 3];
                        return [4 /*yield*/, Promise.props({
                                user: this.keychains().get({ id: wallet._wallet.keys[0], reqId: reqId }),
                                backup: this.keychains().get({ id: wallet._wallet.keys[1], reqId: reqId }),
                                bitgo: this.keychains().get({ id: wallet._wallet.keys[2], reqId: reqId })
                            })];
                    case 2:
                        keychains = _a.sent();
                        _a.label = 3;
                    case 3:
                        keychainArray = [keychains.user, keychains.backup, keychains.bitgo];
                        keySignatures = _.get(wallet, '_wallet.keySignatures');
                        explanation = this.explainTransaction({
                            txHex: txPrebuild.txHex,
                            txInfo: txPrebuild.txInfo,
                            keychains: keychains
                        });
                        allOutputs = explanation.outputs.concat(explanation.changeOutputs);
                        expectedOutputs = _.get(txParams, 'recipients', []);
                        missingOutputs = this.constructor.findMissingOutputs(expectedOutputs, allOutputs);
                        return [4 /*yield*/, Promise.map(allOutputs, co(function (currentOutput) {
                                var currentAddress, addressDetailsPrebuild, addressDetailsVerification, addressDetails, addressType, e_1, walletAddressNotFound, unexpectedAddress;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            currentAddress = currentOutput.address;
                                            addressDetailsPrebuild = _.get(txPrebuild, "txInfo.walletAddressDetails." + currentAddress, {});
                                            addressDetailsVerification = _.get(verification, "addresses." + currentAddress, {});
                                            debug('Parsing address details for %s', currentAddress);
                                            _a.label = 1;
                                        case 1:
                                            _a.trys.push([1, 4, , 5]);
                                            addressDetails = _.extend({}, addressDetailsPrebuild, addressDetailsVerification);
                                            debug('Locally available address %s details: %O', currentAddress, addressDetails);
                                            if (!(_.isEmpty(addressDetails) && !disableNetworking)) return [3 /*break*/, 3];
                                            return [4 /*yield*/, wallet.getAddress({ address: currentAddress, reqId: reqId })];
                                        case 2:
                                            addressDetails = _a.sent();
                                            debug('Downloaded address %s details: %O', currentAddress, addressDetails);
                                            _a.label = 3;
                                        case 3:
                                            addressType = this.constructor.inferAddressType(addressDetails);
                                            this.verifyAddress(_.extend({ addressType: addressType }, addressDetails, {
                                                keychains: keychainArray,
                                                address: currentAddress
                                            }));
                                            debug('Address %s verification passed', currentAddress);
                                            // verify address succeeded without throwing, so the address was
                                            // correctly rederived from the wallet keychains, making it not external
                                            return [2 /*return*/, _.extend({}, currentOutput, addressDetails, { external: false })];
                                        case 4:
                                            e_1 = _a.sent();
                                            // verify address threw an exception
                                            debug('Address %s verification threw an error:', currentAddress, e_1);
                                            walletAddressNotFound = e_1.message.includes('wallet address not found');
                                            unexpectedAddress = (e_1 instanceof errors.UnexpectedAddressError);
                                            if (walletAddressNotFound || unexpectedAddress) {
                                                if (unexpectedAddress && !walletAddressNotFound) {
                                                    /**
                                                     * this could be a migrated SafeHD BCH wallet, and the transaction we are currently
                                                     * parsing is trying to spend change back to the v1 wallet base address.
                                                     * It does this since we don't allow new address creation for these wallets,
                                                     * and instead return the base address from the v1 wallet when a new address is requested.
                                                     * If this new address is requested for the purposes of spending change back to the wallet,
                                                     * the change will go to the v1 wallet base address. This address *is* on the wallet,
                                                     * but it will still cause an error to be thrown by verifyAddress, since the derivation path
                                                     * used for this address is non-standard. (I have seen these addresses derived using paths m/0/0 and m/101,
                                                     * whereas the v2 addresses are derived using path  m/0/0/${chain}/${index}).
                                                     *
                                                     * This means we need to check for this case explicitly in this catch block, and classify
                                                     * these types of outputs as internal instead of external. Failing to do so would cause the
                                                     * transaction's implicit external outputs (ie, outputs which go to addresses not specified in
                                                     * the recipients array) to add up to more than the 150 basis point limit which we enforce on
                                                     * pay-as-you-go outputs (which should be the only implicit external outputs on our transactions).
                                                     *
                                                     * The 150 basis point limit for implicit external sends is enforced in verifyTransaction,
                                                     * which calls this function to get information on the total external/internal spend amounts
                                                     * for a transaction. The idea here is to protect from the transaction being maliciously modified
                                                     * to add more implicit external spends (eg, to an attacker-controlled wallet).
                                                     *
                                                     * See verifyTransaction for more information on how transaction prebuilds are verified before signing.
                                                     */
                                                    if (_.isString(wallet._wallet.migratedFrom) && wallet._wallet.migratedFrom === currentAddress) {
                                                        debug('found address %s which was migrated from v1 wallet, address is not external', currentAddress);
                                                        return [2 /*return*/, _.extend({}, currentOutput, { external: false })];
                                                    }
                                                    debug('Address %s was found on wallet but could not be reconstructed', currentAddress);
                                                }
                                                // the address was found, but not on the wallet, which simply means it's external
                                                debug('Address %s presumed external', currentAddress);
                                                return [2 /*return*/, _.extend({}, currentOutput, { external: true })];
                                            }
                                            else if (e_1 instanceof errors.InvalidAddressDerivationPropertyError && currentAddress === txParams.changeAddress) {
                                                // expect to see this error when passing in a custom changeAddress with no chain or index
                                                return [2 /*return*/, _.extend({}, currentOutput, { external: false })];
                                            }
                                            debug('Address %s verification failed', currentAddress);
                                            /**
                                             * It might be a completely invalid address or a bad validation attempt or something else completely, in
                                             * which case we do not proceed and rather rethrow the error, which is safer than assuming that the address
                                             * validation failed simply because it's external to the wallet.
                                             */
                                            throw e_1;
                                        case 5: return [2 /*return*/];
                                    }
                                });
                            }).bind(this))];
                    case 4:
                        allOutputDetails = _a.sent();
                        changeOutputs = _.filter(allOutputDetails, { external: false });
                        implicitOutputs = this.constructor.findMissingOutputs(allOutputDetails, expectedOutputs);
                        explicitOutputs = this.constructor.findMissingOutputs(allOutputDetails, implicitOutputs);
                        explicitExternalOutputs = _.filter(explicitOutputs, { external: true });
                        explicitExternalSpendAmount = _.sumBy(explicitExternalOutputs, 'amount');
                        implicitExternalOutputs = _.filter(implicitOutputs, { external: true });
                        implicitExternalSpendAmount = _.sumBy(implicitExternalOutputs, 'amount');
                        return [2 /*return*/, {
                                keychains: keychains,
                                keySignatures: keySignatures,
                                outputs: allOutputDetails,
                                missingOutputs: missingOutputs,
                                explicitExternalOutputs: explicitExternalOutputs,
                                implicitExternalOutputs: implicitExternalOutputs,
                                changeOutputs: changeOutputs,
                                explicitExternalSpendAmount: explicitExternalSpendAmount,
                                implicitExternalSpendAmount: implicitExternalSpendAmount
                            }];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     * @param txParams params object passed to send
     * @param txPrebuild prebuild object returned by server
     * @param txPrebuild.txHex prebuilt transaction's txHex form
     * @param wallet Wallet object to obtain keys to verify against
     * @param verification Object specifying some verification parameters
     * @param verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param verification.keychains Pass keychains manually rather than fetching them by id
     * @param verification.addresses Address details to pass in for out-of-band verification
     * @param callback
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.verifyTransaction = function (_a, callback) {
        var txParams = _a.txParams, txPrebuild = _a.txPrebuild, wallet = _a.wallet, _b = _a.verification, verification = _b === void 0 ? {} : _b, reqId = _a.reqId;
        return co(function () {
            var disableNetworking, parsedTransaction, keychains, keySignatures, userPub, userKey, userPrv, encryptedPrv, errorMessage, userPrivateKey, backupPubSignature, bitgoPubSignature, signingAddress, isValidBackupSignature, isValidBitgoSignature, missingOutputs, intendedExternalSpend, payAsYouGoLimit, nonChangeAmount, allOutputs, transaction, transactionCache, inputs, inputAmount, outputAmount, fee;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        disableNetworking = !!verification.disableNetworking;
                        return [4 /*yield*/, this.parseTransaction({ txParams: txParams, txPrebuild: txPrebuild, wallet: wallet, verification: verification, reqId: reqId })];
                    case 1:
                        parsedTransaction = _a.sent();
                        keychains = parsedTransaction.keychains;
                        keySignatures = parsedTransaction.keySignatures;
                        if (!_.isEmpty(keySignatures)) {
                            userPub = keychains.user.pub;
                            userKey = bitcoin.HDNode.fromBase58(userPub);
                            userPrv = keychains.user.prv;
                            if (_.isEmpty(userPrv)) {
                                encryptedPrv = keychains.user.encryptedPrv;
                                if (!_.isEmpty(encryptedPrv)) {
                                    // if the decryption fails, it will throw an error
                                    userPrv = this.bitgo.decrypt({
                                        input: encryptedPrv,
                                        password: txParams.walletPassphrase
                                    });
                                }
                            }
                            if (_.isEmpty(userPrv)) {
                                errorMessage = 'user private key unavailable for verification';
                                if (disableNetworking) {
                                    console.log(errorMessage);
                                }
                                else {
                                    throw new Error(errorMessage);
                                }
                            }
                            else {
                                userPrivateKey = bitcoin.HDNode.fromBase58(userPrv);
                                if (userPrivateKey.toBase58() === userPrivateKey.neutered().toBase58()) {
                                    throw new Error('user private key is only public');
                                }
                                if (userPrivateKey.neutered().toBase58() !== userPub) {
                                    throw new Error('user private key does not match public key');
                                }
                            }
                            backupPubSignature = keySignatures.backupPub;
                            bitgoPubSignature = keySignatures.bitgoPub;
                            signingAddress = userKey.keyPair.getAddress();
                            isValidBackupSignature = bitcoinMessage.verify(keychains.backup.pub, signingAddress, Buffer.from(backupPubSignature, 'hex'));
                            isValidBitgoSignature = bitcoinMessage.verify(keychains.bitgo.pub, signingAddress, Buffer.from(bitgoPubSignature, 'hex'));
                            if (!isValidBackupSignature || !isValidBitgoSignature) {
                                throw new Error('secondary public key signatures invalid');
                            }
                        }
                        else if (!disableNetworking) {
                            // these keys were obtained online and their signatures were not verified
                            // this could be dangerous
                            console.log('unsigned keys obtained online are being used for address verification');
                        }
                        missingOutputs = parsedTransaction.missingOutputs;
                        if (missingOutputs.length !== 0) {
                            // there are some outputs in the recipients list that have not made it into the actual transaction
                            throw new Error('expected outputs missing in transaction prebuild');
                        }
                        intendedExternalSpend = parsedTransaction.explicitExternalSpendAmount;
                        payAsYouGoLimit = intendedExternalSpend * 0.015;
                        nonChangeAmount = parsedTransaction.implicitExternalSpendAmount;
                        // the additional external outputs can only be BitGo's pay-as-you-go fee, but we cannot verify the wallet address
                        if (nonChangeAmount > payAsYouGoLimit) {
                            // there are some addresses that are outside the scope of intended recipients that are not change addresses
                            throw new Error('prebuild attempts to spend to unintended external recipients');
                        }
                        allOutputs = parsedTransaction.outputs;
                        transaction = bitcoin.Transaction.fromHex(txPrebuild.txHex, this.network);
                        transactionCache = {};
                        return [4 /*yield*/, Promise.map(transaction.ins, co(function (currentInput) {
                                var transactionId, txHex, localTx, currentOutput, address, _a, _b, transactionDetails;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            transactionId = Buffer.from(currentInput.hash).reverse().toString('hex');
                                            txHex = _.get(txPrebuild, "txInfo.txHexes." + transactionId);
                                            if (!txHex) return [3 /*break*/, 1];
                                            localTx = bitcoin.Transaction.fromHex(txHex, this.network);
                                            if (localTx.getId() !== transactionId) {
                                                throw new Error('input transaction hex does not match id');
                                            }
                                            currentOutput = localTx.outs[currentInput.index];
                                            address = bitcoin.address.fromOutputScript(currentOutput.script, this.network);
                                            return [2 /*return*/, {
                                                    address: address,
                                                    value: currentOutput.value
                                                }];
                                        case 1:
                                            if (!!transactionCache[transactionId]) return [3 /*break*/, 3];
                                            if (disableNetworking) {
                                                throw new Error('attempting to retrieve transaction details externally with networking disabled');
                                            }
                                            if (reqId) {
                                                this.bitgo._reqId = reqId;
                                            }
                                            _a = transactionCache;
                                            _b = transactionId;
                                            return [4 /*yield*/, this.bitgo.get(this.url("/public/tx/" + transactionId)).result()];
                                        case 2:
                                            _a[_b] = _c.sent();
                                            _c.label = 3;
                                        case 3:
                                            transactionDetails = transactionCache[transactionId];
                                            return [2 /*return*/, transactionDetails.outputs[currentInput.index]];
                                    }
                                });
                            }).bind(this))];
                    case 2:
                        inputs = _a.sent();
                        inputAmount = _.sumBy(inputs, 'value');
                        outputAmount = _.sumBy(allOutputs, 'amount');
                        fee = inputAmount - outputAmount;
                        if (fee < 0) {
                            throw new Error("attempting to spend " + outputAmount + " satoshis, which exceeds the input amount (" + inputAmount + " satoshis) by " + -fee);
                        }
                        return [2 /*return*/, true];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param address The address string on the network
     * @param addressType
     * @param keychains Keychain objects with xpubs
     * @param coinSpecific Coin-specific details for the address such as a witness script
     * @param chain Derivation chain
     * @param index Derivation index
     */
    AbstractUtxoCoin.prototype.verifyAddress = function (_a) {
        var address = _a.address, addressType = _a.addressType, keychains = _a.keychains, coinSpecific = _a.coinSpecific, chain = _a.chain, index = _a.index;
        if (!this.isValidAddress(address)) {
            throw new errors.InvalidAddressError("invalid address: " + address);
        }
        if ((_.isUndefined(chain) && _.isUndefined(index)) || (!(_.isFinite(chain) && _.isFinite(index)))) {
            throw new errors.InvalidAddressDerivationPropertyError("address validation failure: invalid chain (" + chain + ") or index (" + index + ")");
        }
        if (!_.isObject(coinSpecific)) {
            throw new errors.InvalidAddressVerificationObjectPropertyError('address validation failure: coinSpecific field must be an object');
        }
        var expectedAddress = this.generateAddress({
            addressType: addressType,
            keychains: keychains,
            threshold: 2,
            chain: chain,
            index: index
        });
        if (expectedAddress.address !== address) {
            throw new errors.UnexpectedAddressError("address validation failure: expected " + expectedAddress.address + " but got " + address);
        }
    };
    /**
     * Indicates whether coin supports a block target
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.supportsBlockTarget = function () {
        return true;
    };
    /**
     * Indicates whether a coin supports wrapped segwit outputs
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.supportsP2shP2wsh = function () {
        return false;
    };
    /**
     * Indicates whether a coin supports native segwit outputs
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.supportsP2wsh = function () {
        return false;
    };
    /**
     * TODO(BG-11487): Remove addressType, segwit, and bech32 params in SDKv6
     * Generate an address for a wallet based on a set of configurations
     * @param addressType {string}   Deprecated
     * @param keychains   {[object]} Array of objects with xpubs
     * @param threshold   {number}   Minimum number of signatures
     * @param chain       {number}   Derivation chain (see https://github.com/BitGo/unspents/blob/master/src/codes.ts for
     *                                                 the corresponding address type of a given chain code)
     * @param index       {number}   Derivation index
     * @param segwit      {boolean}  Deprecated
     * @param bech32      {boolean}  Deprecated
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript, redeemScript}}}
     */
    AbstractUtxoCoin.prototype.generateAddress = function (_a) {
        var addressType = _a.addressType, keychains = _a.keychains, threshold = _a.threshold, chain = _a.chain, index = _a.index, _b = _a.segwit, segwit = _b === void 0 ? false : _b, _c = _a.bech32, bech32 = _c === void 0 ? false : _c;
        var derivationChain = 0;
        if (_.isInteger(chain) && chain > 0) {
            derivationChain = chain;
        }
        if (_.isUndefined(addressType)) {
            addressType = Codes.UnspentTypeTcomb('p2sh');
            if (_.isBoolean(segwit) && segwit) {
                addressType = Codes.UnspentTypeTcomb('p2shP2wsh');
            }
            if (_.isBoolean(bech32) && bech32) {
                addressType = Codes.UnspentTypeTcomb('p2wsh');
            }
        }
        switch (addressType) {
            case Codes.UnspentTypeTcomb('p2sh'):
                if (!Codes.isP2sh(derivationChain)) {
                    throw new errors.AddressTypeChainMismatchError(addressType, derivationChain);
                }
                break;
            case Codes.UnspentTypeTcomb('p2shP2wsh'):
                if (!this.supportsP2shP2wsh()) {
                    throw new errors.P2shP2wshUnsupportedError();
                }
                if (!Codes.isP2shP2wsh(derivationChain)) {
                    throw new errors.AddressTypeChainMismatchError(addressType, derivationChain);
                }
                break;
            case Codes.UnspentTypeTcomb('p2wsh'):
                if (!this.supportsP2wsh()) {
                    throw new errors.P2wshUnsupportedError();
                }
                if (!Codes.isP2wsh(derivationChain)) {
                    throw new errors.AddressTypeChainMismatchError(addressType, derivationChain);
                }
                break;
            default:
                throw new errors.UnsupportedAddressTypeError();
        }
        var signatureThreshold = 2;
        if (_.isInteger(threshold)) {
            signatureThreshold = threshold;
            if (signatureThreshold <= 0) {
                throw new Error('threshold has to be positive');
            }
            if (signatureThreshold > keychains.length) {
                throw new Error('threshold cannot exceed number of keys');
            }
        }
        var derivationIndex = 0;
        if (_.isInteger(index) && index > 0) {
            derivationIndex = index;
        }
        var path = 'm/0/0/' + derivationChain + '/' + derivationIndex;
        var hdNodes = keychains.map(function (_a) {
            var pub = _a.pub;
            return prova.HDNode.fromBase58(pub);
        });
        var derivedKeys = hdNodes.map(function (hdNode) { return hdNode.hdPath().deriveKey(path).getPublicKeyBuffer(); });
        var addressDetails = {
            chain: derivationChain,
            index: derivationIndex,
            coin: this.getChain(),
            coinSpecific: {},
            addressType: addressType
        };
        var _d = this.createMultiSigAddress(addressType, signatureThreshold, derivedKeys), outputScript = _d.outputScript, redeemScript = _d.redeemScript, witnessScript = _d.witnessScript, address = _d.address;
        addressDetails.coinSpecific.outputScript = outputScript.toString('hex');
        addressDetails.coinSpecific.redeemScript = redeemScript && redeemScript.toString('hex');
        addressDetails.coinSpecific.witnessScript = witnessScript && witnessScript.toString('hex');
        addressDetails.address = address;
        return addressDetails;
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @param params.isLastSignature Ture if txb.build() should be called and not buildIncomplete()
     * @returns {{txHex}}
     */
    AbstractUtxoCoin.prototype.signTransaction = function (params) {
        var _this = this;
        var txPrebuild = params.txPrebuild;
        var userPrv = params.prv;
        if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
            if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
            }
            throw new Error('missing txPrebuild parameter');
        }
        var transaction = bitcoin.Transaction.fromHex(txPrebuild.txHex, this.network);
        if (transaction.ins.length !== txPrebuild.txInfo.unspents.length) {
            throw new Error('length of unspents array should equal to the number of transaction inputs');
        }
        var isLastSignature = false;
        if (_.isBoolean(params.isLastSignature)) {
            // if build is called instead of buildIncomplete, no signature placeholders are left in the sig script
            isLastSignature = params.isLastSignature;
        }
        if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
            if (!_.isUndefined(userPrv) && !_.isString(userPrv)) {
                throw new Error("prv must be a string, got type " + typeof userPrv);
            }
            throw new Error('missing prv parameter to sign transaction');
        }
        var keychain = bitcoin.HDNode.fromBase58(userPrv);
        var hdPath = bitcoin.hdPath(keychain);
        var txb = bitcoin.TransactionBuilder.fromTransaction(transaction, this.network);
        this.prepareTransactionBuilder(txb);
        var getSignatureContext = function (txPrebuild, index) {
            var currentUnspent = txPrebuild.txInfo.unspents[index];
            return {
                inputIndex: index,
                unspent: currentUnspent,
                path: 'm/0/0/' + currentUnspent.chain + '/' + currentUnspent.index,
                isP2wsh: !currentUnspent.redeemScript,
                isBitGoTaintedUnspent: _this.isBitGoTaintedUnspent(currentUnspent),
                error: undefined
            };
        };
        var signatureIssues = [];
        // Sign inputs
        for (var index = 0; index < transaction.ins.length; ++index) {
            debug('Signing input %d of %d', index + 1, transaction.ins.length);
            var signatureContext = getSignatureContext(txPrebuild, index);
            if (signatureContext.isBitGoTaintedUnspent) {
                debug('Skipping input %d of %d (unspent from replay protection address which is platform signed only)', index + 1, transaction.ins.length);
                continue;
            }
            var privKey = hdPath.deriveKey(signatureContext.path);
            privKey.network = this.network;
            debug('Input details: %O', signatureContext);
            var sigHashType = this.defaultSigHashType;
            try {
                if (signatureContext.isP2wsh) {
                    debug('Signing p2wsh input');
                    var witnessScript = Buffer.from(signatureContext.unspent.witnessScript, 'hex');
                    var witnessScriptHash = bitcoin.crypto.sha256(witnessScript);
                    var prevOutScript = bitcoin.script.witnessScriptHash.output.encode(witnessScriptHash);
                    txb.sign(index, privKey, prevOutScript, sigHashType, signatureContext.unspent.value, witnessScript);
                }
                else {
                    var subscript = new Buffer(signatureContext.unspent.redeemScript, 'hex');
                    var isP2shP2wsh = !!signatureContext.unspent.witnessScript;
                    if (isP2shP2wsh) {
                        debug('Signing p2shP2wsh input');
                        var witnessScript = Buffer.from(signatureContext.unspent.witnessScript, 'hex');
                        txb.sign(index, privKey, subscript, sigHashType, signatureContext.unspent.value, witnessScript);
                    }
                    else {
                        debug('Signing p2sh input');
                        txb.sign(index, privKey, subscript, sigHashType, signatureContext.unspent.value);
                    }
                }
            }
            catch (e) {
                debug('Failed to sign input:', e);
                signatureContext.error = e;
                signatureIssues.push(signatureContext);
                continue;
            }
        }
        if (isLastSignature) {
            transaction = txb.build();
        }
        else {
            transaction = txb.buildIncomplete();
        }
        // Verify input signatures
        for (var index = 0; index < transaction.ins.length; ++index) {
            debug('Verifying input signature %d of %d', index + 1, transaction.ins.length);
            var signatureContext = getSignatureContext(txPrebuild, index);
            if (signatureContext.isBitGoTaintedUnspent) {
                debug('Skipping input signature %d of %d (unspent from replay protection address which is platform signed only)', index + 1, transaction.ins.length);
                continue;
            }
            if (signatureContext.isP2wsh) {
                transaction.setInputScript(index, Buffer.alloc(0));
            }
            var isValidSignature = this.verifySignature(transaction, index, signatureContext.unspent.value);
            if (!isValidSignature) {
                debug('Invalid signature');
                signatureContext.error = new Error('invalid signature');
                signatureIssues.push(signatureContext);
            }
        }
        if (signatureIssues.length > 0) {
            var failedIndices = signatureIssues.map(function (currentIssue) { return currentIssue.inputIndex; });
            var error = new Error("Failed to sign inputs at indices " + failedIndices.join(', '));
            error.code = 'input_signature_failure';
            error.signingErrors = signatureIssues;
            throw error;
        }
        return {
            txHex: transaction.toBuffer().toString('hex')
        };
    };
    /**
     * Always false for coins other than BCH and TBCH.
     * @param unspent
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.isBitGoTaintedUnspent = function (unspent) {
        return false;
    };
    /**
     * Modify the transaction builder to comply with the specific coin's requirements such as version and branch id
     * @param txBuilder
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.prepareTransactionBuilder = function (txBuilder) {
        return txBuilder;
    };
    Object.defineProperty(AbstractUtxoCoin.prototype, "defaultSigHashType", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return bitcoin.Transaction.SIGHASH_ALL;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Parse a transaction's signature script to obtain public keys, signatures, the sig script, and other properties
     * @param transaction
     * @param inputIndex
     * @returns { isSegwitInput: boolean, inputClassification: string, signatures: [Buffer], publicKeys: [Buffer], pubScript: Buffer }
     */
    AbstractUtxoCoin.prototype.parseSignatureScript = function (transaction, inputIndex) {
        var currentInput = transaction.ins[inputIndex];
        var isSegwitInput = currentInput.witness.length > 0;
        var isNativeSegwitInput = currentInput.script.length === 0;
        var decompiledSigScript, inputClassification;
        if (isSegwitInput) {
            // The decompiledSigScript is the script containing the signatures, public keys, and the script that was committed
            // to (pubScript). If this is a segwit input the decompiledSigScript is in the witness, regardless of whether it
            // is native or not. The inputClassification is determined based on whether or not the input is native to give an
            // accurate classification. Note that p2shP2wsh inputs will be classified as p2sh and not p2wsh.
            decompiledSigScript = currentInput.witness;
            if (isNativeSegwitInput) {
                inputClassification = bitcoin.script.classifyWitness(bitcoin.script.compile(decompiledSigScript), true);
            }
            else {
                inputClassification = bitcoin.script.classifyInput(currentInput.script, true);
            }
        }
        else {
            inputClassification = bitcoin.script.classifyInput(currentInput.script, true);
            decompiledSigScript = bitcoin.script.decompile(currentInput.script);
        }
        if (inputClassification === bitcoin.script.types.P2PKH) {
            var signature = decompiledSigScript[0], publicKey = decompiledSigScript[1];
            var publicKeys = [publicKey];
            var signatures = [signature];
            var pubScript = bitcoin.script.pubKeyHash.output.encode(bitcoin.crypto.hash160(publicKey));
            return { isSegwitInput: isSegwitInput, inputClassification: inputClassification, signatures: signatures, publicKeys: publicKeys, pubScript: pubScript };
        }
        else if (inputClassification === bitcoin.script.types.P2SH
            || inputClassification === bitcoin.script.types.P2WSH) {
            // Note the assumption here that if we have a p2sh or p2wsh input it will be multisig (appropriate because the
            // BitGo platform only supports multisig within these types of inputs). Signatures are all but the last entry in
            // the decompiledSigScript. The redeemScript/witnessScript (depending on which type of input this is) is the last
            // entry in the decompiledSigScript (denoted here as the pubScript). The public keys are the second through
            // antepenultimate entries in the decompiledPubScript. See below for a visual representation of the typical 2-of-3
            // multisig setup:
            //
            // decompiledSigScript = 0 <sig1> <sig2> <pubScript>
            // decompiledPubScript = 2 <pub1> <pub2> <pub3> 3 OP_CHECKMULTISIG
            var signatures = decompiledSigScript.slice(0, -1);
            var pubScript = _.last(decompiledSigScript);
            var decompiledPubScript = bitcoin.script.decompile(pubScript);
            var publicKeys = decompiledPubScript.slice(1, -2);
            // Op codes 81 through 96 represent numbers 1 through 16 (see https://en.bitcoin.it/wiki/Script#Opcodes), which is
            // why we subtract by 80 to get the number of signatures (n) and the number of public keys (m) in an n-of-m setup.
            var len = decompiledPubScript.length;
            var nSignatures = decompiledPubScript[0] - 80;
            var nPubKeys = decompiledPubScript[len - 2] - 80;
            // Due to a bug in the implementation of multisignature in the bitcoin protocol, a 0 is added to the signature
            // script, so we add 1 when asserting the number of signatures matches the number of signatures expected by the
            // pub script. Also, note that we consider a signature script with the the same number of signatures as public
            // keys (+1 as noted above) valid because we use placeholder signatures when parsing a half-signed signature
            // script.
            if (signatures.length !== nSignatures + 1 && signatures.length !== nPubKeys + 1) {
                throw new Error("expected " + nSignatures + " or " + nPubKeys + " signatures, got " + (signatures.length - 1));
            }
            if (publicKeys.length !== nPubKeys) {
                throw new Error("expected " + nPubKeys + " public keys, got " + publicKeys.length);
            }
            var lastOpCode = decompiledPubScript[len - 1];
            if (lastOpCode !== bitcoin.opcodes.OP_CHECKMULTISIG) {
                throw new Error("expected opcode #" + bitcoin.opcodes.OP_CHECKMULTISIG + ", got opcode #" + lastOpCode);
            }
            return { isSegwitInput: isSegwitInput, inputClassification: inputClassification, signatures: signatures, publicKeys: publicKeys, pubScript: pubScript };
        }
        else {
            return { isSegwitInput: isSegwitInput, inputClassification: inputClassification };
        }
    };
    /**
     * Calculate the hash to verify the signature against
     * @param transaction Transaction object
     * @param inputIndex
     * @param pubScript
     * @param amount The previous output's amount
     * @param hashType
     * @param isSegwitInput
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.calculateSignatureHash = function (transaction, inputIndex, pubScript, amount, hashType, isSegwitInput) {
        if (isSegwitInput) {
            return transaction.hashForWitnessV0(inputIndex, pubScript, amount, hashType);
        }
        else {
            return transaction.hashForSignature(inputIndex, pubScript, hashType);
        }
    };
    /**
     * Verify the signature on a (half-signed) transaction
     * @param transaction bitcoinjs-lib tx object
     * @param inputIndex The input whererfore to check the signature
     * @param amount For segwit and BCH, the input amount needs to be known for signature verification
     * @param verificationSettings
     * @param verificationSettings.signatureIndex The index of the signature to verify (only iterates over non-empty signatures)
     * @param verificationSettings.publicKey The hex of the public key to verify (will verify all signatures)
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.verifySignature = function (transaction, inputIndex, amount, verificationSettings) {
        if (verificationSettings === void 0) { verificationSettings = {}; }
        var _a = this.parseSignatureScript(transaction, inputIndex), signatures = _a.signatures, publicKeys = _a.publicKeys, isSegwitInput = _a.isSegwitInput, inputClassification = _a.inputClassification, pubScript = _a.pubScript;
        if (![bitcoin.script.types.P2WSH, bitcoin.script.types.P2SH, bitcoin.script.types.P2PKH]
            .includes(inputClassification)) {
            return false;
        }
        if (isSegwitInput && !amount) {
            return false;
        }
        // get the first non-empty signature and verify it against all public keys
        var nonEmptySignatures = _.filter(signatures, function (s) { return !_.isEmpty(s); });
        /*
        We either want to verify all signature/pubkey combinations, or do an explicit combination
    
        If a signature index is specified, only that signature is checked. It's verified against all public keys.
        If a single public key is found to be valid, the function returns true.
    
        If a public key is specified, we iterate over all signatures. If a single one matches the public key, the function
        returns true.
    
        If neither is specified, all signatures are checked against all public keys. Each signature must have its own distinct
        public key that it matches for the function to return true.
         */
        var signaturesToCheck = nonEmptySignatures;
        if (!_.isUndefined(verificationSettings.signatureIndex)) {
            signaturesToCheck = [nonEmptySignatures[verificationSettings.signatureIndex]];
        }
        var publicKeyHex = verificationSettings.publicKey;
        var matchedPublicKeyIndices = {};
        var areAllSignaturesValid = true;
        // go over all signatures
        for (var _i = 0, signaturesToCheck_1 = signaturesToCheck; _i < signaturesToCheck_1.length; _i++) {
            var signatureBuffer = signaturesToCheck_1[_i];
            var isSignatureValid = false;
            if (Buffer.isBuffer(signatureBuffer) && signatureBuffer.length > 0) {
                // slice the last byte from the signature hash input because it's the hash type
                var signature = bitcoin.ECSignature.fromDER(signatureBuffer.slice(0, -1));
                var hashType = _.last(signatureBuffer);
                var signatureHash = this.calculateSignatureHash(transaction, inputIndex, pubScript, amount, hashType, isSegwitInput);
                for (var publicKeyIndex = 0; publicKeyIndex < publicKeys.length; publicKeyIndex++) {
                    var publicKeyBuffer = publicKeys[publicKeyIndex];
                    if (!_.isUndefined(publicKeyHex) && publicKeyBuffer.toString('hex') !== publicKeyHex) {
                        // we are only looking to verify one specific public key's signature (publicKeyHex)
                        // this particular public key is not the one whose signature we're trying to verify
                        continue;
                    }
                    if (matchedPublicKeyIndices[publicKeyIndex]) {
                        continue;
                    }
                    var publicKey = bitcoin.ECPair.fromPublicKeyBuffer(publicKeyBuffer);
                    if (publicKey.verify(signatureHash, signature)) {
                        isSignatureValid = true;
                        matchedPublicKeyIndices[publicKeyIndex] = true;
                        break;
                    }
                }
            }
            if (!_.isUndefined(publicKeyHex) && isSignatureValid) {
                // We were trying to see if any of the signatures was valid for the given public key. Evidently yes.
                return true;
            }
            if (!isSignatureValid && _.isUndefined(publicKeyHex)) {
                return false;
            }
            areAllSignaturesValid = isSignatureValid && areAllSignaturesValid;
        }
        return areAllSignaturesValid;
    };
    AbstractUtxoCoin.prototype.explainTransaction = function (params) {
        var _this = this;
        if (params === void 0) { params = {}; }
        var txHex = params.txHex, txInfo = params.txInfo;
        if (!txHex || !_.isString(txHex) || !txHex.match(/^([a-f0-9]{2})+$/i)) {
            throw new Error('invalid transaction hex, must be a valid hex string');
        }
        var transaction;
        try {
            transaction = bitcoin.Transaction.fromHex(txHex, this.network);
        }
        catch (e) {
            throw new Error('failed to parse transaction hex');
        }
        var id = transaction.getId();
        var changeAddresses = [];
        var spendAmount = 0;
        var changeAmount = 0;
        if (txInfo && txInfo.changeAddresses) {
            changeAddresses = txInfo.changeAddresses;
        }
        var explanation = {
            displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs'],
            id: id,
            outputs: [],
            changeOutputs: []
        };
        transaction.outs.forEach(function (currentOutput) {
            var currentAddress = _this.getCoinLibrary().address.fromOutputScript(currentOutput.script, _this.network);
            var currentAmount = currentOutput.value;
            if (changeAddresses.indexOf(currentAddress) !== -1) {
                // this is change
                changeAmount += currentAmount;
                explanation.changeOutputs.push({
                    address: currentAddress,
                    amount: currentAmount
                });
                return;
            }
            spendAmount += currentAmount;
            explanation.outputs.push({
                address: currentAddress,
                amount: currentAmount
            });
        });
        explanation.outputAmount = spendAmount;
        explanation.changeAmount = changeAmount;
        // add fee info if available
        if (params.feeInfo) {
            explanation.displayOrder.push('fee');
            explanation.fee = params.feeInfo;
        }
        if (_.isInteger(transaction.locktime) && transaction.locktime > 0) {
            explanation.locktime = transaction.locktime;
            explanation.displayOrder.push('locktime');
        }
        var unspentValues = {};
        // get information on tx inputs
        var inputSignatures = transaction.ins.map(function (input, idx) {
            var hasSigScript = !_.isEmpty(input.script);
            var hasWitnessScript = !_.isEmpty(input.witness);
            if (!hasSigScript && !hasWitnessScript) {
                // no sig script or witness data for this input
                debug('no signature script or witness script data for input %s', idx);
                return 0;
            }
            var parsedSigScript;
            try {
                parsedSigScript = _this.parseSignatureScript(transaction, idx);
            }
            catch (e) {
                return false;
            }
            if (hasWitnessScript) {
                if (!txInfo || !txInfo.unspents) {
                    // segwit txs require input values, cannot validate signatures
                    debug('unable to retrieve input amounts from unspents - cannot validate segwit input signatures');
                    return 0;
                }
                // lazily populate unspent values
                if (_.isEmpty(unspentValues)) {
                    txInfo.unspents.forEach(function (unspent) {
                        unspentValues[unspent.id] = unspent.value;
                    });
                }
            }
            var nonEmptySignatures = parsedSigScript.signatures.filter(function (sig) { return !_.isEmpty(sig); });
            var validSignatures = nonEmptySignatures.map(function (sig, sigIndex) {
                if (_.isEmpty(sig)) {
                    return false;
                }
                var parentTxId = Buffer.from(input.hash).reverse().toString('hex');
                var inputId = parentTxId + ":" + input.index;
                var amount = unspentValues[inputId];
                try {
                    return _this.verifySignature(transaction, idx, amount, { signatureIndex: sigIndex });
                }
                catch (e) {
                    return false;
                }
            });
            return validSignatures.reduce(function (validCount, isValid) { return isValid ? validCount + 1 : validCount; }, 0);
        });
        explanation.inputSignatures = inputSignatures;
        explanation.signatures = _.max(inputSignatures);
        return explanation;
    };
    AbstractUtxoCoin.prototype.createMultiSigAddress = function (addressType, signatureThreshold, keys) {
        function createWitnessProgram(inputScript) {
            var witnessScriptHash = bitcoin.crypto.sha256(inputScript);
            return bitcoin.script.witnessScriptHash.output.encode(witnessScriptHash);
        }
        var multiSigScript = bitcoin.script.multisig.output.encode(signatureThreshold, keys);
        var outputScript, redeemScript, witnessScript;
        switch (addressType) {
            case Codes.UnspentTypeTcomb('p2sh'):
                var multisigScriptHash = bitcoin.crypto.hash160(multiSigScript);
                outputScript = bitcoin.script.scriptHash.output.encode(multisigScriptHash);
                redeemScript = multiSigScript;
                break;
            case Codes.UnspentTypeTcomb('p2shP2wsh'):
                var witnessProgram = createWitnessProgram(multiSigScript);
                var witnessProgramHash = bitcoin.crypto.hash160(witnessProgram);
                outputScript = bitcoin.script.scriptHash.output.encode(witnessProgramHash);
                redeemScript = witnessProgram;
                witnessScript = multiSigScript;
                break;
            case Codes.UnspentTypeTcomb('p2wsh'):
                outputScript = createWitnessProgram(multiSigScript);
                witnessScript = multiSigScript;
                break;
            default:
                throw new Error("unexpected addressType " + addressType);
        }
        return {
            outputScript: outputScript,
            redeemScript: redeemScript,
            witnessScript: witnessScript,
            address: bitcoin.address.fromOutputScript(outputScript, this.network)
        };
    };
    // TODO(BG-11638): remove in next SDK major version release
    AbstractUtxoCoin.prototype.calculateRecoveryAddress = function (scriptHashScript) {
        return this.getCoinLibrary().address.fromOutputScript(scriptHashScript, this.network);
    };
    AbstractUtxoCoin.prototype.getRecoveryFeePerBytes = function () {
        return Promise.resolve(100);
    };
    AbstractUtxoCoin.prototype.getRecoveryFeeRecommendationApiBaseUrl = function () {
        return Promise.reject(new Error('AbtractUtxoCoin method not implemented'));
    };
    AbstractUtxoCoin.prototype.getRecoveryMarketPrice = function () {
        return co(function getRecoveryMarketPrice() {
            var bitcoinAverageUrl, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        bitcoinAverageUrl = config.bitcoinAverageBaseUrl + this.getFamily().toUpperCase() + 'USD';
                        return [4 /*yield*/, request.get(bitcoinAverageUrl).retry(2).result()];
                    case 1:
                        response = _a.sent();
                        if (response === null || typeof response.last !== 'number') {
                            throw new Error('unable to reach BitcoinAverage for price data');
                        }
                        return [2 /*return*/, response.last];
                }
            });
        }).call(this);
    };
    /**
     * Helper function for recover()
     * This transforms the txInfo from recover into the format that offline-signing-tool expects
     * @param txInfo
     * @param txHex
     * @returns {{txHex: *, txInfo: {unspents: *}, feeInfo: {}, coin: void}}
     */
    AbstractUtxoCoin.prototype.formatForOfflineVault = function (txInfo, txHex) {
        var response = {
            txHex: txHex,
            txInfo: {
                unspents: txInfo.inputs
            },
            feeInfo: {},
            coin: this.getChain()
        };
        _.map(response.txInfo.unspents, function (unspent) {
            var pathArray = unspent.chainPath.split('/');
            // Note this code works because we assume our chainPath is m/0/0/chain/index - this will be incorrect for custom derivation schemes
            unspent.index = pathArray[4];
            unspent.chain = pathArray[3];
        });
        return response;
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] xprv, or xpub
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * - scan: the amount of consecutive addresses without unspents to scan through before stopping
     * - ignoreAddressTypes: (optional) array of AddressTypes to ignore, these are strings defined in Codes.UnspentTypeTcomb
     *        for example: ['p2shP2wsh', 'p2wsh'] will prevent code from checking for wrapped-segwit and native-segwit chains on the public block explorers
     * @param callback
     */
    AbstractUtxoCoin.prototype.recover = function (params, callback) {
        return co(function recover() {
            // ============================HELPER FUNCTIONS============================
            function deriveKeys(keyArray, index) {
                return keyArray.map(function (k) { return k.derive(index); });
            }
            var self, queryBlockchainUnspentsPath, isKrsRecovery, isUnsignedSweep, krsProvider, keys, baseKeyPath, queries, addressesById, queryResponses, unspents, totalInputAmount, transactionBuilder, txInfo, feePerByte, outputSize, approximateSize, approximateFee, recoveryAmount, krsFee, krsFeeAddress, txHex, signedTx, _a, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        self = this;
                        queryBlockchainUnspentsPath = co(function queryBlockchainUnspentsPath(keyArray, basePath, addressesById) {
                            var MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS, numSequentialAddressesWithoutTxs, gatherUnspents, walletUnspents;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS = params.scan || 20;
                                        numSequentialAddressesWithoutTxs = 0;
                                        gatherUnspents = co(function coGatherUnspents(addrIndex) {
                                            var derivedKeys, chain, keys, address, addrInfo, addressUnspents;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        derivedKeys = deriveKeys(keyArray, addrIndex);
                                                        chain = Number(basePath.split('/').pop());
                                                        keys = derivedKeys.map(function (k) { return k.getPublicKeyBuffer(); });
                                                        address = self.createMultiSigAddress(Codes.typeForCode(chain), 2, keys);
                                                        return [4 /*yield*/, self.getAddressInfoFromExplorer(address.address)];
                                                    case 1:
                                                        addrInfo = _a.sent();
                                                        if (!(addrInfo.txCount === 0)) return [3 /*break*/, 2];
                                                        numSequentialAddressesWithoutTxs++;
                                                        return [3 /*break*/, 4];
                                                    case 2:
                                                        numSequentialAddressesWithoutTxs = 0;
                                                        if (!(addrInfo.totalBalance > 0)) return [3 /*break*/, 4];
                                                        // This address has a balance.
                                                        address.chainPath = basePath + '/' + addrIndex;
                                                        address.userKey = derivedKeys[0];
                                                        address.backupKey = derivedKeys[1];
                                                        addressesById[address.address] = address;
                                                        return [4 /*yield*/, self.getUnspentInfoFromExplorer(address.address)];
                                                    case 3:
                                                        addressUnspents = _a.sent();
                                                        addressUnspents.forEach(function addAddressToUnspent(unspent) {
                                                            unspent.address = address.address;
                                                            walletUnspents.push(unspent);
                                                        });
                                                        _a.label = 4;
                                                    case 4:
                                                        if (numSequentialAddressesWithoutTxs >= MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS) {
                                                            // stop searching for addresses with unspents in them, we've found 5 in a row with none
                                                            // we are done
                                                            return [2 /*return*/];
                                                        }
                                                        return [2 /*return*/, gatherUnspents(addrIndex + 1)];
                                                }
                                            });
                                        });
                                        walletUnspents = [];
                                        // This will populate walletAddresses
                                        return [4 /*yield*/, gatherUnspents(0)];
                                    case 1:
                                        // This will populate walletAddresses
                                        _a.sent();
                                        if (walletUnspents.length === 0) {
                                            // Couldn't find any addresses with funds
                                            return [2 /*return*/, []];
                                        }
                                        return [2 /*return*/, walletUnspents];
                                }
                            });
                        });
                        // ============================LOGIC============================
                        if (_.isUndefined(params.userKey)) {
                            throw new Error('missing userKey');
                        }
                        if (_.isUndefined(params.backupKey)) {
                            throw new Error('missing backupKey');
                        }
                        if (_.isUndefined(params.recoveryDestination) || !this.isValidAddress(params.recoveryDestination)) {
                            throw new Error('invalid recoveryDestination');
                        }
                        if (!_.isUndefined(params.scan) && (!_.isInteger(params.scan) || params.scan < 0)) {
                            throw new Error('scan must be a positive integer');
                        }
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        krsProvider = config.krsProviders[params.krsProvider];
                        if (isKrsRecovery && _.isUndefined(krsProvider)) {
                            throw new Error('unknown key recovery service provider');
                        }
                        if (isKrsRecovery && !(krsProvider.supportedCoins.includes(this.getFamily()))) {
                            throw new Error('specified key recovery service does not support recoveries for this coin');
                        }
                        return [4 /*yield*/, this.initiateRecovery(params)];
                    case 1:
                        keys = _b.sent();
                        baseKeyPath = deriveKeys(deriveKeys(keys, 0), 0);
                        queries = [];
                        addressesById = {};
                        _.forEach(Object.keys(Codes.UnspentTypeTcomb.meta.map), function (addressType) {
                            // If we aren't ignoring the address type, we derive the public key and construct the query for the external and
                            // internal indices
                            if (!_.includes(params.ignoreAddressTypes, addressType)) {
                                if (addressType === Codes.UnspentTypeTcomb('p2shP2wsh') && !self.supportsP2shP2wsh()) {
                                    // P2shP2wsh is not supported. Skip.
                                    return;
                                }
                                if (addressType === Codes.UnspentTypeTcomb('p2wsh') && !self.supportsP2wsh()) {
                                    // P2wsh is not supported. Skip.
                                    return;
                                }
                                var codes = void 0;
                                try {
                                    codes = Codes.forType(Codes.UnspentTypeTcomb(addressType));
                                }
                                catch (e) {
                                    // The unspent type is not supported by bitgo so attempting to get its chain codes throws. Catch that error
                                    // and continue.
                                    return;
                                }
                                var externalChainCode = codes.external;
                                var internalChainCode = codes.internal;
                                var externalKey = deriveKeys(baseKeyPath, externalChainCode);
                                var internalKey = deriveKeys(baseKeyPath, internalChainCode);
                                queries.push(queryBlockchainUnspentsPath(externalKey, '/0/0/' + externalChainCode, addressesById));
                                queries.push(queryBlockchainUnspentsPath(internalKey, '/0/0/' + internalChainCode, addressesById));
                            }
                        });
                        return [4 /*yield*/, Promise.all(queries)];
                    case 2:
                        queryResponses = _b.sent();
                        unspents = _.flatten(queryResponses);
                        totalInputAmount = _.sumBy(unspents, 'amount');
                        if (totalInputAmount <= 0) {
                            throw new Error('No input to recover - aborting!');
                        }
                        transactionBuilder = new bitcoin.TransactionBuilder(this.network);
                        this.prepareTransactionBuilder(transactionBuilder);
                        txInfo = {};
                        return [4 /*yield*/, this.getRecoveryFeePerBytes()];
                    case 3:
                        feePerByte = _b.sent();
                        outputSize = (isKrsRecovery ? 2 : 1) * VirtualSizes.txP2wshOutputSize;
                        approximateSize = VirtualSizes.txSegOverheadVSize + outputSize + (VirtualSizes.txP2shInputSize * unspents.length);
                        approximateFee = approximateSize * feePerByte;
                        // Construct a transaction
                        txInfo.inputs = unspents.map(function addInputForUnspent(unspent) {
                            var address = addressesById[unspent.address];
                            transactionBuilder.addInput(unspent.txid, unspent.n, 0xffffffff, address.outputScript);
                            return {
                                chainPath: address.chainPath,
                                redeemScript: address.redeemScript && address.redeemScript.toString('hex'),
                                witnessScript: address.witnessScript && address.witnessScript.toString('hex'),
                                value: unspent.amount
                            };
                        });
                        recoveryAmount = totalInputAmount - approximateFee;
                        if (!isKrsRecovery) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.calculateFeeAmount({ provider: params.krsProvider, amount: recoveryAmount })];
                    case 4:
                        krsFee = _b.sent();
                        recoveryAmount -= krsFee;
                        _b.label = 5;
                    case 5:
                        if (recoveryAmount < 0) {
                            throw new Error('this wallet\'s balance is too low to pay the fees specified by the KRS provider');
                        }
                        transactionBuilder.addOutput(params.recoveryDestination, recoveryAmount);
                        if (isKrsRecovery && krsFee > 0) {
                            krsFeeAddress = krsProvider.feeAddresses[this.getChain()];
                            if (!krsFeeAddress) {
                                throw new Error('this KRS provider has not configured their fee structure yet - recovery cannot be completed');
                            }
                            transactionBuilder.addOutput(krsFeeAddress, krsFee);
                        }
                        if (!isUnsignedSweep) return [3 /*break*/, 6];
                        txHex = transactionBuilder.buildIncomplete().toBuffer().toString('hex');
                        return [2 /*return*/, this.formatForOfflineVault(txInfo, txHex)];
                    case 6:
                        signedTx = this.signRecoveryTransaction(transactionBuilder, unspents, addressesById, !isKrsRecovery);
                        txInfo.transactionHex = signedTx.build().toBuffer().toString('hex');
                        _b.label = 7;
                    case 7:
                        _b.trys.push([7, 9, , 10]);
                        _a = txInfo;
                        return [4 /*yield*/, this.verifyRecoveryTransaction(txInfo)];
                    case 8:
                        _a.tx = _b.sent();
                        return [3 /*break*/, 10];
                    case 9:
                        e_2 = _b.sent();
                        if (!(e_2 instanceof errors.MethodNotImplementedError)) {
                            // some coins don't have a reliable third party verification endpoint, so we continue without verification for those coins
                            throw new Error('could not verify recovery transaction');
                        }
                        return [3 /*break*/, 10];
                    case 10:
                        if (isKrsRecovery) {
                            txInfo.coin = this.getChain();
                            txInfo.backupKey = params.backupKey;
                            txInfo.recoveryAmount = recoveryAmount;
                        }
                        return [2 /*return*/, txInfo];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Apply signatures to a funds recovery transaction using user + backup key
     * @param txb {Object} a transaction builder object (with inputs and outputs)
     * @param unspents {Array} the unspents to use in the transaction
     * @param addresses {Array} the address and redeem script info for the unspents
     * @param cosign {Boolean} whether to cosign this transaction with the user's backup key (false if KRS recovery)
     */
    AbstractUtxoCoin.prototype.signRecoveryTransaction = function (txb, unspents, addresses, cosign) {
        var _this = this;
        // sign the inputs
        var signatureIssues = [];
        unspents.forEach(function (unspent, i) {
            var address = addresses[unspent.address];
            var backupPrivateKey = address.backupKey.keyPair;
            var userPrivateKey = address.userKey.keyPair;
            // force-override networks
            backupPrivateKey.network = _this.network;
            userPrivateKey.network = _this.network;
            var currentSignatureIssue = {
                inputIndex: i,
                unspent: unspent
            };
            if (cosign) {
                try {
                    txb.sign(i, backupPrivateKey, address.redeemScript, _this.defaultSigHashType, unspent.amount, address.witnessScript);
                }
                catch (e) {
                    currentSignatureIssue.error = e;
                    signatureIssues.push(currentSignatureIssue);
                }
            }
            try {
                txb.sign(i, userPrivateKey, address.redeemScript, _this.defaultSigHashType, unspent.amount, address.witnessScript);
            }
            catch (e) {
                currentSignatureIssue.error = e;
                signatureIssues.push(currentSignatureIssue);
            }
        });
        if (signatureIssues.length > 0) {
            var failedIndices = signatureIssues.map(function (currentIssue) { return currentIssue.inputIndex; });
            var error = new Error("Failed to sign inputs at indices " + failedIndices.join(', '));
            error.code = 'input_signature_failure';
            error.signingErrors = signatureIssues;
            throw error;
        }
        return txb;
    };
    /**
     * Calculates the amount (in base units) to pay a KRS provider when building a recovery transaction
     * @param params
     * @param params.provider {String} the KRS provider that holds the backup key
     * @param params.amount {Number} amount (in base units) to be recovered
     * @param callback
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.calculateFeeAmount = function (params, callback) {
        return co(function calculateFeeAmount() {
            var krsProvider, feeAmountUsd, currentPrice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        krsProvider = config.krsProviders[params.provider];
                        if (krsProvider === undefined) {
                            throw new Error("no fee structure specified for provider " + params.provider);
                        }
                        if (!(krsProvider.feeType === 'flatUsd')) return [3 /*break*/, 2];
                        feeAmountUsd = krsProvider.feeAmount;
                        return [4 /*yield*/, this.getRecoveryMarketPrice()];
                    case 1:
                        currentPrice = _a.sent();
                        return [2 /*return*/, Math.round(feeAmountUsd / currentPrice * this.getBaseFactor())];
                    case 2: 
                    // we can add more fee structures here as needed for different providers, such as percentage of recovery amount
                    throw new Error('Fee structure not implemented');
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Recover BTC that was sent to the wrong chain
     * @param params
     * @param params.txid {String} The txid of the faulty transaction
     * @param params.recoveryAddress {String} address to send recovered funds to
     * @param params.wallet {Wallet} the wallet that received the funds
     * @param params.recoveryCoin {Coin} the coin type of the wallet that received the funds
     * @param params.signed {Boolean} return a half-signed transaction (default=true)
     * @param params.walletPassphrase {String} the wallet passphrase
     * @param params.xprv {String} the unencrypted xprv (used instead of wallet passphrase)
     * @param callback
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.recoverFromWrongChain = function (params, callback) {
        return co(function recoverFromWrongChain() {
            var txid, recoveryAddress, wallet, walletPassphrase, xprv, recoveryCoin, signed, sourceCoinFamily, recoveryCoinFamily, supportedRecoveryCoins, recoveryTool;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txid = params.txid, recoveryAddress = params.recoveryAddress, wallet = params.wallet, walletPassphrase = params.walletPassphrase, xprv = params.xprv;
                        recoveryCoin = params.coin || params.recoveryCoin;
                        signed = params.signed !== false;
                        sourceCoinFamily = this.getFamily();
                        recoveryCoinFamily = recoveryCoin.getFamily();
                        supportedRecoveryCoins = config.supportedCrossChainRecoveries[sourceCoinFamily];
                        if (_.isUndefined(supportedRecoveryCoins) || !supportedRecoveryCoins.includes(recoveryCoinFamily)) {
                            throw new Error("Recovery of " + sourceCoinFamily + " balances from " + recoveryCoinFamily + " wallets is not supported.");
                        }
                        recoveryTool = new RecoveryTool({
                            bitgo: this.bitgo,
                            sourceCoin: this,
                            recoveryCoin: recoveryCoin,
                            logging: false
                        });
                        return [4 /*yield*/, recoveryTool.buildTransaction({
                                wallet: wallet,
                                faultyTxId: txid,
                                recoveryAddress: recoveryAddress
                            })];
                    case 1:
                        _a.sent();
                        if (!signed) return [3 /*break*/, 3];
                        return [4 /*yield*/, recoveryTool.signTransaction({ passphrase: walletPassphrase, prv: xprv })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, recoveryTool.export()];
                    case 3: return [4 /*yield*/, recoveryTool.buildUnsigned()];
                    case 4: return [2 /*return*/, _a.sent()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    AbstractUtxoCoin.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto.randomBytes(512 / 8);
        }
        var extendedKey = prova.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58()
        };
    };
    return AbstractUtxoCoin;
}(BaseCoin));
module.exports = AbstractUtxoCoin;
//# sourceMappingURL=abstractUtxoCoin.js.map