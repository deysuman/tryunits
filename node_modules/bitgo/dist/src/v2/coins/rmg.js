"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AbstractUtxoCoin = require('./abstractUtxoCoin');
var prova = require('../../prova');
var _ = require("lodash");
var Rmg = /** @class */ (function (_super) {
    __extends(Rmg, _super);
    function Rmg(network) {
        var _this = this;
        // TODO: move to bitgo-utxo-lib (BG-6821)
        prova.networks.rmg.coin = 'rmg';
        _this = _super.call(this, network || prova.networks.rmg) || this;
        return _this;
    }
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    Rmg.prototype.getBaseFactor = function () {
        return 1e6;
    };
    Rmg.prototype.getChain = function () {
        return 'rmg';
    };
    Rmg.prototype.getFamily = function () {
        return 'rmg';
    };
    Rmg.prototype.getFullName = function () {
        return 'Royal Mint Gold';
    };
    Rmg.prototype.isValidAddress = function (address) {
        return prova.Address.validateBase58(address, this.network);
    };
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param address The address string on the network
     * @param keychains Keychain objects with xpubs
     * @param chain Derivation chain
     * @param index Derivation index
     */
    Rmg.prototype.verifyAddress = function (_a) {
        var address = _a.address, keychains = _a.keychains, chain = _a.chain, index = _a.index;
        if (!this.isValidAddress(address)) {
            throw new Error("invalid address: " + address);
        }
        var expectedAddress = this.generateAddress({
            keychains: keychains,
            threshold: 2,
            chain: chain,
            index: index
        });
        if (expectedAddress.address !== address) {
            throw new Error("address validation failure: expected " + expectedAddress.address + " but got " + address);
        }
    };
    /**
     * Generate an address for a wallet based on a set of configurations
     * @param keychains Array of objects with xpubs
     * @param threshold Minimum number of signatures
     * @param chain Derivation chain
     * @param index Derivation index
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript}}}
     */
    Rmg.prototype.generateAddress = function (_a) {
        var keychains = _a.keychains, threshold = _a.threshold, chain = _a.chain, index = _a.index;
        var signatureThreshold = 2;
        if (_.isInteger(threshold)) {
            signatureThreshold = threshold;
            if (signatureThreshold <= 0) {
                throw new Error('threshold has to be positive');
            }
            if (signatureThreshold > keychains.length) {
                throw new Error('threshold cannot exceed number of keys');
            }
        }
        var derivationChain = 0;
        if (_.isInteger(chain) && chain > 0) {
            derivationChain = chain;
        }
        var derivationIndex = 0;
        if (_.isInteger(index) && index > 0) {
            derivationIndex = index;
        }
        var path = 'm/0/0/' + derivationChain + '/' + derivationIndex;
        // do not modify the original argument
        var keychainCopy = _.cloneDeep(keychains);
        var userKey = keychainCopy.shift();
        var aspKeyIds = keychainCopy.map(function (key) { return key.aspKeyId; });
        var derivedUserKey = prova.HDNode.fromBase58(userKey.pub).hdPath().deriveKey(path).getPublicKeyBuffer();
        var provaAddress = new prova.Address(derivedUserKey, aspKeyIds, this.network);
        provaAddress.signatureCount = signatureThreshold;
        var addressDetails = {
            chain: derivationChain,
            index: derivationIndex,
            coin: this.getChain(),
            coinSpecific: {
                outputScript: provaAddress.toScript().toString('hex')
            }
        };
        try {
            addressDetails.address = provaAddress.toString();
        }
        catch (e) {
            // non-(n-1)/n signature count
            addressDetails.address = null;
        }
        return addressDetails;
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {{txHex}}
     */
    Rmg.prototype.signTransaction = function (params) {
        var txPrebuild = params.txPrebuild;
        var userPrv = params.prv;
        if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
            if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
            }
            throw new Error('missing txPrebuild parameter');
        }
        var transaction = prova.Transaction.fromHex(txPrebuild.txHex);
        if (transaction.ins.length !== txPrebuild.txInfo.unspents.length) {
            throw new Error('length of unspents array should equal to the number of transaction inputs');
        }
        if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
            if (!_.isUndefined(userPrv) && !_.isString(userPrv)) {
                throw new Error("prv must be a string, got type " + typeof userPrv);
            }
            throw new Error('missing prv parameter to sign transaction');
        }
        var keychain = prova.HDNode.fromBase58(userPrv, this.network);
        var hdPath = keychain.hdPath();
        var signatureIssues = [];
        for (var index = 0; index < transaction.ins.length; ++index) {
            var currentUnspent = txPrebuild.txInfo.unspents[index];
            var path_1 = 'm/0/0/' + currentUnspent.chain + '/' + currentUnspent.index;
            var privKey = hdPath.deriveKey(path_1);
            var currentSignatureIssue = {
                inputIndex: index,
                unspent: currentUnspent,
                path: path_1
            };
            var unspentAddress = prova.Address.fromBase58(currentUnspent.address);
            var subscript = unspentAddress.toScript();
            var txb = prova.TransactionBuilder.fromTransaction(transaction, this.network);
            try {
                txb.sign(index, privKey, subscript, currentUnspent.value);
            }
            catch (e) {
                currentSignatureIssue.error = e;
                signatureIssues.push(currentSignatureIssue);
                continue;
            }
            transaction = txb.buildIncomplete();
            var isValidSignature = this.verifySignature(transaction, index, currentUnspent.value);
            if (!isValidSignature) {
                currentSignatureIssue.error = new Error('invalid signature');
                signatureIssues.push(currentSignatureIssue);
            }
        }
        if (signatureIssues.length > 0) {
            var failedIndices = signatureIssues.map(function (currentIssue) { return currentIssue.inputIndex; });
            var error = new Error("Failed to sign inputs at indices " + failedIndices.join(', '));
            error.code = 'input_signature_failure';
            error.signingErrors = signatureIssues;
            throw error;
        }
        return {
            txHex: transaction.toHex()
        };
    };
    /**
     * Verify the signature(s) on a (half-signed) transaction
     * @param transaction provajs-lib tx object
     * @param inputIndex The input whose signature is to be verified
     * @param amount The input amount needs to be known for signature verification
     * @param verificationSettings
     * @param verificationSettings.signatureIndex The index of the signature to verify (only iterates over non-empty signatures)
     * @param verificationSettings.publicKey The hex of the public key to verify (will verify all signatures)
     * @returns {boolean}
     */
    Rmg.prototype.verifySignature = function (transaction, inputIndex, amount, verificationSettings) {
        if (verificationSettings === void 0) { verificationSettings = {}; }
        if (!(transaction instanceof prova.Transaction)) {
            throw new Error('transaction has to be an instance of prova.Transaction');
        }
        var currentInput = transaction.ins[inputIndex];
        var signatureScript = currentInput.script;
        var decompiledSigScript = prova.script.decompile(signatureScript);
        // the public keys are all the even-indexed entries
        var publicKeys = _.filter(decompiledSigScript, function (item, index) { return index % 2 === 0; });
        // convert the keys to their hex representations
        var publicKeyHexes = _.map(publicKeys, function (k) { return k.toString('hex'); });
        // the signatures are all the odd-indexed ones
        var signatures = _.filter(decompiledSigScript, function (item, index) { return index % 2 === 1; });
        // we map them to each other
        var signaturesByKeys = _.zipObject(publicKeyHexes, signatures);
        var publicKeysToVerify = publicKeyHexes;
        var publicKeyHex = verificationSettings.publicKey;
        if (!_.isUndefined(verificationSettings.signatureIndex)) {
            publicKeysToVerify = [publicKeyHexes[verificationSettings.signatureIndex]];
        }
        var areAllSignaturesValid = true;
        for (var _i = 0, publicKeysToVerify_1 = publicKeysToVerify; _i < publicKeysToVerify_1.length; _i++) {
            var currentPublicKeyHex = publicKeysToVerify_1[_i];
            if (!_.isUndefined(publicKeyHex) && publicKeyHex !== currentPublicKeyHex) {
                areAllSignaturesValid = false;
                continue;
            }
            if (_.isEmpty(currentPublicKeyHex)) {
                areAllSignaturesValid = false;
                continue;
            }
            var isSignatureValid = false;
            var publicKeyBuffer = Buffer.from(currentPublicKeyHex, 'hex');
            var signatureBuffer = signaturesByKeys[currentPublicKeyHex];
            if (Buffer.isBuffer(publicKeyBuffer) && publicKeyBuffer.length > 0 && Buffer.isBuffer(signatureBuffer) && signatureBuffer.length > 0) {
                var publicKey = prova.ECPair.fromPublicKeyBuffer(publicKeyBuffer);
                var signatureHash = transaction.hashForWitnessV0(inputIndex, null, amount, prova.Transaction.SIGHASH_ALL);
                isSignatureValid = publicKey.verify(signatureHash, signatureBuffer);
            }
            if (!_.isUndefined(publicKeyHex) && isSignatureValid) {
                // We were trying to see if any of the signatures was valid for the given public key. Evidently yes.
                return true;
            }
            areAllSignaturesValid = isSignatureValid && areAllSignaturesValid;
        }
        return areAllSignaturesValid;
    };
    Rmg.prototype.explainTransaction = function (params) {
        var self = this;
        var transaction = prova.Transaction.fromHex(params.txHex);
        var id = transaction.getId();
        var changeAddresses = [];
        var spendAmount = 0;
        var changeAmount = 0;
        if (params.txInfo && params.txInfo.changeAddresses) {
            changeAddresses = params.txInfo.changeAddresses;
        }
        var explanation = {
            displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs'],
            id: id,
            outputs: [],
            changeOutputs: []
        };
        transaction.outs.forEach(function (currentOutput) {
            var currentAddress = prova.Address.fromScript(currentOutput.script, self.network).toString();
            var currentAmount = currentOutput.value;
            if (changeAddresses.indexOf(currentAddress) !== -1) {
                // this is change
                changeAmount += currentAmount;
                explanation.changeOutputs.push({
                    address: currentAddress,
                    amount: currentAmount
                });
                return;
            }
            spendAmount += currentAmount;
            explanation.outputs.push({
                address: currentAddress,
                amount: currentAmount
            });
        });
        explanation.outputAmount = spendAmount;
        explanation.changeAmount = changeAmount;
        // add fee info if available
        if (params.feeInfo) {
            explanation.displayOrder.push('fee');
            explanation.fee = params.feeInfo;
        }
        return explanation;
    };
    return Rmg;
}(AbstractUtxoCoin));
module.exports = Rmg;
//# sourceMappingURL=rmg.js.map