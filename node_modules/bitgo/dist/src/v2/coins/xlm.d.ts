declare const BaseCoin: any;
declare class Xlm extends BaseCoin {
    constructor();
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    getBaseFactor(): number;
    getChain(): string;
    getFamily(): string;
    getFullName(): string;
    getFederationServerUrl(): any;
    getHorizonUrl(): string;
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed: any): {
        pub: any;
        prv: any;
    };
    /**
     * Get decoded ed25519 public key from raw data
     *
     * @param pub {String} Raw public key
     * @returns {String} Encoded public key
     */
    getPubFromRaw(pub: any): any;
    /**
     * Get decoded ed25519 private key from raw data
     *
     * @param prv {String} Raw private key
     * @returns {String} Encoded private key
     */
    getPrvFromRaw(prv: any): any;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: any): any;
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPrv(prv: any): any;
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId {String} memo id
     * @returns {boolean} true if memo id is valid
     */
    isValidMemoId(memoId: any): any;
    /**
     * Evaluates whether a memo is valid
     *
     * @param value {String} value of the memo
     * @param type {String} type of the memo
     * @returns {Boolean} true if value and type are a valid
     */
    isValidMemo({ value, type }: {
        value: any;
        type: any;
    }): boolean;
    /**
     * Minimum balance of a 2-of-3 multisig wallet
     * @returns {number} minimum balance in stroops
     */
    getMinimumReserve(): any;
    /**
     * Transaction fee for each operation
     * @returns {number} transaction fee in stroops
     */
    getBaseTransactionFee(): any;
    /**
     * Process address into address and memo id
     *
     * @param address {String} the address
     * @returns {Object} object containing address and memo id
     */
    getAddressDetails(address: any): {
        address: any;
        memoId: any;
    };
    /**
     * Validate and return address with appended memo id
     *
     * @param address {String} address
     * @param memoId {String} memo id
     * @returns {String} address with memo id
     */
    normalizeAddress({ address, memoId }: {
        address: any;
        memoId: any;
    }): any;
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidAddress(address: any): boolean;
    /**
     * Evaluate whether a stellar username has valid format
     * This method is used by the client when a stellar address is being added to a wallet
     * Example of a common stellar username: foo@bar.baz
     * The above example would result in the Stellar address: foo@bar.baz*bitgo.com
     *
     * @param {String} username - stellar username
     * @return {boolean} true if stellar username is valid
     */
    isValidStellarUsername(username: any): boolean;
    /**
     * Get an instance of FederationServer for BitGo lookups
     *
     * @returns {FederationServer} instance of BitGo Federation Server
     */
    getBitGoFederationServer(): any;
    /**
     * Attempt to resolve a stellar address into a stellar account
     * If address domain matches bitgo's then resolve on our federation server
     * Else, make the request to the federation server hosting the address
     *
     * @param {String} address - stellar address to look for
     * @return {Promise}
     */
    federationLookupByName(address: any): any;
    /**
     * Attempt to resolve an account id into a stellar account
     * Only works for accounts that can be resolved by our federation server
     *
     * @param {String} accountId - stellar account id
     * @return {Promise}
     */
    federationLookupByAccountId(accountId: any): any;
    /**
     * Check if address is a valid XLM address, and then make sure it matches the root address.
     *
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    verifyAddress({ address, rootAddress }: {
        address: any;
        rootAddress: any;
    }): void;
    /**
     * Generates Stellar keypairs from the user key and backup key
     * @param params
     *  - userKey: user keypair private key (encrypted or plaintext)
     *  - backupKey: backup keypair public key (plaintext) or private key (encrypted or plaintext)
     * @returns {stellar.Keypair[]} array of user and backup keypairs
     */
    initiateRecovery(params: any): any[];
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] Stellar private key
     * - backupKey: [encrypted] Stellar private key, or public key if the private key is held by a KRS provider
     * - walletPassphrase: necessary if one of the private keys is encrypted
     * - rootAddress: base address of the wallet to recover funds from
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * @param callback
     * @returns {Function|*}
     */
    recover(params: any, callback: any): any;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     */
    signTransaction(params: any): {
        halfSigned: {
            txBase64: any;
        };
    };
    /**
     * Extend walletParams with extra params required for generating an XLM wallet
     *
     * @param walletParams {Object}
     */
    supplementGenerateWallet(walletParams: any): any;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    signMessage(key: any, message: any): any;
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub {String} public key
     * @param message {Buffer|String} signed message
     * @param signature {Buffer} signature to verify
     * @returns {Boolean} true if signature is valid.
     */
    verifySignature(pub: any, message: any, signature: any): any;
    /**
     * Explain/parse transaction
     * @param params
     * - txBase64: transaction encoded as base64 string
     * @returns {{displayOrder: [string,string,string,string,string], id: *, outputs: Array, changeOutputs: Array}}
     */
    explainTransaction(params: any): any;
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param txParams {Object} params object passed to send
     * @param txPrebuild {Object} prebuild object returned by platform
     * @param txPrebuild.txBase64 {String} prebuilt transaction encoded as base64 string
     * @param wallet {Wallet} wallet object to obtain keys to verify against
     * @param verification Object specifying some verification parameters
     * @param verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param verification.keychains Pass keychains manually rather than fetching them by id
     * @param callback
     * @returns {boolean}
     */
    verifyTransaction({ txParams, txPrebuild, wallet, verification }: any, callback: any): any;
}
export = Xlm;
