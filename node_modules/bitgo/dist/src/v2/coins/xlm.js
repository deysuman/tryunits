"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _ = require("lodash");
var BigNumber = require('bignumber.js');
var querystring = require('querystring');
var url = require('url');
var Promise = require("bluebird");
var co = Promise.coroutine;
var request = require('superagent');
var BaseCoin = require('../baseCoin');
var config = require('../../config');
var common = require("../../common");
var stellar = require('stellar-sdk');
var maxMemoId = '0xFFFFFFFFFFFFFFFF'; // max unsigned 64-bit number = 18446744073709551615
var Xlm = /** @class */ (function (_super) {
    __extends(Xlm, _super);
    function Xlm() {
        var _this = _super.call(this) || this;
        _this.homeDomain = 'bitgo.com'; // used for reverse federation lookup
        stellar.Network.use(new stellar.Network(stellar.Networks.PUBLIC));
        return _this;
    }
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    Xlm.prototype.getBaseFactor = function () {
        return 1e7;
    };
    Xlm.prototype.getChain = function () {
        return 'xlm';
    };
    Xlm.prototype.getFamily = function () {
        return 'xlm';
    };
    Xlm.prototype.getFullName = function () {
        return 'Stellar';
    };
    Xlm.prototype.getFederationServerUrl = function () {
        return common.Environments[this.bitgo.env].stellarFederationServerUrl;
    };
    Xlm.prototype.getHorizonUrl = function () {
        return 'https://horizon.stellar.org';
    };
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    Xlm.prototype.generateKeyPair = function (seed) {
        var pair = seed ? stellar.Keypair.fromRawEd25519Seed(seed) : stellar.Keypair.random();
        return {
            pub: pair.publicKey(),
            prv: pair.secret()
        };
    };
    /**
     * Get decoded ed25519 public key from raw data
     *
     * @param pub {String} Raw public key
     * @returns {String} Encoded public key
     */
    Xlm.prototype.getPubFromRaw = function (pub) {
        return stellar.StrKey.encodeEd25519PublicKey(Buffer.from(pub, 'hex'));
    };
    /**
     * Get decoded ed25519 private key from raw data
     *
     * @param prv {String} Raw private key
     * @returns {String} Encoded private key
     */
    Xlm.prototype.getPrvFromRaw = function (prv) {
        return stellar.StrKey.encodeEd25519SecretSeed(Buffer.from(prv, 'hex'));
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Xlm.prototype.isValidPub = function (pub) {
        return stellar.StrKey.isValidEd25519PublicKey(pub);
    };
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    Xlm.prototype.isValidPrv = function (prv) {
        return stellar.StrKey.isValidEd25519SecretSeed(prv);
    };
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId {String} memo id
     * @returns {boolean} true if memo id is valid
     */
    Xlm.prototype.isValidMemoId = function (memoId) {
        try {
            stellar.Memo.id(memoId); // throws if the value is not valid memo id
            memoId = new BigNumber(memoId);
        }
        catch (e) {
            return false;
        }
        return (memoId.gte(0) && memoId.lt(maxMemoId));
    };
    /**
     * Evaluates whether a memo is valid
     *
     * @param value {String} value of the memo
     * @param type {String} type of the memo
     * @returns {Boolean} true if value and type are a valid
     */
    Xlm.prototype.isValidMemo = function (_a) {
        var value = _a.value, type = _a.type;
        if (!value || !type) {
            return false;
        }
        try {
            // throws if the value is not valid for the type
            // valid types are: 'id', 'text', 'hash', 'return'
            // See https://www.stellar.org/developers/guides/concepts/transactions.html#memo
            stellar.Memo[type](value);
        }
        catch (e) {
            return false;
        }
        return true;
    };
    /**
     * Minimum balance of a 2-of-3 multisig wallet
     * @returns {number} minimum balance in stroops
     */
    Xlm.prototype.getMinimumReserve = function () {
        return co(function () {
            var server, horizonLedgerInfo, baseReserve;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        server = new stellar.Server(this.getHorizonUrl());
                        return [4 /*yield*/, server
                                .ledgers()
                                .order('desc')
                                .limit(1)
                                .call()];
                    case 1:
                        horizonLedgerInfo = _a.sent();
                        if (!horizonLedgerInfo) {
                            throw new Error('unable to connect to Horizon for reserve requirement data');
                        }
                        baseReserve = horizonLedgerInfo.records[0].base_reserve_in_stroops;
                        // 2-of-3 wallets have a minimum reserve of 5x the base reserve
                        return [2 /*return*/, 5 * baseReserve];
                }
            });
        }).call(this);
    };
    /**
     * Transaction fee for each operation
     * @returns {number} transaction fee in stroops
     */
    Xlm.prototype.getBaseTransactionFee = function () {
        return co(function () {
            var server, horizonLedgerInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        server = new stellar.Server(this.getHorizonUrl());
                        return [4 /*yield*/, server
                                .ledgers()
                                .order('desc')
                                .limit(1)
                                .call()];
                    case 1:
                        horizonLedgerInfo = _a.sent();
                        if (!horizonLedgerInfo) {
                            throw new Error('unable to connect to Horizon for reserve requirement data');
                        }
                        return [2 /*return*/, horizonLedgerInfo.records[0].base_fee_in_stroops];
                }
            });
        }).call(this);
    };
    /**
     * Process address into address and memo id
     *
     * @param address {String} the address
     * @returns {Object} object containing address and memo id
     */
    Xlm.prototype.getAddressDetails = function (address) {
        var destinationDetails = url.parse(address);
        var queryDetails = querystring.parse(destinationDetails.query);
        var destinationAddress = destinationDetails.pathname;
        if (!stellar.StrKey.isValidEd25519PublicKey(destinationAddress)) {
            throw new Error("invalid address: " + address);
        }
        // address doesn't have a memo id
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                memoId: null
            };
        }
        if (!queryDetails.memoId) {
            // if there are more properties, the query details need to contain the memo id property
            throw new Error("invalid address: " + address);
        }
        try {
            new BigNumber(queryDetails.memoId);
        }
        catch (e) {
            throw new Error("invalid address: " + address);
        }
        if (!this.isValidMemoId(queryDetails.memoId)) {
            throw new Error("invalid address: " + address);
        }
        return {
            address: destinationAddress,
            memoId: queryDetails.memoId
        };
    };
    /**
     * Validate and return address with appended memo id
     *
     * @param address {String} address
     * @param memoId {String} memo id
     * @returns {String} address with memo id
     */
    Xlm.prototype.normalizeAddress = function (_a) {
        var address = _a.address, memoId = _a.memoId;
        if (!stellar.StrKey.isValidEd25519PublicKey(address)) {
            throw new Error("invalid address details: " + address);
        }
        if (this.isValidMemoId(memoId)) {
            return address + "?memoId=" + memoId;
        }
        return address;
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Xlm.prototype.isValidAddress = function (address) {
        try {
            var addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Evaluate whether a stellar username has valid format
     * This method is used by the client when a stellar address is being added to a wallet
     * Example of a common stellar username: foo@bar.baz
     * The above example would result in the Stellar address: foo@bar.baz*bitgo.com
     *
     * @param {String} username - stellar username
     * @return {boolean} true if stellar username is valid
     */
    Xlm.prototype.isValidStellarUsername = function (username) {
        return /^[a-z0-9\-\_\.\+\@]+$/.test(username);
    };
    /**
     * Get an instance of FederationServer for BitGo lookups
     *
     * @returns {FederationServer} instance of BitGo Federation Server
     */
    Xlm.prototype.getBitGoFederationServer = function () {
        // Identify the URI scheme in case we need to allow connecting to HTTP server.
        var isNonSecureEnv = !_.startsWith(common.Environments[this.bitgo.env].uri, 'https');
        var federationServerOptions = { allowHttp: isNonSecureEnv };
        return new stellar.FederationServer(this.getFederationServerUrl(), 'bitgo.com', federationServerOptions);
    };
    /**
     * Attempt to resolve a stellar address into a stellar account
     * If address domain matches bitgo's then resolve on our federation server
     * Else, make the request to the federation server hosting the address
     *
     * @param {String} address - stellar address to look for
     * @return {Promise}
     */
    Xlm.prototype.federationLookupByName = function (address) {
        return co(function () {
            var addressParts, homeDomain, federationServer, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        addressParts = _.split(address, '*');
                        if (addressParts.length !== 2) {
                            throw new Error("invalid stellar address: " + address);
                        }
                        homeDomain = addressParts[1];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        if (!(homeDomain === this.homeDomain)) return [3 /*break*/, 3];
                        federationServer = this.getBitGoFederationServer();
                        return [4 /*yield*/, federationServer.resolveAddress(address)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3: return [4 /*yield*/, stellar.FederationServer.resolve(address)];
                    case 4: return [2 /*return*/, _a.sent()];
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        e_1 = _a.sent();
                        if (e_1.message === 'Network Error') {
                            throw e_1;
                        }
                        else {
                            throw new Error('account not found');
                        }
                        return [3 /*break*/, 7];
                    case 7: return [2 /*return*/];
                }
            });
        }).call(this);
    };
    /**
     * Attempt to resolve an account id into a stellar account
     * Only works for accounts that can be resolved by our federation server
     *
     * @param {String} accountId - stellar account id
     * @return {Promise}
     */
    Xlm.prototype.federationLookupByAccountId = function (accountId) {
        return co(function () {
            var federationServer, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        federationServer = this.getBitGoFederationServer();
                        return [4 /*yield*/, federationServer.resolveAccountId(accountId)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        e_2 = _a.sent();
                        throw new Error(e_2.response.data.detail);
                    case 3: return [2 /*return*/];
                }
            });
        }).call(this);
    };
    /**
     * Check if address is a valid XLM address, and then make sure it matches the root address.
     *
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    Xlm.prototype.verifyAddress = function (_a) {
        var address = _a.address, rootAddress = _a.rootAddress;
        if (!this.isValidAddress(address)) {
            throw new Error("invalid address: " + address);
        }
        var addressDetails = this.getAddressDetails(address);
        var rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.address !== rootAddressDetails.address) {
            throw new Error("address validation failure: " + addressDetails.address + " vs " + rootAddressDetails.address);
        }
    };
    /**
     * Generates Stellar keypairs from the user key and backup key
     * @param params
     *  - userKey: user keypair private key (encrypted or plaintext)
     *  - backupKey: backup keypair public key (plaintext) or private key (encrypted or plaintext)
     * @returns {stellar.Keypair[]} array of user and backup keypairs
     */
    Xlm.prototype.initiateRecovery = function (params) {
        var keys = [];
        var userKey = params.userKey;
        var backupKey = params.backupKey;
        // Stellar's Ed25519 public keys start with a G, while private keys start with an S
        var isKrsRecovery = backupKey.startsWith('G') && !userKey.startsWith('G');
        var isUnsignedSweep = backupKey.startsWith('G') && userKey.startsWith('G');
        if (isKrsRecovery && _.isUndefined(config.krsProviders[params.krsProvider])) {
            throw new Error("Unknown key recovery service provider - " + params.krsProvider);
        }
        if (isKrsRecovery && !config.krsProviders[params.krsProvider].supportedCoins.includes(this.getFamily())) {
            throw new Error("Specified key recovery service does not support recoveries for " + this.getChain());
        }
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new Error('Invalid destination address!');
        }
        try {
            if (!userKey.startsWith('S') && !userKey.startsWith('G')) {
                userKey = this.bitgo.decrypt({
                    input: userKey,
                    password: params.walletPassphrase
                });
            }
            var userKeyPair = isUnsignedSweep ? stellar.Keypair.fromPublicKey(userKey) : stellar.Keypair.fromSecret(userKey);
            keys.push(userKeyPair);
        }
        catch (e) {
            throw new Error('Failed to decrypt user key with passcode - try again!');
        }
        try {
            if (!backupKey.startsWith('S') && !isKrsRecovery && !isUnsignedSweep) {
                backupKey = this.bitgo.decrypt({
                    input: backupKey,
                    password: params.walletPassphrase
                });
            }
            if (isKrsRecovery || isUnsignedSweep) {
                keys.push(stellar.Keypair.fromPublicKey(backupKey));
            }
            else {
                keys.push(stellar.Keypair.fromSecret(backupKey));
            }
        }
        catch (e) {
            throw new Error('Failed to decrypt backup key with passcode - try again!');
        }
        return keys;
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] Stellar private key
     * - backupKey: [encrypted] Stellar private key, or public key if the private key is held by a KRS provider
     * - walletPassphrase: necessary if one of the private keys is encrypted
     * - rootAddress: base address of the wallet to recover funds from
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * @param callback
     * @returns {Function|*}
     */
    Xlm.prototype.recover = function (params, callback) {
        return co(function () {
            var _a, userKey, backupKey, isKrsRecovery, isUnsignedSweep, accountDataUrl, destinationUrl, accountData, e_3, unfundedDestination, e_4, account, nativeBalanceInfo, walletBalance, minimumReserve, baseTxFee, recoveryAmount, formattedRecoveryAmount, txBuilder, operation, transaction;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.initiateRecovery(params), userKey = _a[0], backupKey = _a[1];
                        isKrsRecovery = params.backupKey.startsWith('G') && !params.userKey.startsWith('G');
                        isUnsignedSweep = params.backupKey.startsWith('G') && params.userKey.startsWith('G');
                        if (!stellar.StrKey.isValidEd25519PublicKey(params.rootAddress)) {
                            throw new Error("Invalid wallet address: " + params.rootAddress);
                        }
                        accountDataUrl = this.getHorizonUrl() + "/accounts/" + params.rootAddress;
                        destinationUrl = this.getHorizonUrl() + "/accounts/" + params.recoveryDestination;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, request.get(accountDataUrl).result()];
                    case 2:
                        accountData = _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_3 = _b.sent();
                        throw new Error('Unable to reach the Stellar network via Horizon.');
                    case 4:
                        unfundedDestination = false;
                        _b.label = 5;
                    case 5:
                        _b.trys.push([5, 7, , 8]);
                        return [4 /*yield*/, request.get(destinationUrl)];
                    case 6:
                        _b.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        e_4 = _b.sent();
                        if (e_4.status === 404) {
                            // If the destination account does not yet exist, horizon responds with 404
                            unfundedDestination = true;
                        }
                        return [3 /*break*/, 8];
                    case 8:
                        if (!accountData.sequence || !accountData.balances) {
                            throw new Error('Horizon server error - unable to retrieve sequence ID or account balance');
                        }
                        account = new stellar.Account(params.rootAddress, accountData.sequence);
                        nativeBalanceInfo = accountData.balances.find(function (assetBalance) { return assetBalance['asset_type'] === 'native'; });
                        if (!nativeBalanceInfo) {
                            throw new Error('Provided wallet has a balance of 0 XLM, recovery aborted');
                        }
                        walletBalance = this.bigUnitsToBaseUnits(nativeBalanceInfo.balance);
                        return [4 /*yield*/, this.getMinimumReserve()];
                    case 9:
                        minimumReserve = _b.sent();
                        return [4 /*yield*/, this.getBaseTransactionFee()];
                    case 10:
                        baseTxFee = _b.sent();
                        recoveryAmount = walletBalance - minimumReserve - baseTxFee;
                        formattedRecoveryAmount = (this.baseUnitsToBigUnits(recoveryAmount)).toString();
                        txBuilder = new stellar.TransactionBuilder(account);
                        if (unfundedDestination) { // In this case, we need to create the account
                            operation = stellar.Operation.createAccount({
                                destination: params.recoveryDestination,
                                startingBalance: formattedRecoveryAmount
                            });
                        }
                        else { // Otherwise if the account already exists, we do a normal send
                            operation = stellar.Operation.payment({
                                destination: params.recoveryDestination,
                                asset: stellar.Asset.native(),
                                amount: formattedRecoveryAmount
                            });
                        }
                        txBuilder = txBuilder.addOperation(operation).build();
                        if (!isUnsignedSweep) {
                            txBuilder.sign(userKey);
                        }
                        if (!isKrsRecovery && !isUnsignedSweep) {
                            txBuilder.sign(backupKey);
                        }
                        transaction = {
                            tx: txBuilder.toEnvelope().toXDR('base64'),
                            recoveryAmount: recoveryAmount
                        };
                        if (isKrsRecovery) {
                            transaction.backupKey = params.backupKey;
                            transaction.coin = this.getChain();
                        }
                        return [2 /*return*/, transaction];
                }
            });
        }).call(this);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     */
    Xlm.prototype.signTransaction = function (params) {
        var txPrebuild = params.txPrebuild, prv = params.prv;
        if (_.isUndefined(txPrebuild)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isObject(txPrebuild)) {
            throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error("prv must be a string, got type " + typeof prv);
        }
        var keyPair = stellar.Keypair.fromSecret(prv);
        var tx = new stellar.Transaction(txPrebuild.txBase64);
        tx.sign(keyPair);
        return {
            halfSigned: {
                txBase64: tx.toEnvelope().toXDR('base64')
            }
        };
    };
    /**
     * Extend walletParams with extra params required for generating an XLM wallet
     *
     * @param walletParams {Object}
     */
    Xlm.prototype.supplementGenerateWallet = function (walletParams) {
        return co(function () {
            var seed, rootPrv, keyPair;
            return __generator(this, function (_a) {
                rootPrv = walletParams.rootPrivateKey;
                if (rootPrv) {
                    if (!this.isValidPrv(rootPrv)) {
                        throw new Error('rootPrivateKey needs to be valid ed25519 secret seed');
                    }
                    seed = stellar.StrKey.decodeEd25519SecretSeed(rootPrv);
                }
                keyPair = this.generateKeyPair(seed);
                // extend the wallet initialization params
                walletParams.rootPrivateKey = keyPair.prv;
                return [2 /*return*/, walletParams];
            });
        }).call(this);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    Xlm.prototype.signMessage = function (key, message) {
        if (!this.isValidPrv(key.prv)) {
            throw new Error("invalid prv: " + key.prv);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        var keypair = stellar.Keypair.fromSecret(key.prv);
        return keypair.sign(message);
    };
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub {String} public key
     * @param message {Buffer|String} signed message
     * @param signature {Buffer} signature to verify
     * @returns {Boolean} true if signature is valid.
     */
    Xlm.prototype.verifySignature = function (pub, message, signature) {
        if (!this.isValidPub(pub)) {
            throw new Error("invalid pub: " + pub);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        var keyPair = stellar.Keypair.fromPublicKey(pub);
        return keyPair.verify(message, signature);
    };
    /**
     * Explain/parse transaction
     * @param params
     * - txBase64: transaction encoded as base64 string
     * @returns {{displayOrder: [string,string,string,string,string], id: *, outputs: Array, changeOutputs: Array}}
     */
    Xlm.prototype.explainTransaction = function (params) {
        var _this = this;
        var txBase64 = params.txBase64;
        var tx;
        try {
            tx = new stellar.Transaction(txBase64);
        }
        catch (e) {
            throw new Error('txBase64 needs to be a valid tx encoded as base64 string');
        }
        var id = tx.hash().toString('hex');
        var explanation = {
            displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee', 'memo'],
            id: id,
            outputs: [],
            changeOutputs: [],
            memo: {}
        };
        // In a Stellar tx, the _memo property is an object with the methods:
        // value() and arm() that provide memo value and type, respectively.
        if (_.result(tx, '_memo.value') && _.result(tx, '_memo.arm')) {
            explanation.memo = {
                value: _.result(tx, '_memo.value').toString(),
                type: _.result(tx, '_memo.arm')
            };
        }
        var spendAmount = new BigNumber(0);
        // Process only operations of the native asset (XLM)
        var operations = _.filter(tx.operations, function (operation) { return !operation.asset || operation.asset.getCode() === 'XLM'; });
        if (_.isEmpty(operations)) {
            throw new Error('missing operations');
        }
        explanation.outputs = _.map(operations, function (operation) {
            // Get memo to attach to address, if type is 'id'
            var memoId = (_.get(explanation, 'memo.type') === 'id' && !_.get(explanation, 'memo.value') ? "?memoId=" + explanation.memo.value : '');
            var output = {
                amount: _this.bigUnitsToBaseUnits(operation.startingBalance || operation.amount),
                address: operation.destination + memoId
            };
            spendAmount = spendAmount.plus(output.amount);
            return output;
        });
        explanation.outputAmount = spendAmount.toFixed(0);
        explanation.changeAmount = '0';
        explanation.fee = {
            fee: tx.fee.toFixed(0),
            feeRate: null,
            size: null
        };
        return explanation;
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param txParams {Object} params object passed to send
     * @param txPrebuild {Object} prebuild object returned by platform
     * @param txPrebuild.txBase64 {String} prebuilt transaction encoded as base64 string
     * @param wallet {Wallet} wallet object to obtain keys to verify against
     * @param verification Object specifying some verification parameters
     * @param verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param verification.keychains Pass keychains manually rather than fetching them by id
     * @param callback
     * @returns {boolean}
     */
    Xlm.prototype.verifyTransaction = function (_a, callback) {
        var txParams = _a.txParams, txPrebuild = _a.txPrebuild, wallet = _a.wallet, _b = _a.verification, verification = _b === void 0 ? {} : _b;
        // TODO BG-5600 Add parseTransaction / improve verification
        return co(function () {
            var disableNetworking, tx, outputOperations, userSignature, keychains;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        disableNetworking = !!verification.disableNetworking;
                        tx = new stellar.Transaction(txPrebuild.txBase64);
                        if (txParams.recipients.length !== 1) {
                            throw new Error('cannot specify more than 1 recipient');
                        }
                        outputOperations = _.filter(tx.operations, function (operation) {
                            return operation.type === 'createAccount' || operation.type === 'payment';
                        });
                        if (_.isEmpty(outputOperations)) {
                            throw new Error('transaction prebuild does not have any operations');
                        }
                        _.forEach(txParams.recipients, function (expectedOutput, index) {
                            var expectedOutputAddress = _this.getAddressDetails(expectedOutput.address);
                            var output = outputOperations[index];
                            if (output.destination !== expectedOutputAddress.address) {
                                throw new Error('transaction prebuild does not match expected recipient');
                            }
                            var expectedOutputAmount = new BigNumber(expectedOutput.amount);
                            // The output amount is expressed as startingBalance in createAccount operations and as amount in payment operations.
                            var outputAmount = (output.type === 'createAccount') ? output.startingBalance : output.amount;
                            outputAmount = new BigNumber(_this.bigUnitsToBaseUnits(outputAmount));
                            if (!outputAmount.eq(expectedOutputAmount)) {
                                throw new Error('transaction prebuild does not match expected amount');
                            }
                        });
                        if (!!_.isEmpty(tx.signatures)) return [3 /*break*/, 4];
                        userSignature = tx.signatures[0].signature();
                        keychains = verification.keychains;
                        if (!(!keychains && disableNetworking)) return [3 /*break*/, 1];
                        throw new Error('cannot fetch keychains without networking');
                    case 1:
                        if (!!keychains) return [3 /*break*/, 3];
                        return [4 /*yield*/, Promise.props({
                                user: this.keychains().get({ id: wallet._wallet.keys[0] }),
                                backup: this.keychains().get({ id: wallet._wallet.keys[1] }),
                                bitgo: this.keychains().get({ id: wallet._wallet.keys[2] })
                            })];
                    case 2:
                        keychains = _a.sent();
                        _a.label = 3;
                    case 3:
                        if (this.verifySignature(keychains.backup.pub, tx.hash(), userSignature)) {
                            throw new Error('transaction signed with wrong key');
                        }
                        if (!this.verifySignature(keychains.user.pub, tx.hash(), userSignature)) {
                            throw new Error('transaction signature invalid');
                        }
                        _a.label = 4;
                    case 4: return [2 /*return*/, true];
                }
            });
        }).call(this).asCallback(callback);
    };
    return Xlm;
}(BaseCoin));
module.exports = Xlm;
//# sourceMappingURL=xlm.js.map