"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var BaseCoin = require('../baseCoin');
var Wallet = require('../wallet');
var common = require("../../common");
var config = require('../../config');
var BigNumber = require('bignumber.js');
var Util = require('../../util');
var _ = require("lodash");
var Promise = require("bluebird");
var request = require('superagent');
var crypto = require('crypto');
var prova = require('prova-lib');
var utxoLib = require('bitgo-utxo-lib');
var co = Promise.coroutine;
// The following dependencies are optional. If they are missing we still want to be
// able to require `eth.js` without error.
var optionalDeps = {
    get ethAbi() {
        return require('ethereumjs-abi');
    },
    get ethUtil() {
        return require('ethereumjs-util');
    },
    get EthTx() {
        return require('ethereumjs-tx');
    }
};
var Eth = /** @class */ (function (_super) {
    __extends(Eth, _super);
    function Eth() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    Eth.prototype.getBaseFactor = function () {
        // 10^18
        return '1000000000000000000';
    };
    Eth.prototype.getChain = function () {
        return 'eth';
    };
    Eth.prototype.getFamily = function () {
        return 'eth';
    };
    Eth.prototype.getFullName = function () {
        return 'Ethereum';
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Eth.prototype.valuelessTransferAllowed = function () {
        return true;
    };
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    Eth.prototype.transactionDataAllowed = function () {
        return true;
    };
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    Eth.prototype.isValidAddress = function (address) {
        return optionalDeps.ethUtil.isValidAddress(optionalDeps.ethUtil.addHexPrefix(address));
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Eth.prototype.isValidPub = function (pub) {
        try {
            prova.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Default gas price from platform
     * @returns {BigNumber}
     */
    Eth.prototype.getRecoveryGasPrice = function () {
        return new optionalDeps.ethUtil.BN('20000000000');
    };
    /**
     * Default gas limit from platform
     * @returns {BigNumber}
     */
    Eth.prototype.getRecoveryGasLimit = function () {
        return new optionalDeps.ethUtil.BN('500000');
    };
    /**
     * Default expire time for a contract call (1 week)
     * @returns {number} Time in seconds
     */
    Eth.prototype.getDefaultExpireTime = function () {
        return Math.floor((new Date().getTime()) / 1000) + (60 * 60 * 24 * 7);
    };
    /**
     * Query Etherscan for the balance of an address
     * @param address {String} the ETH address
     * @param callback
     * @returns {BigNumber} address balance
     */
    Eth.prototype.queryAddressBalance = function (address, callback) {
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.recoveryBlockchainExplorerQuery({
                            module: 'account',
                            action: 'balance',
                            address: address
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new optionalDeps.ethUtil.BN(result.result, 10)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Query Etherscan for the balance of an address for a token
     * @param tokenContractAddress {String} address where the token smart contract is hosted
     * @param walletContractAddress {String} address of the wallet
     * @param callback
     * @returns {BigNumber} token balaance in base units
     */
    Eth.prototype.queryAddressTokenBalance = function (tokenContractAddress, walletContractAddress, callback) {
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!optionalDeps.ethUtil.isValidAddress(tokenContractAddress)) {
                            throw new Error('cannot get balance for invalid token address');
                        }
                        if (!optionalDeps.ethUtil.isValidAddress(walletContractAddress)) {
                            throw new Error('cannot get token balance for invalid wallet address');
                        }
                        return [4 /*yield*/, this.recoveryBlockchainExplorerQuery({
                                module: 'account',
                                action: 'tokenbalance',
                                contractaddress: tokenContractAddress,
                                address: walletContractAddress,
                                tag: 'latest'
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new optionalDeps.ethUtil.BN(result.result, 10)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Get transfer operation for coin
     * @param recipient recipient info
     * @param expireTime expiry time
     * @param contractSequenceId sequence id
     * @returns {Array} operation array
     */
    Eth.prototype.getOperation = function (recipient, expireTime, contractSequenceId) {
        return [
            ['string', 'address', 'uint', 'bytes', 'uint', 'uint'],
            [
                'ETHER',
                new optionalDeps.ethUtil.BN(optionalDeps.ethUtil.stripHexPrefix(recipient.address), 16),
                recipient.amount,
                new Buffer(optionalDeps.ethUtil.stripHexPrefix(recipient.data) || '', 'hex'),
                expireTime,
                contractSequenceId
            ]
        ];
    };
    Eth.prototype.getOperationSha3ForExecuteAndConfirm = function (recipients, expireTime, contractSequenceId) {
        var _a;
        if (!recipients || !Array.isArray(recipients)) {
            throw new Error('expecting array of recipients');
        }
        // Right now we only support 1 recipient
        if (recipients.length !== 1) {
            throw new Error('must send to exactly 1 recipient');
        }
        if (!_.isNumber(expireTime)) {
            throw new Error('expireTime must be number of seconds since epoch');
        }
        if (!_.isNumber(contractSequenceId)) {
            throw new Error('contractSequenceId must be number');
        }
        // Check inputs
        recipients.forEach(function (recipient) {
            if (!_.isString(recipient.address) || !optionalDeps.ethUtil.isValidAddress(optionalDeps.ethUtil.addHexPrefix(recipient.address))) {
                throw new Error('Invalid address: ' + recipient.address);
            }
            var amount;
            try {
                amount = new BigNumber(recipient.amount);
            }
            catch (e) {
                throw new Error('Invalid amount for: ' + recipient.address + ' - should be numeric');
            }
            recipient.amount = amount.toFixed(0);
            if (recipient.data && !_.isString(recipient.data)) {
                throw new Error('Data for recipient ' + recipient.address + ' - should be of type hex string');
            }
        });
        var recipient = recipients[0];
        return optionalDeps.ethUtil.bufferToHex((_a = optionalDeps.ethAbi).soliditySHA3.apply(_a, this.getOperation(recipient, expireTime, contractSequenceId)));
    };
    /**
     * Queries the contract (via Etherscan) for the next sequence ID
     * @param address {String} address of the contract
     * @param callback
     * @returns {Number} sequence ID
     */
    Eth.prototype.querySequenceId = function (address, callback) {
        return co(function () {
            var sequenceIdMethodSignature, sequenceIdArgs, sequenceIdData, result, sequenceIdHex;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sequenceIdMethodSignature = optionalDeps.ethAbi.methodID('getNextSequenceId', []);
                        sequenceIdArgs = optionalDeps.ethAbi.rawEncode([], []);
                        sequenceIdData = Buffer.concat([sequenceIdMethodSignature, sequenceIdArgs]).toString('hex');
                        return [4 /*yield*/, this.recoveryBlockchainExplorerQuery({
                                module: 'proxy',
                                action: 'eth_call',
                                to: address,
                                data: sequenceIdData,
                                tag: 'latest'
                            })];
                    case 1:
                        result = _a.sent();
                        sequenceIdHex = result.result;
                        return [2 /*return*/, new optionalDeps.ethUtil.BN(sequenceIdHex.slice(2), 16).toNumber()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Helper function for signTransaction for the rare case that SDK is doing the second signature
     * Note: we are expecting this to be called from the offline vault
     * @param params.txPrebuild
     * @param params.signingKeyNonce
     * @param params.walletContractAddress
     * @param params.prv
     * @returns {{txHex: *}}
     */
    Eth.prototype.signFinal = function (params) {
        var txPrebuild = params.txPrebuild;
        if (!_.isNumber(params.signingKeyNonce)) {
            throw new Error('must have signingKeyNonce as a parameter, and it must be a number');
        }
        if (_.isUndefined(params.walletContractAddress)) {
            throw new Error('params must include walletContractAddress, but got undefined');
        }
        var signingNode = utxoLib.HDNode.fromBase58(params.prv);
        var signingKey = signingNode.getKey().getPrivateKeyBuffer();
        var txInfo = {
            recipient: txPrebuild.recipients[0],
            expireTime: txPrebuild.halfSigned.expireTime,
            contractSequenceId: txPrebuild.halfSigned.contractSequenceId,
            signature: txPrebuild.halfSigned.signature
        };
        var sendMethodArgs = this.getSendMethodArgs(txInfo);
        var methodSignature = optionalDeps.ethAbi.methodID('sendMultiSig', _.map(sendMethodArgs, 'type'));
        var encodedArgs = optionalDeps.ethAbi.rawEncode(_.map(sendMethodArgs, 'type'), _.map(sendMethodArgs, 'value'));
        var sendData = Buffer.concat([methodSignature, encodedArgs]);
        var ethTxParams = {
            to: params.walletContractAddress,
            nonce: params.signingKeyNonce,
            value: 0,
            gasPrice: new optionalDeps.ethUtil.BN(txPrebuild.gasPrice),
            gasLimit: new optionalDeps.ethUtil.BN(txPrebuild.gasLimit),
            data: sendData,
            spendAmount: params.recipients[0].amount
        };
        var ethTx = new optionalDeps.EthTx(ethTxParams);
        ethTx.sign(signingKey);
        return { txHex: ethTx.serialize().toString('hex') };
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {{txHex}}
     */
    Eth.prototype.signTransaction = function (params) {
        var txPrebuild = params.txPrebuild;
        var userPrv = params.prv;
        var EXPIRETIME_DEFAULT = 60 * 60 * 24 * 7; // This signature will be valid for 1 week
        if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
            if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
            }
            throw new Error('missing txPrebuild parameter');
        }
        if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
            if (!_.isUndefined(userPrv) && !_.isString(userPrv)) {
                throw new Error("prv must be a string, got type " + typeof userPrv);
            }
            throw new Error('missing prv parameter to sign transaction');
        }
        params.recipients = params.recipients || txPrebuild.recipients;
        // if no recipients in either params or txPrebuild, then throw an error
        if (!params.recipients || !Array.isArray(params.recipients)) {
            throw new Error('recipients missing or not array');
        }
        // Normally the SDK provides the first signature for an ETH tx, but occasionally it provides the second and final one.
        if (params.isLastSignature) {
            // In this case when we're doing the second (final) signature, the logic is different.
            return this.signFinal(params);
        }
        var secondsSinceEpoch = Math.floor((new Date().getTime()) / 1000);
        var expireTime = params.expireTime || secondsSinceEpoch + EXPIRETIME_DEFAULT;
        var operationHash = this.getOperationSha3ForExecuteAndConfirm(params.recipients, expireTime, txPrebuild.nextContractSequenceId);
        var signature = Util.ethSignMsgHash(operationHash, Util.xprvToEthPrivateKey(userPrv));
        var txParams = {
            recipients: params.recipients,
            expireTime: expireTime,
            contractSequenceId: txPrebuild.nextContractSequenceId,
            sequenceId: params.sequenceId,
            operationHash: operationHash,
            signature: signature,
            gasLimit: params.gasLimit,
            gasPrice: params.gasPrice
        };
        return { halfSigned: txParams };
    };
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    Eth.prototype.preCreateBitGo = function (params) {
        // We always need params object, since either enterprise or newFeeAddress is required
        if (!_.isObject(params)) {
            throw new Error("preCreateBitGo must be passed a params object. Got " + params + " (type " + typeof params + ")");
        }
        if (_.isUndefined(params.enterprise) && _.isUndefined(params.newFeeAddress)) {
            throw new Error('expecting enterprise when adding BitGo key. If you want to create a new ETH bitgo key, set the newFeeAddress parameter to true.');
        }
        // Check whether key should be an enterprise key or a BitGo key for a new fee address
        if (!_.isUndefined(params.enterprise) && !_.isUndefined(params.newFeeAddress)) {
            throw new Error("Incompatible arguments - cannot pass both enterprise and newFeeAddress parameter.");
        }
        if (!_.isUndefined(params.enterprise) && !_.isString(params.enterprise)) {
            throw new Error("enterprise should be a string - got " + params.enterprise + " (type " + typeof params.enterprise + ")");
        }
        if (!_.isUndefined(params.newFeeAddress) && !_.isBoolean(params.newFeeAddress)) {
            throw new Error("newFeeAddress should be a boolean - got " + params.newFeeAddress + " (type " + typeof params.newFeeAddress + ")");
        }
    };
    /**
     * Queries public block explorer to get the next ETH nonce that should be used for the given ETH address
     * @param address
     * @param callback
     * @returns {*}
     */
    Eth.prototype.getAddressNonce = function (address, callback) {
        return co(function () {
            var nonce, result, backupKeyTxList, outgoingTxs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nonce = 0;
                        return [4 /*yield*/, this.recoveryBlockchainExplorerQuery({
                                module: 'account',
                                action: 'txlist',
                                address: address
                            })];
                    case 1:
                        result = _a.sent();
                        backupKeyTxList = result.result;
                        if (backupKeyTxList.length > 0) {
                            outgoingTxs = backupKeyTxList.filter(function (tx) { return tx.from === address; });
                            nonce = outgoingTxs.length;
                        }
                        return [2 /*return*/, nonce];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Helper function for recover()
     * This transforms the unsigned transaction information into a format the BitGo offline vault expects
     * @param txInfo
     * @param ethTx
     * @param userKey
     * @param backupKey
     * @returns {{tx: *, userKey: *, backupKey: *, coin: string, amount: string, gasPrice: string, gasLimit: string, recipients: ({address, amount}|{address: ({address, amount}|string), amount: string}|string)[]}}
     */
    Eth.prototype.formatForOfflineVault = function (txInfo, ethTx, userKey, backupKey, gasPrice, gasLimit, callback) {
        return co(function () {
            var backupHDNode, backupSigningKey, response, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        backupHDNode = utxoLib.HDNode.fromBase58(backupKey);
                        backupSigningKey = backupHDNode.getKey().getPublicKeyBuffer();
                        _a = {
                            tx: ethTx.serialize().toString('hex'),
                            userKey: userKey,
                            backupKey: backupKey,
                            coin: this.getChain(),
                            gasPrice: optionalDeps.ethUtil.bufferToInt(gasPrice).toFixed(),
                            gasLimit: gasLimit,
                            recipients: [
                                txInfo.recipient
                            ],
                            walletContractAddress: '0x' + ethTx.to.toString('hex'),
                            amount: txInfo.recipient.amount
                        };
                        return [4 /*yield*/, this.getAddressNonce("0x" + optionalDeps.ethUtil.publicToAddress(backupSigningKey, true).toString('hex'))];
                    case 1:
                        response = (_a.backupKeyNonce = _b.sent(),
                            _a);
                        _.extend(response, txInfo);
                        response.nextContractSequenceId = response.contractSequenceId;
                        return [2 /*return*/, response];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params.userKey {String} [encrypted] xprv
     * @param params.backupKey {String} [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param params.walletPassphrase {String} used to decrypt userKey and backupKey
     * @param params.walletContractAddress {String} the ETH address of the wallet contract
     * @param params.krsProvider {String} necessary if backup key is held by KRS
     * @param params.recoveryDestination {String} target address to send recovered funds to
     * @param callback
     */
    Eth.prototype.recover = function (params, callback) {
        return co(function recover() {
            var isKrsRecovery, isUnsignedSweep, userKey, backupKey, gasPrice, gasLimit, backupKeyAddress, backupSigningKey, backupHDNode, backupPrv, backupHDNode, backupKeyNonce, backupKeyBalance, txAmount, recipients, sequenceId, operationHash, signature, txInfo, sendMethodArgs, methodSignature, encodedArgs, sendData, tx, signedTx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (_.isUndefined(params.userKey)) {
                            throw new Error('missing userKey');
                        }
                        if (_.isUndefined(params.backupKey)) {
                            throw new Error('missing backupKey');
                        }
                        if (_.isUndefined(params.walletPassphrase) && !params.userKey.startsWith('xpub')) {
                            throw new Error('missing wallet passphrase');
                        }
                        if (_.isUndefined(params.walletContractAddress) || !this.isValidAddress(params.walletContractAddress)) {
                            throw new Error('invalid walletContractAddress');
                        }
                        if (_.isUndefined(params.recoveryDestination) || !this.isValidAddress(params.recoveryDestination)) {
                            throw new Error('invalid recoveryDestination');
                        }
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        if (isKrsRecovery && _.isUndefined(config.krsProviders[params.krsProvider])) {
                            throw new Error('unknown key recovery service provider');
                        }
                        userKey = params.userKey.replace(/\s/g, '');
                        backupKey = params.backupKey.replace(/\s/g, '');
                        gasPrice = this.getRecoveryGasPrice();
                        gasLimit = this.getRecoveryGasLimit();
                        // Decrypt private keys from KeyCard values if necessary
                        if (!userKey.startsWith('xpub') && !userKey.startsWith('xprv')) {
                            try {
                                userKey = this.bitgo.decrypt({
                                    input: userKey,
                                    password: params.walletPassphrase
                                });
                            }
                            catch (e) {
                                throw new Error("Error decrypting user keychain: " + e.message);
                            }
                        }
                        if (isKrsRecovery || isUnsignedSweep) {
                            backupHDNode = prova.HDNode.fromBase58(backupKey);
                            backupSigningKey = backupHDNode.getKey().getPublicKeyBuffer();
                            backupKeyAddress = "0x" + optionalDeps.ethUtil.publicToAddress(backupSigningKey, true).toString('hex');
                        }
                        else {
                            backupPrv = void 0;
                            try {
                                backupPrv = this.bitgo.decrypt({
                                    input: backupKey,
                                    password: params.walletPassphrase
                                });
                            }
                            catch (e) {
                                throw new Error("Error decrypting backup keychain: " + e.message);
                            }
                            backupHDNode = prova.HDNode.fromBase58(backupPrv);
                            backupSigningKey = backupHDNode.getKey().getPrivateKeyBuffer();
                            backupKeyAddress = "0x" + optionalDeps.ethUtil.privateToAddress(backupSigningKey).toString('hex');
                        }
                        return [4 /*yield*/, this.getAddressNonce(backupKeyAddress)];
                    case 1:
                        backupKeyNonce = _a.sent();
                        return [4 /*yield*/, this.queryAddressBalance(backupKeyAddress)];
                    case 2:
                        backupKeyBalance = _a.sent();
                        if (backupKeyBalance.lt(gasPrice.mul(gasLimit))) {
                            throw new Error("Backup key address " + backupKeyAddress + " has balance " + backupKeyBalance.toString(10) + ". This address must have a balance of at least 0.01 ETH to perform recoveries. Try sending some ETH to this address then retry.");
                        }
                        return [4 /*yield*/, this.queryAddressBalance(params.walletContractAddress)];
                    case 3:
                        txAmount = _a.sent();
                        recipients = [{
                                address: params.recoveryDestination,
                                amount: txAmount.toString(10)
                            }];
                        return [4 /*yield*/, this.querySequenceId(params.walletContractAddress)];
                    case 4:
                        sequenceId = _a.sent();
                        // Get operation hash and sign it
                        if (!isUnsignedSweep) {
                            operationHash = this.getOperationSha3ForExecuteAndConfirm(recipients, this.getDefaultExpireTime(), sequenceId);
                            signature = Util.ethSignMsgHash(operationHash, Util.xprvToEthPrivateKey(userKey));
                            try {
                                Util.ecRecoverEthAddress(operationHash, signature);
                            }
                            catch (e) {
                                throw new Error('Invalid signature');
                            }
                        }
                        txInfo = {
                            recipient: recipients[0],
                            expireTime: this.getDefaultExpireTime(),
                            contractSequenceId: sequenceId,
                            operationHash: operationHash,
                            signature: signature,
                            gasLimit: gasLimit.toString(10)
                        };
                        sendMethodArgs = this.getSendMethodArgs(txInfo);
                        methodSignature = optionalDeps.ethAbi.methodID('sendMultiSig', _.map(sendMethodArgs, 'type'));
                        encodedArgs = optionalDeps.ethAbi.rawEncode(_.map(sendMethodArgs, 'type'), _.map(sendMethodArgs, 'value'));
                        sendData = Buffer.concat([methodSignature, encodedArgs]);
                        tx = new optionalDeps.EthTx({
                            to: params.walletContractAddress,
                            nonce: backupKeyNonce,
                            value: 0,
                            gasPrice: gasPrice,
                            gasLimit: gasLimit,
                            data: sendData,
                            spendAmount: txAmount
                        });
                        if (isUnsignedSweep) {
                            return [2 /*return*/, this.formatForOfflineVault(txInfo, tx, userKey, backupKey, gasPrice, gasLimit)];
                        }
                        if (!isKrsRecovery) {
                            tx.sign(backupSigningKey);
                        }
                        signedTx = {
                            id: optionalDeps.ethUtil.bufferToHex(tx.hash(true)),
                            tx: tx.serialize().toString('hex'),
                        };
                        if (isKrsRecovery) {
                            signedTx.backupKey = backupKey;
                            signedTx.coin = this.getChain();
                        }
                        return [2 /*return*/, signedTx];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * This builds a half-signed transaction, for which there will be an admin route to co-sign and broadcast. Optionally
     * the user can set params.broadcast = true and the half-signed tx will be sent to BitGo for cosigning and broadcasting
     * @param params
     * @param params.wallet the wallet to recover the token from
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     * @param params.broadcast if true, we will automatically submit the half-signed tx to BitGo for cosigning and broadcasting
     */
    Eth.prototype.recoverToken = function (params, callback) {
        return co(function () {
            var walletContractAddress, recoveryAmount, sendMethodArgs, methodSignature, encodedArgs, sendData, broadcastParams, recipient, expireTime, _a, nextContractSequenceId, gasPrice, gasLimit, safeSequenceId, operationTypes, operationArgs, operationHash, userPrv, signature, txParams;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!_.isObject(params)) {
                            throw new Error("recoverToken must be passed a params object. Got " + params + " (type " + typeof params + ")");
                        }
                        if (_.isUndefined(params.tokenContractAddress) || !_.isString(params.tokenContractAddress)) {
                            throw new Error("tokenContractAddress must be a string, got " + params.tokenContractAddress + " (type " + typeof params.tokenContractAddress + ")");
                        }
                        if (!this.isValidAddress(params.tokenContractAddress)) {
                            throw new Error('tokenContractAddress not a valid address');
                        }
                        if (_.isUndefined(params.wallet) || !(params.wallet instanceof Wallet)) {
                            throw new Error("wallet must be a wallet instance, got " + params.wallet + " (type " + typeof params.wallet + ")");
                        }
                        if (_.isUndefined(params.recipient) || !_.isString(params.recipient)) {
                            throw new Error("recipient must be a string, got " + params.recipient + " (type " + typeof params.recipient + ")");
                        }
                        if (!this.isValidAddress(params.recipient)) {
                            throw new Error('recipient not a valid address');
                        }
                        if (!optionalDeps.ethUtil.bufferToHex || !optionalDeps.ethAbi.soliditySHA3) {
                            throw new Error('ethereum not fully supported in this environment');
                        }
                        walletContractAddress = params.wallet._wallet.coinSpecific.baseAddress;
                        return [4 /*yield*/, this.queryAddressTokenBalance(params.tokenContractAddress, walletContractAddress)];
                    case 1:
                        recoveryAmount = _b.sent();
                        if (!params.broadcast) return [3 /*break*/, 3];
                        sendMethodArgs = [
                            {
                                name: '_to',
                                type: 'address',
                                value: params.recipient
                            },
                            {
                                name: '_value',
                                type: 'uint256',
                                value: recoveryAmount.toString(10)
                            }
                        ];
                        methodSignature = optionalDeps.ethAbi.methodID('transfer', _.map(sendMethodArgs, 'type'));
                        encodedArgs = optionalDeps.ethAbi.rawEncode(_.map(sendMethodArgs, 'type'), _.map(sendMethodArgs, 'value'));
                        sendData = Buffer.concat([methodSignature, encodedArgs]);
                        broadcastParams = {
                            address: params.tokenContractAddress,
                            amount: '0',
                            data: sendData.toString('hex')
                        };
                        if (params.walletPassphrase) {
                            broadcastParams.walletPassphrase = params.walletPassphrase;
                        }
                        else if (params.prv) {
                            broadcastParams.prv = params.prv;
                        }
                        return [4 /*yield*/, params.wallet.send(broadcastParams)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        recipient = {
                            address: params.recipient,
                            amount: recoveryAmount.toString(10)
                        };
                        expireTime = Math.floor((new Date().getTime()) / 1000) + (60 * 60 * 24 * 7);
                        return [4 /*yield*/, params.wallet.prebuildTransaction({
                                recipients: [
                                    {
                                        address: params.recipient,
                                        amount: '1'
                                    }
                                ]
                            })];
                    case 4:
                        _a = _b.sent(), nextContractSequenceId = _a.nextContractSequenceId, gasPrice = _a.gasPrice, gasLimit = _a.gasLimit;
                        safeSequenceId = nextContractSequenceId + 1000;
                        operationTypes = ['string', 'address', 'uint', 'address', 'uint', 'uint'];
                        operationArgs = [
                            // "ERC20" has been added here so that ether operation hashes, signatures cannot be re-used for tokenSending
                            'ERC20',
                            new optionalDeps.ethUtil.BN(optionalDeps.ethUtil.stripHexPrefix(recipient.address), 16),
                            recipient.amount,
                            new optionalDeps.ethUtil.BN(optionalDeps.ethUtil.stripHexPrefix(params.tokenContractAddress), 16),
                            expireTime,
                            safeSequenceId
                        ];
                        operationHash = optionalDeps.ethUtil.bufferToHex(optionalDeps.ethAbi.soliditySHA3(operationTypes, operationArgs));
                        return [4 /*yield*/, params.wallet.getPrv({
                                prv: params.prv,
                                walletPassphrase: params.walletPassphrase
                            })];
                    case 5:
                        userPrv = _b.sent();
                        signature = Util.ethSignMsgHash(operationHash, Util.xprvToEthPrivateKey(userPrv));
                        txParams = {
                            recipient: recipient,
                            expireTime: expireTime,
                            contractSequenceId: safeSequenceId,
                            operationHash: operationHash,
                            signature: signature,
                            gasLimit: gasLimit,
                            gasPrice: gasPrice,
                            tokenContractAddress: params.tokenContractAddress,
                            walletId: params.wallet.id()
                        };
                        return [2 /*return*/, { halfSigned: txParams }];
                }
            });
        }).call(this).asCallback(callback);
    };
    Eth.prototype.getSendMethodArgs = function (txInfo) {
        // Method signature is
        // sendMultiSig(address toAddress, uint value, bytes data, uint expireTime, uint sequenceId, bytes signature)
        return [
            {
                name: 'toAddress',
                type: 'address',
                value: txInfo.recipient.address
            },
            {
                name: 'value',
                type: 'uint',
                value: txInfo.recipient.amount
            },
            {
                name: 'data',
                type: 'bytes',
                value: optionalDeps.ethUtil.toBuffer(txInfo.recipient.data || '')
            },
            {
                name: 'expireTime',
                type: 'uint',
                value: txInfo.expireTime
            },
            {
                name: 'sequenceId',
                type: 'uint',
                value: txInfo.contractSequenceId
            },
            {
                name: 'signature',
                type: 'bytes',
                value: optionalDeps.ethUtil.toBuffer(txInfo.signature)
            }
        ];
    };
    /**
     * Make a query to Etherscan for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @param callback
     * @returns {Object} response from Etherscan
     */
    Eth.prototype.recoveryBlockchainExplorerQuery = function (query, callback) {
        return co(function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, request.get(common.Environments[this.bitgo.env].etherscanBaseUrl + '/api')
                            .query(query)];
                    case 1:
                        response = _a.sent();
                        if (!response.ok) {
                            throw new Error('could not reach Etherscan');
                        }
                        return [2 /*return*/, response.body];
                }
            });
        }).call(this).asCallback(callback);
    };
    return Eth;
}(BaseCoin));
/**
 * Generate secp256k1 key pair
 *
 * @param seed
 * @returns {Object} object with generated pub and prv
 */
Eth.prototype.generateKeyPair = function (seed) {
    if (!seed) {
        // An extended private key has both a normal 256 bit private key and a 256
        // bit chain code, both of which must be random. 512 bits is therefore the
        // maximum entropy and gives us maximum security against cracking.
        seed = crypto.randomBytes(512 / 8);
    }
    var extendedKey = prova.HDNode.fromSeedBuffer(seed);
    var xpub = extendedKey.neutered().toBase58();
    return {
        pub: xpub,
        prv: extendedKey.toBase58()
    };
};
module.exports = Eth;
//# sourceMappingURL=eth.js.map