import BaseCoin = require('../baseCoin');
declare class AbstractUtxoCoin extends BaseCoin {
    readonly altScriptHash: any;
    readonly supportAltScriptDestination: any;
    private readonly _network;
    constructor(network: any);
    readonly network: any;
    static readonly validAddressTypes: any[];
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    getBaseFactor(): number;
    getCoinLibrary(): any;
    isValidAddress(address: any, forceAltScriptSupport?: boolean): boolean;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: any): boolean;
    getLatestBlockHeight(reqId: any, callback: any): any;
    postProcessPrebuild(prebuild: any, callback: any): any;
    /**
     * Find outputs that are within expected outputs but not within actual outputs, including duplicates
     * @param expectedOutputs
     * @param actualOutputs
     * @returns {Array}
     */
    static findMissingOutputs(expectedOutputs: any, actualOutputs: any): any;
    /**
     * Determine an address' type based on its witness and redeem script presence
     * @param addressDetails
     */
    static inferAddressType(addressDetails: any): any;
    /**
     * Extract and fill transaction details such as internal/change spend, external spend (explicit vs. implicit), etc.
     * @param txParams
     * @param txPrebuild
     * @param wallet
     * @param verification
     * @param callback
     * @returns {*}
     */
    parseTransaction({ txParams, txPrebuild, wallet, verification, reqId }: {
        txParams: any;
        txPrebuild: any;
        wallet: any;
        verification?: any;
        reqId: any;
    }, callback: any): any;
    /**
     * Verify that a transaction prebuild complies with the original intention
     * @param txParams params object passed to send
     * @param txPrebuild prebuild object returned by server
     * @param txPrebuild.txHex prebuilt transaction's txHex form
     * @param wallet Wallet object to obtain keys to verify against
     * @param verification Object specifying some verification parameters
     * @param verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param verification.keychains Pass keychains manually rather than fetching them by id
     * @param verification.addresses Address details to pass in for out-of-band verification
     * @param callback
     * @returns {boolean}
     */
    verifyTransaction({ txParams, txPrebuild, wallet, verification, reqId }: {
        txParams: any;
        txPrebuild: any;
        wallet: any;
        verification?: any;
        reqId: any;
    }, callback: any): any;
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param address The address string on the network
     * @param addressType
     * @param keychains Keychain objects with xpubs
     * @param coinSpecific Coin-specific details for the address such as a witness script
     * @param chain Derivation chain
     * @param index Derivation index
     */
    verifyAddress({ address, addressType, keychains, coinSpecific, chain, index }: {
        address: any;
        addressType: any;
        keychains: any;
        coinSpecific: any;
        chain: any;
        index: any;
    }): void;
    /**
     * Indicates whether coin supports a block target
     * @returns {boolean}
     */
    supportsBlockTarget(): boolean;
    /**
     * Indicates whether a coin supports wrapped segwit outputs
     * @returns {boolean}
     */
    supportsP2shP2wsh(): boolean;
    /**
     * Indicates whether a coin supports native segwit outputs
     * @returns {boolean}
     */
    supportsP2wsh(): boolean;
    /**
     * TODO(BG-11487): Remove addressType, segwit, and bech32 params in SDKv6
     * Generate an address for a wallet based on a set of configurations
     * @param addressType {string}   Deprecated
     * @param keychains   {[object]} Array of objects with xpubs
     * @param threshold   {number}   Minimum number of signatures
     * @param chain       {number}   Derivation chain (see https://github.com/BitGo/unspents/blob/master/src/codes.ts for
     *                                                 the corresponding address type of a given chain code)
     * @param index       {number}   Derivation index
     * @param segwit      {boolean}  Deprecated
     * @param bech32      {boolean}  Deprecated
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript, redeemScript}}}
     */
    generateAddress({ addressType, keychains, threshold, chain, index, segwit, bech32 }: {
        addressType: any;
        keychains: any;
        threshold: any;
        chain: any;
        index: any;
        segwit?: boolean;
        bech32?: boolean;
    }): any;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @param params.isLastSignature Ture if txb.build() should be called and not buildIncomplete()
     * @returns {{txHex}}
     */
    signTransaction(params: any): {
        txHex: any;
    };
    /**
     * Always false for coins other than BCH and TBCH.
     * @param unspent
     * @returns {boolean}
     */
    isBitGoTaintedUnspent(unspent: any): boolean;
    /**
     * Modify the transaction builder to comply with the specific coin's requirements such as version and branch id
     * @param txBuilder
     * @returns {*}
     */
    prepareTransactionBuilder(txBuilder: any): any;
    /**
     *
     * @returns {number}
     */
    readonly defaultSigHashType: any;
    /**
     * Parse a transaction's signature script to obtain public keys, signatures, the sig script, and other properties
     * @param transaction
     * @param inputIndex
     * @returns { isSegwitInput: boolean, inputClassification: string, signatures: [Buffer], publicKeys: [Buffer], pubScript: Buffer }
     */
    parseSignatureScript(transaction: any, inputIndex: any): {
        isSegwitInput: boolean;
        inputClassification: any;
        signatures: any;
        publicKeys: any;
        pubScript: any;
    } | {
        isSegwitInput: boolean;
        inputClassification: any;
        signatures?: undefined;
        publicKeys?: undefined;
        pubScript?: undefined;
    };
    /**
     * Calculate the hash to verify the signature against
     * @param transaction Transaction object
     * @param inputIndex
     * @param pubScript
     * @param amount The previous output's amount
     * @param hashType
     * @param isSegwitInput
     * @returns {*}
     */
    calculateSignatureHash(transaction: any, inputIndex: any, pubScript: any, amount: any, hashType: any, isSegwitInput: any): any;
    /**
     * Verify the signature on a (half-signed) transaction
     * @param transaction bitcoinjs-lib tx object
     * @param inputIndex The input whererfore to check the signature
     * @param amount For segwit and BCH, the input amount needs to be known for signature verification
     * @param verificationSettings
     * @param verificationSettings.signatureIndex The index of the signature to verify (only iterates over non-empty signatures)
     * @param verificationSettings.publicKey The hex of the public key to verify (will verify all signatures)
     * @returns {boolean}
     */
    verifySignature(transaction: any, inputIndex: any, amount: any, verificationSettings?: any): boolean;
    explainTransaction(params?: any): any;
    createMultiSigAddress(addressType: any, signatureThreshold: any, keys: any): {
        outputScript: any;
        redeemScript: any;
        witnessScript: any;
        address: any;
    };
    calculateRecoveryAddress(scriptHashScript: any): any;
    getRecoveryFeePerBytes(): any;
    getRecoveryFeeRecommendationApiBaseUrl(): any;
    getRecoveryMarketPrice(): any;
    /**
     * Helper function for recover()
     * This transforms the txInfo from recover into the format that offline-signing-tool expects
     * @param txInfo
     * @param txHex
     * @returns {{txHex: *, txInfo: {unspents: *}, feeInfo: {}, coin: void}}
     */
    formatForOfflineVault(txInfo: any, txHex: any): {
        txHex: any;
        txInfo: {
            unspents: any;
        };
        feeInfo: {};
        coin: void;
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] xprv, or xpub
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * - scan: the amount of consecutive addresses without unspents to scan through before stopping
     * - ignoreAddressTypes: (optional) array of AddressTypes to ignore, these are strings defined in Codes.UnspentTypeTcomb
     *        for example: ['p2shP2wsh', 'p2wsh'] will prevent code from checking for wrapped-segwit and native-segwit chains on the public block explorers
     * @param callback
     */
    recover(params: any, callback: any): any;
    /**
     * Apply signatures to a funds recovery transaction using user + backup key
     * @param txb {Object} a transaction builder object (with inputs and outputs)
     * @param unspents {Array} the unspents to use in the transaction
     * @param addresses {Array} the address and redeem script info for the unspents
     * @param cosign {Boolean} whether to cosign this transaction with the user's backup key (false if KRS recovery)
     */
    signRecoveryTransaction(txb: any, unspents: any, addresses: any, cosign: any): any;
    /**
     * Calculates the amount (in base units) to pay a KRS provider when building a recovery transaction
     * @param params
     * @param params.provider {String} the KRS provider that holds the backup key
     * @param params.amount {Number} amount (in base units) to be recovered
     * @param callback
     * @returns {*}
     */
    calculateFeeAmount(params: any, callback: any): any;
    /**
     * Recover BTC that was sent to the wrong chain
     * @param params
     * @param params.txid {String} The txid of the faulty transaction
     * @param params.recoveryAddress {String} address to send recovered funds to
     * @param params.wallet {Wallet} the wallet that received the funds
     * @param params.recoveryCoin {Coin} the coin type of the wallet that received the funds
     * @param params.signed {Boolean} return a half-signed transaction (default=true)
     * @param params.walletPassphrase {String} the wallet passphrase
     * @param params.xprv {String} the unencrypted xprv (used instead of wallet passphrase)
     * @param callback
     * @returns {*}
     */
    recoverFromWrongChain(params: any, callback: any): any;
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed: any): {
        pub: any;
        prv: any;
    };
}
export = AbstractUtxoCoin;
