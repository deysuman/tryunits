/// <reference types="node" />
declare const BaseCoin: any;
import * as Promise from 'bluebird';
interface AddressDetails {
    address: string;
    destinationTag: number;
}
interface FeeInfo {
    date: string;
    height: number;
    baseReserve: string;
    baseFee: string;
}
interface TransactionPrebuild {
    txHex: string;
}
interface SignTransactionOptions {
    txPrebuild: TransactionPrebuild;
    prv: string;
}
interface Output {
    address: string;
    amount: string;
}
interface TransactionFee {
    fee: number;
    feeRate?: number;
    size: number;
}
interface TransactionExplanation {
    displayOrder: string[];
    id: string;
    outputs: Output[];
    changeOutputs: Output[];
    outputAmount: string;
    changeAmount: number;
    fee: TransactionFee;
}
interface ExplainTransactionOptions {
    txHex: string;
}
interface VerifyTransactionOptions {
    txParams: any;
    txPrebuild: TransactionPrebuild;
}
interface VerifyAddressOptions {
    address: string;
    rootAddress: string;
}
interface RecoveryInfo extends TransactionExplanation {
    txHex: string;
    backupKey?: string;
    coin?: string;
}
interface RecoveryOptions {
    backupKey: string;
    userKey: string;
    rootAddress: string;
    recoveryDestination: string;
    bitgoKey: string;
    walletPassphrase: string;
    krsProvider: string;
}
interface KeyPair {
    pub: string;
    prv: string;
}
interface HalfSignedTransaction {
    halfSigned: {
        txHex: string;
    };
}
declare class Xrp extends BaseCoin {
    /**
     * Factor between the coin's base unit and its smallest subdivison
     */
    getBaseFactor(): number;
    /**
     * Identifier for the blockchain which supports this coin
     */
    getChain(): string;
    /**
     * Identifier for the coin family
     */
    getFamily(): string;
    /**
     * Complete human-readable name of this coin
     */
    getFullName(): string;
    /**
     * Parse an address string into address and destination tag
     */
    getAddressDetails(address: string): AddressDetails;
    /**
     * Construct a full, normalized address from an address and destination tag
     */
    normalizeAddress({ address, destinationTag }: {
        address: any;
        destinationTag: any;
    }): string;
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    isValidAddress(address: any): boolean;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Get fee info from server
     */
    getFeeInfo(_: any, callback: any): Promise<FeeInfo>;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {{txHex}}
     */
    signTransaction({ txPrebuild, prv }: SignTransactionOptions): HalfSignedTransaction;
    /**
     * Ripple requires additional parameters for wallet generation to be sent to the server. The additional parameters are
     * the root public key, which is the basis of the root address, two signed, and one half-signed initialization txs
     * @param walletParams
     * - rootPrivateKey: optional hex-encoded Ripple private key
     * @param keychains
     * @return {*|Request|Promise.<TResult>|{anyOf}}
     */
    supplementGenerateWallet(walletParams: any, keychains: any): Promise<any>;
    /**
     * Explain/parse transaction
     * @param params
     * - txHex: hexadecimal representation of transaction
     * @returns {{displayOrder: [string,string,string,string,string], id: *, outputs: Array, changeOutputs: Array}}
     */
    explainTransaction(params: ExplainTransactionOptions): TransactionExplanation;
    /**
     * Verify that a transaction prebuild complies with the original intention
     * @param txParams params object passed to send
     * @param txPrebuild prebuild object returned by server
     * @param wallet
     * @param callback
     * @returns {boolean}
     */
    verifyTransaction({ txParams, txPrebuild }: VerifyTransactionOptions, callback: any): Promise<boolean>;
    /**
     * Check if address is a valid XRP address, and then make sure the root addresses match.
     * This prevents attacks where an attack may switch out the new address for one of their own
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    verifyAddress({ address, rootAddress }: VerifyAddressOptions): void;
    /**
     * URL of a well-known, public facing (non-bitgo) rippled instance which can be used for recovery
     */
    getRippledUrl(): string;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - rootAddress: root XRP wallet address to recover funds from
     * - userKey: [encrypted] xprv
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * @param callback
     */
    recover(params: RecoveryOptions, callback: any): Promise<RecoveryInfo | string>;
    /**
     * Prepare and validate all keychains from the keycard for recovery
     */
    private initiateRecovery;
    /**
     * Generate a new keypair for this coin.
     * @param seed Seed from which the new keypair should be generated, otherwise a random seed is used
     */
    generateKeyPair(seed?: Buffer): KeyPair;
}
export = Xrp;
