"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var BaseCoin = require('../baseCoin');
var BigNumber = require('bignumber.js');
var crypto = require('crypto');
var ripple = require('../../ripple');
var rippleAddressCodec = require('ripple-address-codec');
var rippleBinaryCodec = require('ripple-binary-codec');
var rippleHashes = require('ripple-hashes');
var rippleKeypairs = require('ripple-keypairs');
var _ = require("lodash");
var Promise = require("bluebird");
var co = Promise.coroutine;
var sjcl = require('../../vendor/sjcl.min.js');
var config = require('../../config');
var url = require("url");
var querystring = require("querystring");
var errors_1 = require("../../errors");
var bitgo_utxo_lib_1 = require("bitgo-utxo-lib");
var prova = require('../../prova');
var Xrp = /** @class */ (function (_super) {
    __extends(Xrp, _super);
    function Xrp() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Factor between the coin's base unit and its smallest subdivison
     */
    Xrp.prototype.getBaseFactor = function () {
        return 1e6;
    };
    /**
     * Identifier for the blockchain which supports this coin
     */
    Xrp.prototype.getChain = function () {
        return 'xrp';
    };
    /**
     * Identifier for the coin family
     */
    Xrp.prototype.getFamily = function () {
        return 'xrp';
    };
    /**
     * Complete human-readable name of this coin
     */
    Xrp.prototype.getFullName = function () {
        return 'Ripple';
    };
    /**
     * Parse an address string into address and destination tag
     */
    Xrp.prototype.getAddressDetails = function (address) {
        var destinationDetails = url.parse(address);
        var queryDetails = querystring.parse(destinationDetails.query);
        var destinationAddress = destinationDetails.pathname;
        if (!rippleAddressCodec.isValidAddress(destinationAddress)) {
            throw new errors_1.InvalidAddressError("destination address \"" + destinationAddress + "\" is not valid");
        }
        // there are no other properties like destination tags
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                destinationTag: null
            };
        }
        if (!queryDetails.dt) {
            // if there are more properties, the query details need to contain the destination tag property.
            throw new errors_1.InvalidAddressError('destination tag missing');
        }
        if (Array.isArray(queryDetails.dt)) {
            // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
            throw new errors_1.InvalidAddressError("destination tag can appear at most once, but " + queryDetails.dt.length + " destination tags were found");
        }
        var parsedTag = parseInt(queryDetails.dt, 10);
        if (!Number.isSafeInteger(parsedTag)) {
            throw new errors_1.InvalidAddressError('invalid destination tag');
        }
        if (parsedTag > 0xFFFFFFFF || parsedTag < 0) {
            throw new errors_1.InvalidAddressError('destination tag out of range');
        }
        return {
            address: destinationAddress,
            destinationTag: parsedTag
        };
    };
    /**
     * Construct a full, normalized address from an address and destination tag
     */
    Xrp.prototype.normalizeAddress = function (_a) {
        var address = _a.address, destinationTag = _a.destinationTag;
        if (!_.isString(address)) {
            throw new errors_1.InvalidAddressError('invalid address details');
        }
        if (_.isInteger(destinationTag)) {
            return address + "?dt=" + destinationTag;
        }
        return address;
    };
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    Xrp.prototype.isValidAddress = function (address) {
        try {
            var addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Xrp.prototype.isValidPub = function (pub) {
        try {
            bitgo_utxo_lib_1.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Get fee info from server
     */
    Xrp.prototype.getFeeInfo = function (_, callback) {
        return this.bitgo.get(this.url('/public/feeinfo'))
            .result()
            .nodeify(callback);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {{txHex}}
     */
    Xrp.prototype.signTransaction = function (_a) {
        var txPrebuild = _a.txPrebuild, prv = _a.prv;
        if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
            if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
            }
            throw new Error('missing txPrebuild parameter');
        }
        if (_.isUndefined(prv) || !_.isString(prv)) {
            if (!_.isUndefined(prv) && !_.isString(prv)) {
                throw new Error("prv must be a string, got type " + typeof prv);
            }
            throw new Error('missing prv parameter to sign transaction');
        }
        var userKey = bitgo_utxo_lib_1.HDNode.fromBase58(prv).getKey();
        var userPrivateKey = userKey.getPrivateKeyBuffer();
        var userAddress = rippleKeypairs.deriveAddress(userKey.getPublicKeyBuffer().toString('hex'));
        var rippleLib = ripple();
        var halfSigned = rippleLib.signWithPrivateKey(txPrebuild.txHex, userPrivateKey.toString('hex'), { signAs: userAddress });
        return { halfSigned: { txHex: halfSigned.signedTransaction } };
    };
    /**
     * Ripple requires additional parameters for wallet generation to be sent to the server. The additional parameters are
     * the root public key, which is the basis of the root address, two signed, and one half-signed initialization txs
     * @param walletParams
     * - rootPrivateKey: optional hex-encoded Ripple private key
     * @param keychains
     * @return {*|Request|Promise.<TResult>|{anyOf}}
     */
    Xrp.prototype.supplementGenerateWallet = function (walletParams, keychains) {
        return co(function () {
            var userKeychain, backupKeychain, bitgoKeychain, userKey, userAddress, backupKey, backupAddress, bitgoKey, bitgoAddress, keyPair, rootPrivateKey, privateKey, publicKey, rootAddress, self, rippleLib, feeInfo, openLedgerFee, medianFee, fee, multisigAssignmentTx, signedMultisigAssignmentTx, destinationTagTx, signedDestinationTagTx, masterDeactivationTx, signedMasterDeactivationTx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userKeychain = keychains.userKeychain, backupKeychain = keychains.backupKeychain, bitgoKeychain = keychains.bitgoKeychain;
                        userKey = bitgo_utxo_lib_1.HDNode.fromBase58(userKeychain.pub).getKey();
                        userAddress = rippleKeypairs.deriveAddress(userKey.getPublicKeyBuffer().toString('hex'));
                        backupKey = bitgo_utxo_lib_1.HDNode.fromBase58(backupKeychain.pub).getKey();
                        backupAddress = rippleKeypairs.deriveAddress(backupKey.getPublicKeyBuffer().toString('hex'));
                        bitgoKey = bitgo_utxo_lib_1.HDNode.fromBase58(bitgoKeychain.pub).getKey();
                        bitgoAddress = rippleKeypairs.deriveAddress(bitgoKey.getPublicKeyBuffer().toString('hex'));
                        keyPair = bitgo_utxo_lib_1.ECPair.makeRandom();
                        if (walletParams.rootPrivateKey) {
                            rootPrivateKey = walletParams.rootPrivateKey;
                            if (typeof rootPrivateKey !== 'string' || rootPrivateKey.length !== 64) {
                                throw new Error('rootPrivateKey needs to be a hexadecimal private key string');
                            }
                            keyPair = prova.ECPair.fromPrivateKeyBuffer(Buffer.from(walletParams.rootPrivateKey, 'hex'));
                        }
                        privateKey = keyPair.getPrivateKeyBuffer();
                        publicKey = keyPair.getPublicKeyBuffer();
                        rootAddress = rippleKeypairs.deriveAddress(publicKey.toString('hex'));
                        self = this;
                        rippleLib = ripple();
                        return [4 /*yield*/, self.getFeeInfo()];
                    case 1:
                        feeInfo = _a.sent();
                        openLedgerFee = new BigNumber(feeInfo.xrpOpenLedgerFee);
                        medianFee = new BigNumber(feeInfo.xrpMedianFee);
                        fee = BigNumber.max(openLedgerFee, medianFee).times(1.5).toFixed(0);
                        multisigAssignmentTx = {
                            TransactionType: 'SignerListSet',
                            Account: rootAddress,
                            SignerQuorum: 2,
                            SignerEntries: [
                                {
                                    SignerEntry: {
                                        Account: userAddress,
                                        SignerWeight: 1
                                    }
                                },
                                {
                                    SignerEntry: {
                                        Account: backupAddress,
                                        SignerWeight: 1
                                    }
                                },
                                {
                                    SignerEntry: {
                                        Account: bitgoAddress,
                                        SignerWeight: 1
                                    }
                                }
                            ],
                            Flags: 2147483648,
                            // LastLedgerSequence: ledgerVersion + 10,
                            Fee: fee,
                            Sequence: 1
                        };
                        signedMultisigAssignmentTx = rippleLib.signWithPrivateKey(JSON.stringify(multisigAssignmentTx), privateKey.toString('hex'));
                        destinationTagTx = {
                            TransactionType: 'AccountSet',
                            Account: rootAddress,
                            SetFlag: 1,
                            Flags: 2147483648,
                            // LastLedgerSequence: ledgerVersion + 10,
                            Fee: fee,
                            Sequence: 2
                        };
                        signedDestinationTagTx = rippleLib.signWithPrivateKey(JSON.stringify(destinationTagTx), privateKey.toString('hex'));
                        masterDeactivationTx = {
                            TransactionType: 'AccountSet',
                            Account: rootAddress,
                            SetFlag: 4,
                            Flags: 2147483648,
                            // LastLedgerSequence: ledgerVersion + 10,
                            Fee: fee,
                            Sequence: 3
                        };
                        signedMasterDeactivationTx = rippleLib.signWithPrivateKey(JSON.stringify(masterDeactivationTx), privateKey.toString('hex'));
                        // extend the wallet initialization params
                        walletParams.rootPub = publicKey.toString('hex');
                        walletParams.initializationTxs = {
                            setMultisig: signedMultisigAssignmentTx.signedTransaction,
                            disableMasterKey: signedMasterDeactivationTx.signedTransaction,
                            forceDestinationTag: signedDestinationTagTx.signedTransaction
                        };
                        return [2 /*return*/, walletParams];
                }
            });
        }).call(this);
    };
    /**
     * Explain/parse transaction
     * @param params
     * - txHex: hexadecimal representation of transaction
     * @returns {{displayOrder: [string,string,string,string,string], id: *, outputs: Array, changeOutputs: Array}}
     */
    Xrp.prototype.explainTransaction = function (params) {
        var transaction;
        var txHex;
        try {
            transaction = rippleBinaryCodec.decode(params.txHex);
            txHex = params.txHex;
        }
        catch (e) {
            try {
                transaction = JSON.parse(params.txHex);
                txHex = rippleBinaryCodec.encode(transaction);
            }
            catch (e) {
                throw new Error('txHex needs to be either hex or JSON string for XRP');
            }
        }
        var id = rippleHashes.computeBinaryTransactionHash(txHex);
        var address = transaction.Destination + ((transaction.DestinationTag >= 0) ? '?dt=' + transaction.DestinationTag : '');
        return {
            displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'],
            id: id,
            changeOutputs: [],
            outputAmount: transaction.Amount,
            changeAmount: 0,
            outputs: [
                {
                    address: address,
                    amount: transaction.Amount
                }
            ],
            fee: {
                fee: transaction.Fee,
                feeRate: null,
                size: txHex.length / 2
            }
        };
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     * @param txParams params object passed to send
     * @param txPrebuild prebuild object returned by server
     * @param wallet
     * @param callback
     * @returns {boolean}
     */
    Xrp.prototype.verifyTransaction = function (_a, callback) {
        var txParams = _a.txParams, txPrebuild = _a.txPrebuild;
        return co(function () {
            var explanation, output, expectedOutput, comparator;
            return __generator(this, function (_a) {
                explanation = this.explainTransaction({
                    txHex: txPrebuild.txHex
                });
                output = explanation.outputs.concat(explanation.changeOutputs)[0];
                expectedOutput = txParams.recipients[0];
                comparator = function (recipient1, recipient2) {
                    if (recipient1.address !== recipient2.address) {
                        return false;
                    }
                    var amount1 = new BigNumber(recipient1.amount);
                    var amount2 = new BigNumber(recipient2.amount);
                    return amount1.toFixed() === amount2.toFixed();
                };
                if (!comparator(output, expectedOutput)) {
                    throw new Error('transaction prebuild does not match expected output');
                }
                return [2 /*return*/, true];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Check if address is a valid XRP address, and then make sure the root addresses match.
     * This prevents attacks where an attack may switch out the new address for one of their own
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    Xrp.prototype.verifyAddress = function (_a) {
        var address = _a.address, rootAddress = _a.rootAddress;
        if (!this.isValidAddress(address)) {
            throw new errors_1.InvalidAddressError("address verification failure: address \"" + address + "\" is not valid");
        }
        var addressDetails = this.getAddressDetails(address);
        var rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.address !== rootAddressDetails.address) {
            throw new errors_1.UnexpectedAddressError("address validation failure: " + addressDetails.address + " vs. " + rootAddressDetails.address);
        }
    };
    /**
     * URL of a well-known, public facing (non-bitgo) rippled instance which can be used for recovery
     */
    Xrp.prototype.getRippledUrl = function () {
        return 'https://s1.ripple.com:51234';
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - rootAddress: root XRP wallet address to recover funds from
     * - userKey: [encrypted] xprv
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * @param callback
     */
    Xrp.prototype.recover = function (params, callback) {
        var rippledUrl = this.getRippledUrl();
        var self = this;
        var isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
        var isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
        return this.initiateRecovery(params)
            .then(function (keys) {
            var addressDetailsPromise = self.bitgo.post(rippledUrl)
                .send({
                method: 'account_info',
                params: [{
                        account: params.rootAddress,
                        strict: true,
                        ledger_index: 'current',
                        queue: true,
                        signer_lists: true
                    }]
            });
            var feeDetailsPromise = self.bitgo.post(rippledUrl).send({ method: 'fee' });
            var serverDetailsPromise = self.bitgo.post(rippledUrl).send({ method: 'server_info' });
            return [addressDetailsPromise, feeDetailsPromise, serverDetailsPromise, keys];
        })
            .spread(function (addressDetails, feeDetails, serverDetails, keys) {
            var openLedgerFee = new BigNumber(feeDetails.body.result.drops.open_ledger_fee);
            var baseReserve = new BigNumber(serverDetails.body.result.info.validated_ledger.reserve_base_xrp).times(self.getBaseFactor());
            var reserveDelta = new BigNumber(serverDetails.body.result.info.validated_ledger.reserve_inc_xrp).times(self.getBaseFactor());
            var currentLedger = serverDetails.body.result.info.validated_ledger.seq;
            var sequenceId = addressDetails.body.result.account_data.Sequence;
            var balance = new BigNumber(addressDetails.body.result.account_data.Balance);
            var signerLists = addressDetails.body.result.account_data.signer_lists;
            var accountFlags = addressDetails.body.result.account_data.Flags;
            // make sure there is only one signer list set
            if (signerLists.length !== 1) {
                throw new Error('unexpected set of signer lists');
            }
            // make sure the signers are user, backup, bitgo
            var userAddress = rippleKeypairs.deriveAddress(keys[0].getPublicKeyBuffer().toString('hex'));
            var backupAddress = rippleKeypairs.deriveAddress(keys[1].getPublicKeyBuffer().toString('hex'));
            var signerList = signerLists[0];
            if (signerList.SignerQuorum !== 2) {
                throw new Error('invalid minimum signature count');
            }
            var foundAddresses = {};
            var signerEntries = signerList.SignerEntries;
            if (signerEntries.length !== 3) {
                throw new Error('invalid signer list length');
            }
            for (var _i = 0, signerEntries_1 = signerEntries; _i < signerEntries_1.length; _i++) {
                var SignerEntry = signerEntries_1[_i].SignerEntry;
                var weight = SignerEntry.SignerWeight;
                var address = SignerEntry.Account;
                if (weight !== 1) {
                    throw new Error('invalid signer weight');
                }
                // if it's a dupe of an address we already know, block
                if (foundAddresses[address] >= 1) {
                    throw new Error('duplicate signer address');
                }
                foundAddresses[address] = (foundAddresses[address] || 0) + 1;
            }
            if (foundAddresses[userAddress] !== 1) {
                throw new Error('unexpected incidence frequency of user signer address');
            }
            if (foundAddresses[backupAddress] !== 1) {
                throw new Error('unexpected incidence frequency of user signer address');
            }
            // make sure the flags disable the master key and enforce destination tags
            var USER_KEY_SETTING_FLAG = 65536;
            var MASTER_KEY_DEACTIVATION_FLAG = 1048576;
            var REQUIRE_DESTINATION_TAG_FLAG = 131072;
            if ((accountFlags & USER_KEY_SETTING_FLAG) !== 0) {
                throw new Error('a custom user key has been set');
            }
            if ((accountFlags & MASTER_KEY_DEACTIVATION_FLAG) !== MASTER_KEY_DEACTIVATION_FLAG) {
                throw new Error('the master key has not been deactivated');
            }
            if ((accountFlags & REQUIRE_DESTINATION_TAG_FLAG) !== REQUIRE_DESTINATION_TAG_FLAG) {
                throw new Error('the destination flag requirement has not been activated');
            }
            // recover the funds
            var reserve = baseReserve.plus(reserveDelta.times(5));
            var recoverableBalance = balance.minus(reserve);
            var rawDestination = params.recoveryDestination;
            var destinationDetails = url.parse(rawDestination);
            var queryDetails = querystring.parse(destinationDetails.query);
            var destinationAddress = destinationDetails.pathname;
            var destinationTag = undefined;
            if (Array.isArray(queryDetails.dt)) {
                // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
                throw new errors_1.InvalidAddressError("destination tag can appear at most once, but " + queryDetails.dt.length + " destination tags were found");
            }
            var parsedTag = parseInt(queryDetails.dt, 10);
            if (Number.isInteger(parsedTag)) {
                destinationTag = parsedTag;
            }
            var transaction = {
                TransactionType: 'Payment',
                Account: params.rootAddress,
                Destination: destinationAddress,
                DestinationTag: destinationTag,
                Amount: recoverableBalance.toFixed(0),
                Flags: 2147483648,
                LastLedgerSequence: currentLedger + 1000000,
                Fee: openLedgerFee.times(3).toFixed(0),
                Sequence: sequenceId
            };
            var txJSON = JSON.stringify(transaction);
            if (isUnsignedSweep) {
                return txJSON;
            }
            var rippleLib = ripple();
            var userKey = keys[0].getKey().getPrivateKeyBuffer().toString('hex');
            var userSignature = rippleLib.signWithPrivateKey(txJSON, userKey, { signAs: userAddress });
            var signedTransaction;
            if (isKrsRecovery) {
                signedTransaction = userSignature;
            }
            else {
                var backupKey = keys[1].getKey().getPrivateKeyBuffer().toString('hex');
                var backupSignature = rippleLib.signWithPrivateKey(txJSON, backupKey, { signAs: backupAddress });
                signedTransaction = rippleLib.combine([userSignature.signedTransaction, backupSignature.signedTransaction]);
            }
            var transactionExplanation = self.explainTransaction({ txHex: signedTransaction.signedTransaction });
            transactionExplanation.txHex = signedTransaction.signedTransaction;
            if (isKrsRecovery) {
                transactionExplanation.backupKey = params.backupKey;
                transactionExplanation.coin = self.getChain();
            }
            return transactionExplanation;
        })
            .nodeify(callback);
    };
    /**
     * Prepare and validate all keychains from the keycard for recovery
     */
    Xrp.prototype.initiateRecovery = function (params) {
        return co(function initiateRecovery() {
            var keys, userKey, backupKey, bitgoXpub, destinationAddress, passphrase, isKrsRecovery, isUnsignedSweep, validatePassphraseKey, key, backupHDNode, bitgoHDNode;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keys = [];
                        userKey = params.userKey;
                        backupKey = params.backupKey;
                        bitgoXpub = params.bitgoKey;
                        destinationAddress = params.recoveryDestination;
                        passphrase = params.walletPassphrase;
                        isKrsRecovery = backupKey.startsWith('xpub') && !userKey.startsWith('xpub');
                        isUnsignedSweep = backupKey.startsWith('xpub') && userKey.startsWith('xpub');
                        if (isKrsRecovery && _.isUndefined(config.krsProviders[params.krsProvider])) {
                            throw new Error('unknown key recovery service provider');
                        }
                        validatePassphraseKey = function (userKey, passphrase) {
                            try {
                                if (!userKey.startsWith('xprv') && !isUnsignedSweep) {
                                    userKey = sjcl.decrypt(passphrase, userKey);
                                }
                                var userHDNode = bitgo_utxo_lib_1.HDNode.fromBase58(userKey);
                                return Promise.resolve(userHDNode);
                            }
                            catch (e) {
                                throw new Error('Failed to decrypt user key with passcode - try again!');
                            }
                        };
                        return [4 /*yield*/, validatePassphraseKey(userKey, passphrase)];
                    case 1:
                        key = _a.sent();
                        keys.push(key);
                        // Validate the backup key
                        try {
                            if (!backupKey.startsWith('xprv') && !isKrsRecovery && !isUnsignedSweep) {
                                backupKey = sjcl.decrypt(passphrase, backupKey);
                            }
                            backupHDNode = bitgo_utxo_lib_1.HDNode.fromBase58(backupKey);
                            keys.push(backupHDNode);
                        }
                        catch (e) {
                            throw new Error('Failed to decrypt backup key with passcode - try again!');
                        }
                        try {
                            bitgoHDNode = bitgo_utxo_lib_1.HDNode.fromBase58(bitgoXpub);
                            keys.push(bitgoHDNode);
                        }
                        catch (e) {
                            if (this.getFamily() !== 'xrp') {
                                // in XRP recoveries, the BitGo xpub is optional
                                throw new Error('Failed to parse bitgo xpub!');
                            }
                        }
                        // Validate the destination address
                        if (!this.isValidAddress(destinationAddress)) {
                            throw new Error('Invalid destination address!');
                        }
                        return [2 /*return*/, keys];
                }
            });
        }).call(this);
    };
    /**
     * Generate a new keypair for this coin.
     * @param seed Seed from which the new keypair should be generated, otherwise a random seed is used
     */
    Xrp.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto.randomBytes(512 / 8);
        }
        var extendedKey = bitgo_utxo_lib_1.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58()
        };
    };
    return Xrp;
}(BaseCoin));
module.exports = Xrp;
//# sourceMappingURL=xrp.js.map