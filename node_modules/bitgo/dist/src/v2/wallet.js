"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var common = require("../common");
var BigNumber = require('bignumber.js');
var bitcoin = require('../bitcoin');
var PendingApproval = require('./pendingApproval');
var Promise = require("bluebird");
var co = Promise.coroutine;
var _ = require("lodash");
var debug = require('debug')('bitgo:v2:wallet');
var internal = require('./internal');
var util = require('../util');
var Wallet = function (bitgo, baseCoin, walletData) {
    this.bitgo = bitgo;
    this.baseCoin = baseCoin;
    this._wallet = walletData;
    var userId = _.get(bitgo, '_user.id');
    if (_.isString(userId)) {
        var userDetails = _.find(walletData.users, { user: userId });
        this._permissions = _.get(userDetails, 'permissions');
    }
};
Wallet.prototype.url = function (extra) {
    extra = extra || '';
    return this.baseCoin.url('/wallet/' + this.id() + extra);
};
Wallet.prototype.id = function () {
    return this._wallet.id;
};
Wallet.prototype.approvalsRequired = function () {
    return this._wallet.approvalsRequired;
};
Wallet.prototype.balance = function () {
    return this._wallet.balance;
};
Wallet.prototype.confirmedBalance = function () {
    return this._wallet.confirmedBalance;
};
Wallet.prototype.spendableBalance = function () {
    return this._wallet.spendableBalance;
};
Wallet.prototype.balanceString = function () {
    return this._wallet.balanceString;
};
Wallet.prototype.confirmedBalanceString = function () {
    return this._wallet.confirmedBalanceString;
};
Wallet.prototype.spendableBalanceString = function () {
    return this._wallet.spendableBalanceString;
};
Wallet.prototype.coin = function () {
    return this._wallet.coin;
};
Wallet.prototype.label = function () {
    return this._wallet.label;
};
Wallet.prototype.keyIds = function () {
    return this._wallet.keys;
};
Wallet.prototype.receiveAddress = function () {
    return this._wallet.receiveAddress.address;
};
/**
 * Return the token flush thresholds for this wallet
 * @return {*|Object} pairs of { [tokenName]: thresholds } base units
 */
Wallet.prototype.tokenFlushThresholds = function () {
    if (this.baseCoin.getFamily() !== 'eth') {
        throw new Error('not supported for this wallet');
    }
    return this._wallet.coinSpecific.tokenFlushThresholds;
};
Wallet.prototype.pendingApprovals = function () {
    var self = this;
    return this._wallet.pendingApprovals.map(function (currentApproval) {
        return new PendingApproval(self.bitgo, self.baseCoin, currentApproval, self);
    });
};
/**
 * Refresh the wallet object by syncing with the back-end
 * @param callback
 * @returns {Wallet}
 */
Wallet.prototype.refresh = function (params, callback) {
    return co(function () {
        var res;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, this.bitgo.get(this.url()).result()];
                case 1:
                    res = _a.sent();
                    this._wallet = res;
                    return [2 /*return*/, this];
            }
        });
    }).call(this).asCallback(callback);
};
/**
 * List the transactions for a given wallet
 * @param params
 * @param callback
 * @returns {*}
 */
Wallet.prototype.transactions = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var query = {};
    if (params.prevId) {
        if (!_.isString(params.prevId)) {
            throw new Error('invalid prevId argument, expecting string');
        }
        query.prevId = params.prevId;
    }
    if (params.limit) {
        if (!_.isNumber(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        query.limit = params.limit;
    }
    return this.bitgo.get(this.baseCoin.url('/wallet/' + this._wallet.id + '/tx'))
        .query(query)
        .result()
        .nodeify(callback);
};
/**
 * List the transactions for a given wallet
 * @param params
 *  - txHash the transaction hash to search for
 * @param callback
 * @returns {*}
 */
Wallet.prototype.getTransaction = function getTransaction(params, callback) {
    params = params || {};
    common.validateParams(params, ['txHash'], [], callback);
    var query = {};
    if (!_.isUndefined(params.prevId)) {
        if (!_.isString(params.prevId)) {
            throw new Error('invalid prevId argument, expecting string');
        }
        query.prevId = params.prevId;
    }
    if (!_.isUndefined(params.limit)) {
        if (!_.isInteger(params.limit) || params.limit < 1) {
            throw new Error('invalid limit argument, expecting positive integer');
        }
        query.limit = params.limit;
    }
    return this.bitgo.get(this.url('/tx/' + params.txHash))
        .query(query)
        .result()
        .nodeify(callback);
};
/**
 * List the transfers for a given wallet
 * @param params
 * @param callback
 * @returns {*}
 */
Wallet.prototype.transfers = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var query = {};
    if (params.prevId) {
        if (!_.isString(params.prevId)) {
            throw new Error('invalid prevId argument, expecting string');
        }
        query.prevId = params.prevId;
    }
    if (params.limit) {
        if (!_.isNumber(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        query.limit = params.limit;
    }
    if (params.allTokens) {
        if (!_.isBoolean(params.allTokens)) {
            throw new Error('invalid allTokens argument, expecting boolean');
        }
        query.allTokens = params.allTokens;
    }
    if (params.searchLabel) {
        if (!_.isString(params.searchLabel)) {
            throw new Error('invalid searchLabel argument, expecting string');
        }
        query.searchLabel = params.searchLabel;
    }
    if (params.address) {
        if (!_.isArray(params.address) && !_.isString(params.address)) {
            throw new Error('invalid address argument, expecting string or array');
        }
        if (_.isArray(params.address)) {
            params.address.forEach(function (address) {
                if (!_.isString(address)) {
                    throw new Error('invalid address argument, expecting array of address strings');
                }
            });
        }
        query.address = params.address;
    }
    if (params.dateGte) {
        if (!_.isString(params.dateGte)) {
            throw new Error('invalid dateGte argument, expecting string');
        }
        query.dateGte = params.dateGte;
    }
    if (params.dateLt) {
        if (!_.isString(params.dateLt)) {
            throw new Error('invalid dateLt argument, expecting string');
        }
        query.dateLt = params.dateLt;
    }
    if (!_.isNil(params.valueGte)) {
        if (!_.isNumber(params.valueGte)) {
            throw new Error('invalid valueGte argument, expecting number');
        }
        query.valueGte = params.valueGte;
    }
    if (!_.isNil(params.valueLt)) {
        if (!_.isNumber(params.valueLt)) {
            throw new Error('invalid valueLt argument, expecting number');
        }
        query.valueLt = params.valueLt;
    }
    return this.bitgo.get(this.url('/transfer'))
        .query(query)
        .result()
        .nodeify(callback);
};
Wallet.prototype.getTransfer = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    return this.bitgo.get(this.url('/transfer/' + params.id))
        .result()
        .nodeify(callback);
};
// Get a transaction by sequence id for a given wallet
Wallet.prototype.transferBySequenceId = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['sequenceId'], [], callback);
    return this.bitgo.get(this.url('/transfer/sequenceId/' + params.sequenceId))
        .result()
        .nodeify(callback);
};
/**
 * Get the maximum amount you can spend in a single transaction
 *
 * @param {Object} params - parameters object
 * @param {Number} params.limit - maximum number of selectable unspents
 * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
 * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
 * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
 * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
 * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
 * @param {Number} params.feeRate - fee rate to use in calculation of maximum spendable in satoshis/kB
 * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
 * @param {String} params.recipientAddress - recipient addresses for a more accurate calculation of the maximum available to send
 * @param callback
 * @returns {{maximumSpendable: Number, coin: String}}
 * NOTE : feeTxConfirmTarget omitted on purpose because gauging the maximum spendable amount with dynamic fees does not make sense
 */
Wallet.prototype.maximumSpendable = function maximumSpendable(params, callback) {
    return co(function () {
        var filteredParams;
        return __generator(this, function (_a) {
            params = params || {};
            filteredParams = _.pick(params, [
                'minValue', 'maxValue', 'minHeight', 'target', 'plainTarget', 'limit', 'minConfirms',
                'enforceMinConfirmsForChange', 'feeRate', 'maxFeeRate', 'recipientAddress'
            ]);
            return [2 /*return*/, this.bitgo.get(this.url('/maximumSpendable'))
                    .query(filteredParams)
                    .result()];
        });
    }).call(this).asCallback(callback);
};
/**
 * List the unspents for a given wallet
 * @param params
 * @param callback
 * @returns {*}
 */
Wallet.prototype.unspents = function (params, callback) {
    params = params || {};
    var query = _.pick(params, ['prevId', 'limit', 'minValue', 'maxValue', 'minHeight', 'minConfirms', 'target', 'segwit', 'chains']);
    return this.bitgo.get(this.url('/unspents'))
        .query(query)
        .result()
        .nodeify(callback);
};
/**
 * Consolidate unspents on a wallet
 *
 * @param {Object} params - parameters object
 * @param {String} params.walletPassphrase - the users wallet passphrase
 * @param {String} params.prevId - used in batch requests
 * @param {Number} params.limit - the number of unspents retrieved per call
 * @param {Number} params.minValue - the minimum value of unspents to use in satoshis/kB
 * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis/kB
 * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
 * @param {Number} params.targetUnspentPoolSize - the number of unspents you want after the consolidation of valid unspents
 * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
 * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
 * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
 * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
 * @param callback
 * @returns txHex {String} the txHex of the incomplete transaction that needs to be signed by the user in the SDK
 */
Wallet.prototype.consolidateUnspents = function consolidateUnspents(params, callback) {
    return co(function () {
        var reqId, keychain, filteredParams, response, transactionParams, signedTransaction, selectParams, finalTxParams;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    params = params || {};
                    common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
                    reqId = util.createRequestId();
                    return [4 /*yield*/, this.baseCoin.keychains().get({ id: this._wallet.keys[0], reqId: reqId })];
                case 1:
                    keychain = _a.sent();
                    filteredParams = _.pick(params, ['minValue', 'maxValue', 'minHeight', 'numUnspentsToMake', 'feeTxConfirmTarget', 'limit', 'minConfirms', 'enforceMinConfirmsForChange', 'feeRate', 'maxFeeRate', 'maxFeePercentage']);
                    this.bitgo._reqId = reqId;
                    return [4 /*yield*/, this.bitgo.post(this.url('/consolidateUnspents'))
                            .send(filteredParams)
                            .result()];
                case 2:
                    response = _a.sent();
                    transactionParams = _.extend({}, params, { txPrebuild: response, keychain: keychain });
                    return [4 /*yield*/, this.signTransaction(transactionParams)];
                case 3:
                    signedTransaction = _a.sent();
                    selectParams = _.pick(params, ['comment', 'otp']);
                    finalTxParams = _.extend({}, signedTransaction, selectParams);
                    this.bitgo._reqId = reqId;
                    return [2 /*return*/, this.bitgo.post(this.baseCoin.url('/wallet/' + this._wallet.id + '/tx/send'))
                            .send(finalTxParams)
                            .result()];
            }
        });
    }).call(this).asCallback(callback);
};
/**
 * Fanout unspents for a wallet
 *
 * @param {Object} params - parameters object
 * @param {String} params.walletPassphrase - the users wallet passphrase
 * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
 * @param {Number} params.minValue - the minimum value of unspents to use
 * @param {Number} params.maxValue - the maximum value of unspents to use
 * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
 * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
 * @param {Number} params.maxFeePercentage - the maximum proportion of an unspent you are willing to lose to fees
 * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
 * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
 * @param {Number} params.maxFeeRate - The max limit for a fee rate in satoshis/kB
 * @param {Number} params.maxNumInputsToUse - the number of unspents you want to use in the transaction
 * @param {Number} params.numUnspentsToMake - the number of new unspents to make
 * @param callback
 * @returns txHex {String} the txHex of the incomplete transaction that needs to be signed by the user in the SDK
 */
Wallet.prototype.fanoutUnspents = function fanoutUnspents(params, callback) {
    return co(function () {
        var filteredParams, reqId, response, keychain, transactionParams, signedTransaction, selectParams, finalTxParams;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    params = params || {};
                    common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
                    filteredParams = _.pick(params, ['minValue', 'maxValue', 'minHeight', 'maxNumInputsToUse', 'numUnspentsToMake', 'minConfirms', 'enforceMinConfirmsForChange', 'feeRate', 'maxFeeRate', 'maxFeePercentage', 'feeTxConfirmTarget']);
                    reqId = util.createRequestId();
                    this.bitgo._reqId = reqId;
                    return [4 /*yield*/, this.bitgo.post(this.url('/fanoutUnspents'))
                            .send(filteredParams)
                            .result()];
                case 1:
                    response = _a.sent();
                    return [4 /*yield*/, this.baseCoin.keychains().get({ id: this._wallet.keys[0], reqId: reqId })];
                case 2:
                    keychain = _a.sent();
                    transactionParams = _.extend({}, params, { txPrebuild: response, keychain: keychain, prv: params.xprv });
                    return [4 /*yield*/, this.signTransaction(transactionParams)];
                case 3:
                    signedTransaction = _a.sent();
                    selectParams = _.pick(params, ['comment', 'otp']);
                    finalTxParams = _.extend({}, signedTransaction, selectParams);
                    this.bitgo._reqId = reqId;
                    return [2 /*return*/, this.bitgo.post(this.baseCoin.url('/wallet/' + this._wallet.id + '/tx/send'))
                            .send(finalTxParams)
                            .result()];
            }
        });
    }).call(this).asCallback(callback);
};
/**
 * Set the token flush thresholds for the wallet. Updates the wallet.
 * Tokens will only be flushed from forwarder contracts if the balance is greater than the threshold defined here.
 * @param thresholds {Object} - pairs of { [tokenName]: threshold } (base units)
 * @param [callback]
 */
Wallet.prototype.updateTokenFlushThresholds = function (thresholds, callback) {
    return co(function () {
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (this.baseCoin.getFamily() !== 'eth') {
                        throw new Error('not supported for this wallet');
                    }
                    _a = this;
                    return [4 /*yield*/, this.bitgo.put(this.url()).send({
                            tokenFlushThresholds: thresholds
                        }).result()];
                case 1:
                    _a._wallet = _b.sent();
                    return [2 /*return*/];
            }
        });
    }).call(this).asCallback(callback);
};
/**
 * Sweep funds for a wallet
 *
 * @param {Object} params - parameters object
 * @param {String} params.address - The address to send all the funds in the wallet to
 * @param {String} params.walletPassphrase - the users wallet passphrase
 * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
 * @param {String} params.otp - Two factor auth code to enable sending the transaction
 * @param {Number} params.feeTxConfirmTarget - Estimate the fees to aim for first confirmation within this number of blocks
 * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
 * @param {Number} [params.maxFeeRate] - upper limit for feeRate in satoshis/kB
 * @param [callback]
 * @returns txHex {String} the txHex of the signed transaction
 */
Wallet.prototype.sweep = function sweep(params, callback) {
    return co(function () {
        var value, reqId, filteredParams, response, keychain, transactionParams, signedTransaction, selectParams, finalTxParams;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    params = params || {};
                    common.validateParams(params, ['address'], ['walletPassphrase', 'xprv', 'otp'], callback);
                    if (['eth', 'xrp'].includes(this.baseCoin.getFamily())) {
                        if (this.confirmedBalanceString() !== this.balanceString()) {
                            throw new Error('cannot sweep when unconfirmed funds exist on the wallet, please wait until all inbound transactions confirm');
                        }
                        value = this.spendableBalanceString();
                        if (!value || value === '0') {
                            throw new Error('no funds to sweep');
                        }
                        params.recipients = [{
                                address: params.address,
                                amount: value
                            }];
                        return [2 /*return*/, this.sendMany(params)];
                    }
                    reqId = util.createRequestId();
                    filteredParams = _.pick(params, ['address', 'feeRate', 'maxFeeRate', 'feeTxConfirmTarget']);
                    this.bitgo._reqId = reqId;
                    return [4 /*yield*/, this.bitgo.post(this.url('/sweepWallet'))
                            .send(filteredParams)
                            .result()];
                case 1:
                    response = _a.sent();
                    return [4 /*yield*/, this.baseCoin.keychains().get({ id: this._wallet.keys[0], reqId: reqId })];
                case 2:
                    keychain = _a.sent();
                    transactionParams = _.extend({}, params, { txPrebuild: response, keychain: keychain, prv: params.xprv });
                    return [4 /*yield*/, this.signTransaction(transactionParams)];
                case 3:
                    signedTransaction = _a.sent();
                    selectParams = _.pick(params, ['otp']);
                    finalTxParams = _.extend({}, signedTransaction, selectParams);
                    this.bitgo._reqId = reqId;
                    return [2 /*return*/, this.bitgo.post(this.baseCoin.url('/wallet/' + this._wallet.id + '/tx/send'))
                            .send(finalTxParams)
                            .result()];
            }
        });
    }).call(this).asCallback(callback);
};
/**
 * Freeze a given wallet
 * @param params
 * @param callback
 * @returns {*}
 */
Wallet.prototype.freeze = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (params.duration) {
        if (!_.isNumber(params.duration)) {
            throw new Error('invalid duration: should be number of seconds');
        }
    }
    return this.bitgo.post(this.url('/freeze'))
        .result()
        .nodeify(callback);
};
/**
 * Update comment of a transfer
 * @param params
 * @param callback
 * @returns {*}
 */
Wallet.prototype.transferComment = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], ['comment'], callback);
    return this.bitgo.post(this.baseCoin.url('/wallet/' + this._wallet.id + '/transfer/' + params.id + '/comment'))
        .send(params)
        .result()
        .nodeify(callback);
};
/**
 * List the addresses for a given wallet
 * @param params
 * @param callback
 * @returns {*}
 */
Wallet.prototype.addresses = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var query = {};
    if (params.mine) {
        query.mine = !!params.mine;
    }
    if (!_.isUndefined(params.prevId)) {
        if (!_.isString(params.prevId)) {
            throw new Error('invalid prevId argument, expecting string');
        }
        query.prevId = params.prevId;
    }
    if (params.sort) {
        if (!_.isNumber(params.sort)) {
            throw new Error('invalid sort argument, expecting number');
        }
        query.sort = params.sort;
    }
    if (params.limit) {
        if (!_.isNumber(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        query.limit = params.limit;
    }
    if (params.labelContains) {
        if (!_.isString(params.labelContains)) {
            throw new Error('invalid labelContains argument, expecting string');
        }
        query.labelContains = params.labelContains;
    }
    if (!_.isUndefined(params.segwit)) {
        if (!_.isBoolean(params.segwit)) {
            throw new Error('invalid segwit argument, expecting boolean');
        }
        query.segwit = params.segwit;
    }
    if (!_.isUndefined(params.chains)) {
        if (!_.isArray(params.chains)) {
            throw new Error('invalid chains argument, expecting array of numbers');
        }
        query.chains = params.chains;
    }
    return this.bitgo.get(this.baseCoin.url('/wallet/' + this._wallet.id + '/addresses'))
        .query(query)
        .result()
        .nodeify(callback);
};
/**
 * Get a single wallet address by its id
 * @param params
 * @param callback
 * @returns {*}
 */
Wallet.prototype.getAddress = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['address', 'id'], callback);
    var query;
    if (!params.address && !params.id) {
        throw new Error('address or id of address required');
    }
    if (params.address) {
        query = params.address;
    }
    else {
        query = params.id;
    }
    if (params.reqId) {
        this.bitgo._reqId = params.reqId;
    }
    return this.bitgo.get(this.baseCoin.url("/wallet/" + this._wallet.id + "/address/" + encodeURIComponent(query)))
        .result()
        .nodeify(callback);
};
/**
 * Create one or more new address(es) for use with this wallet.
 *
 * If the `count` field is defined and greater than 1, an object with a single
 * array property named `addresses` containing `count` address objects
 * will be returned. Otherwise, a single address object is returned.
 *
 * @param {Number} [chain] on which the new address should be created
 * @param {(Number|String)} [gasPrice] gas price for new address creation, if applicable
 * @param {String} [label] label for the new address(es)
 * @param {Number} [count=1] number of new addresses which should be created (maximum 250)
 * @param {Boolean} [lowPriority] Ethereum-specific param to create address using low priority fee address
 * @param callback
 */
Wallet.prototype.createAddress = function (_a, callback) {
    var _b = _a === void 0 ? {} : _a, _c = _b.chain, chain = _c === void 0 ? undefined : _c, _d = _b.gasPrice, gasPrice = _d === void 0 ? undefined : _d, _e = _b.count, count = _e === void 0 ? 1 : _e, _f = _b.label, label = _f === void 0 ? undefined : _f, _g = _b.lowPriority, lowPriority = _g === void 0 ? undefined : _g;
    return co(function createAddress() {
        var addressParams, reqId, keychains, rootAddress, newAddresses, _a;
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    addressParams = {};
                    reqId = util.createRequestId();
                    if (!_.isUndefined(chain)) {
                        if (!_.isInteger(chain)) {
                            throw new Error('chain has to be an integer');
                        }
                        addressParams.chain = chain;
                    }
                    if (!_.isUndefined(gasPrice)) {
                        if (!_.isInteger(gasPrice) && (isNaN(Number(gasPrice)) || !_.isString(gasPrice))) {
                            throw new Error('gasPrice has to be an integer or numeric string');
                        }
                        addressParams.gasPrice = gasPrice;
                    }
                    if (!_.isUndefined(label)) {
                        if (!_.isString(label)) {
                            throw new Error('label has to be a string');
                        }
                        addressParams.label = label;
                    }
                    if (!_.isInteger(count) || count <= 0 || count > 250) {
                        throw new Error('count has to be a number between 1 and 250');
                    }
                    if (!_.isUndefined(lowPriority)) {
                        if (!_.isBoolean(lowPriority)) {
                            throw new Error('lowPriority has to be a boolean');
                        }
                        addressParams.lowPriority = lowPriority;
                    }
                    return [4 /*yield*/, Promise.map(this._wallet.keys, function (k) { return _this.baseCoin.keychains().get({ id: k, reqId: reqId }); })];
                case 1:
                    keychains = _b.sent();
                    rootAddress = _.get(this._wallet, 'receiveAddress.address');
                    newAddresses = _.times(count, co(function createAndVerifyAddress() {
                        var newAddress, verificationData;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.bitgo._reqId = reqId;
                                    return [4 /*yield*/, this.bitgo.post(this.baseCoin.url('/wallet/' + this._wallet.id + '/address'))
                                            .send(addressParams)
                                            .result()];
                                case 1:
                                    newAddress = _a.sent();
                                    // infer its address type
                                    if (_.isObject(newAddress.coinSpecific) && _.isFunction(this.baseCoin.constructor.inferAddressType)) {
                                        newAddress.addressType = this.baseCoin.constructor.inferAddressType(newAddress);
                                    }
                                    newAddress.keychains = keychains;
                                    verificationData = _.merge({}, newAddress, { rootAddress: rootAddress });
                                    this.baseCoin.verifyAddress(verificationData);
                                    return [2 /*return*/, newAddress];
                            }
                        });
                    }).bind(this));
                    if (newAddresses.length === 1) {
                        return [2 /*return*/, newAddresses[0]];
                    }
                    _a = {};
                    return [4 /*yield*/, Promise.all(newAddresses)];
                case 2: return [2 /*return*/, (_a.addresses = _b.sent(),
                        _a)];
            }
        });
    }).call(this).asCallback(callback);
};
/**
 *
 * @param params
 * @param callback
 * @returns {*}
 */
Wallet.prototype.updateAddress = function (params, callback) {
    return co(function gUpdateAddress() {
        var address, putParams, url;
        return __generator(this, function (_a) {
            address = params.address;
            putParams = _.pick(params, ['label']);
            url = this.url('/address/' + encodeURIComponent(address));
            return [2 /*return*/, this.bitgo.put(url).send(putParams).result()];
        });
    }).call(this).asCallback(callback);
};
Wallet.prototype.listWebhooks = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var query = {};
    if (params.prevId) {
        if (!_.isString(params.prevId)) {
            throw new Error('invalid prevId argument, expecting string');
        }
        query.prevId = params.prevId;
    }
    if (params.limit) {
        if (!_.isNumber(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        query.limit = params.limit;
    }
    return this.bitgo.get(this.url('/webhooks'))
        .query(query)
        .result()
        .nodeify(callback);
};
/**
 * Simulate wallet webhook, currently for webhooks of type transfer and pending approval
 * @param params
 * - webhookId (required) id of the webhook to be simulated
 * - transferId (optional but required for transfer webhooks) id of the simulated transfer
 * - pendingApprovalId (optional but required for pending approval webhooks) id of the simulated pending approval
 * @param callback
 * @returns {*}
 */
Wallet.prototype.simulateWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['webhookId'], ['transferId', 'pendingApprovalId'], callback);
    var hasTransferId = !!params.transferId;
    var hasPendingApprovalId = !!params.pendingApprovalId;
    if (!hasTransferId && !hasPendingApprovalId) {
        throw new Error('must supply either transferId or pendingApprovalId');
    }
    if (hasTransferId && hasPendingApprovalId) {
        throw new Error('must supply either transferId or pendingApprovalId, but not both');
    }
    // depending on the coin type of the wallet, the txHash has to adhere to its respective format
    // but the server takes care of that
    // only take the transferId and pendingApprovalId properties
    var filteredParams = _.pick(params, ['transferId', 'pendingApprovalId']);
    var webhookId = params.webhookId;
    return this.bitgo.post(this.url('/webhooks/' + webhookId + '/simulate'))
        .send(filteredParams)
        .result()
        .nodeify(callback);
};
Wallet.prototype.addWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['url', 'type'], [], callback);
    return this.bitgo.post(this.url('/webhooks'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.removeWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['url', 'type'], [], callback);
    return this.bitgo.del(this.url('/webhooks'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// Key chains
// Gets the user key chain for this wallet
// The user key chain is typically the first keychain of the wallet and has the encrypted prv stored on BitGo.
// Useful when trying to get the users' keychain from the server before decrypting to sign a transaction.
Wallet.prototype.getEncryptedUserKeychain = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var self = this;
    var tryKeyChain = function (index) {
        if (!self._wallet.keys || index >= self._wallet.keys.length) {
            return self.bitgo.reject('No encrypted keychains on this wallet.', callback);
        }
        var params = { id: self._wallet.keys[index] };
        return self.baseCoin.keychains().get(params)
            .then(function (keychain) {
            // If we find the prv, then this is probably the user keychain we're looking for
            if (keychain.encryptedPrv) {
                return keychain;
            }
            return tryKeyChain(index + 1);
        });
    };
    return tryKeyChain(0).nodeify(callback);
};
// Key chains
// Gets the unencrypted private key for this wallet (be careful!)
// Requires wallet passphrase
Wallet.prototype.getPrv = function (params, callback) {
    return co(function () {
        var userKeychain, userEncryptedPrv, userPrv;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    common.validateParams(params, [], ['walletPassphrase', 'prv'], callback);
                    // Prepare signing key
                    if (_.isUndefined(params.prv) && _.isUndefined(params.walletPassphrase)) {
                        throw new Error('must either provide prv or wallet passphrase');
                    }
                    if (!_.isUndefined(params.prv) && !_.isString(params.prv)) {
                        throw new Error('prv must be a string');
                    }
                    if (!_.isUndefined(params.walletPassphrase) && !_.isString(params.walletPassphrase)) {
                        throw new Error('walletPassphrase must be a string');
                    }
                    if (params.prv) {
                        return [2 /*return*/, params.prv];
                    }
                    return [4 /*yield*/, this.getEncryptedUserKeychain()];
                case 1:
                    userKeychain = _a.sent();
                    userEncryptedPrv = userKeychain.encryptedPrv;
                    try {
                        userPrv = this.bitgo.decrypt({ input: userEncryptedPrv, password: params.walletPassphrase });
                    }
                    catch (e) {
                        throw new Error('error decrypting wallet passphrase');
                    }
                    return [2 /*return*/, userPrv];
            }
        });
    }).call(this).asCallback(callback);
};
//
// createShare
// share the wallet with an existing BitGo user.
// Parameters:
//   user - the recipient, must have a corresponding user record in our database
//   keychain - the keychain to be shared with the recipient
//   permissions - the recipient's permissions if the share is accepted
// Returns:
//
Wallet.prototype.createShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['user', 'permissions'], [], callback);
    if (params.keychain && !_.isEmpty(params.keychain)) {
        if (!params.keychain.pub || !params.keychain.encryptedPrv || !params.keychain.fromPubKey || !params.keychain.toPubKey || !params.keychain.path) {
            throw new Error('requires keychain parameters - pub, encryptedPrv, fromPubKey, toPubKey, path');
        }
    }
    return this.bitgo.post(this.url('/share'))
        .send(params)
        .result()
        .nodeify(callback);
};
/**
 *
 * @param params
 * @param callback
 * @returns {*}
 */
Wallet.prototype.shareWallet = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['email', 'permissions'], ['walletPassphrase', 'message'], callback);
    if (params.reshare !== undefined && !_.isBoolean(params.reshare)) {
        throw new Error('Expected reshare to be a boolean.');
    }
    if (params.skipKeychain !== undefined && !_.isBoolean(params.skipKeychain)) {
        throw new Error('Expected skipKeychain to be a boolean. ');
    }
    var needsKeychain = !params.skipKeychain && params.permissions.indexOf('spend') !== -1;
    if (params.disableEmail !== undefined && !_.isBoolean(params.disableEmail)) {
        throw new Error('Expected disableEmail to be a boolean.');
    }
    var self = this;
    var sharing;
    var sharedKeychain;
    return this.bitgo.getSharingKey({ email: params.email.toLowerCase() })
        .then(function (result) {
        sharing = result;
        if (needsKeychain) {
            return self.getEncryptedUserKeychain({})
                .then(function (keychain) {
                // Decrypt the user key with a passphrase
                if (keychain.encryptedPrv) {
                    if (!params.walletPassphrase) {
                        throw new Error('Missing walletPassphrase argument');
                    }
                    try {
                        keychain.prv = self.bitgo.decrypt({ password: params.walletPassphrase, input: keychain.encryptedPrv });
                    }
                    catch (e) {
                        throw new Error('Unable to decrypt user keychain');
                    }
                    var eckey = bitcoin.makeRandomKey();
                    var secret = self.bitgo.getECDHSecret({ eckey: eckey, otherPubKeyHex: sharing.pubkey });
                    var newEncryptedPrv = self.bitgo.encrypt({ password: secret, input: keychain.prv });
                    sharedKeychain = {
                        pub: keychain.pub,
                        encryptedPrv: newEncryptedPrv,
                        fromPubKey: eckey.getPublicKeyBuffer().toString('hex'),
                        toPubKey: sharing.pubkey,
                        path: sharing.path
                    };
                }
            });
        }
    })
        .then(function () {
        var options = {
            user: sharing.userId,
            permissions: params.permissions,
            reshare: params.reshare,
            message: params.message,
            disableEmail: params.disableEmail
        };
        if (sharedKeychain) {
            options.keychain = sharedKeychain;
        }
        else if (params.skipKeychain) {
            options.keychain = {};
        }
        return self.createShare(options);
    })
        .nodeify(callback);
};
/**
 * Remove user from wallet
 * @param params
 * - userId Id of the user to remove
 * @param callback
 * @return {*}
 */
Wallet.prototype.removeUser = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['userId'], [], callback);
    var userId = params.userId;
    return this.bitgo.del(this.url('/user/' + userId))
        .result()
        .nodeify(callback);
};
/**
 *
 * @param {Object} params
 * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
 * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
 * @param {Number} params.feeRate - the desired feeRate for the transaction in base units/kB
 * @param {Number} params.maxFeeRate - upper limit for feeRate in base units/kB
 * @param {Number} params.minConfirms - Minimum number of confirmations unspents going into this transaction should have
 * @param {Boolean} params.enforceMinConfirmsForChange - Enforce minimum number of confirmations on change (internal) inputs.
 * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet. If the wallet’s current unspent count is lower than the target, up to four additional change outputs will be added to the transaction.
 * @param {Number} params.minValue - Ignore unspents smaller than this amount of base units
 * @param {Number} params.maxValue - Ignore unspents larger than this amount of base units
 * @param {Number} params.sequenceId - The sequence ID of the transaction
 * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
 * @param {String} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
 * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
 * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
 * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
 * @param {String} params.changeAddress - Specifies the destination of the change output
 * @param {Boolean} params.instant - Build this transaction to conform with instant sending coin-specific method (if available)
 * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
 * @param {String} params.addressType - The type of address to create for change. One of `p2sh`, `p2shP2wsh`, and `p2wsh`. Case-sensitive.
 * @param callback
 * @returns {*}
 */
Wallet.prototype.prebuildTransaction = function (params, callback) {
    return co(function () {
        var whitelistedParams, buildQuery, blockHeightQuery, queries, _a, buildResponse, blockHeight, prebuild;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    whitelistedParams = _.pick(params, [
                        'recipients', 'numBlocks', 'feeRate', 'maxFeeRate', 'minConfirms', 'enforceMinConfirmsForChange',
                        'targetWalletUnspents', 'message', 'minValue', 'maxValue', 'sequenceId', 'lastLedgerSequence',
                        'ledgerSequenceDelta', 'gasPrice', 'noSplitChange', 'unspents', 'changeAddress', 'instant', 'memo', 'addressType',
                        'cpfpTxIds', 'cpfpFeeRate', 'maxFee', 'idfVersion', 'idfSignedTimestamp', 'idfUserId', 'strategy'
                    ]);
                    debug('prebuilding transaction: %O', whitelistedParams);
                    if (params.reqId) {
                        this.bitgo._reqId = params.reqId;
                    }
                    buildQuery = this.bitgo.post(this.baseCoin.url('/wallet/' + this.id() + '/tx/build'))
                        .send(whitelistedParams)
                        .result();
                    blockHeightQuery = this.baseCoin.getLatestBlockHeight ? this.baseCoin.getLatestBlockHeight(params.reqId) : Promise.resolve(undefined);
                    queries = [buildQuery, blockHeightQuery];
                    return [4 /*yield*/, Promise.all(queries)];
                case 1:
                    _a = _b.sent(), buildResponse = _a[0], blockHeight = _a[1];
                    debug('postprocessing transaction prebuild: %O', buildResponse);
                    if (!_.isUndefined(blockHeight)) {
                        buildResponse.blockHeight = blockHeight;
                    }
                    return [4 /*yield*/, this.baseCoin.postProcessPrebuild(buildResponse)];
                case 2:
                    prebuild = _b.sent();
                    prebuild = _.extend({}, prebuild, { walletId: this.id() });
                    debug('final transaction prebuild: %O', prebuild);
                    return [2 /*return*/, prebuild];
            }
        });
    }).call(this).asCallback(callback);
};
/**
 * Sign a transaction
 * @param params
 * - txPrebuild
 * - [keychain / key] (object) or prv (string)
 * - walletPassphrase
 * @param callback
 * @return {*}
 */
Wallet.prototype.signTransaction = function (params, callback) {
    var userKeychain = params.keychain || params.key;
    var txPrebuild = params.txPrebuild;
    if (!txPrebuild || typeof txPrebuild !== 'object') {
        throw new Error('txPrebuild must be an object');
    }
    var userPrv = params.prv;
    if (userPrv && typeof userPrv !== 'string') {
        throw new Error('prv must be a string');
    }
    if (userPrv && params.coldDerivationSeed) {
        // the derivation only makes sense when a key already exists
        var derivation = this.baseCoin.deriveKeyWithSeed({ key: userPrv, seed: params.coldDerivationSeed });
        userPrv = derivation.key;
    }
    else if (!userPrv) {
        if (!userKeychain || typeof userKeychain !== 'object') {
            throw new Error('keychain must be an object');
        }
        var userEncryptedPrv = userKeychain.encryptedPrv;
        if (!userEncryptedPrv) {
            throw new Error('keychain does not have property encryptedPrv');
        }
        if (!params.walletPassphrase) {
            throw new Error('walletPassphrase property missing');
        }
        userPrv = this.bitgo.decrypt({ input: userEncryptedPrv, password: params.walletPassphrase });
    }
    var self = this;
    return Promise.try(function () {
        var signingParams = _.extend({}, params, { txPrebuild: txPrebuild, prv: userPrv });
        return self.baseCoin.signTransaction(signingParams);
    })
        .nodeify(callback);
};
Wallet.prototype.prebuildAndSignTransaction = function (params, callback) {
    return co(function () {
        var error, error, error, txPrebuildQuery, userKeychainQuery, _a, txPrebuild, userKeychain, verificationParams, e_1, signingParams, error_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    params = params || {};
                    if (params.prebuildTx && params.recipients) {
                        error = new Error('Only one of prebuildTx and recipients may be specified');
                        error.code = 'both_prebuildtx_and_recipients_specified';
                        throw error;
                    }
                    if (params.recipients && !Array.isArray(params.recipients)) {
                        error = new Error('expecting recipients array');
                        error.code = 'recipients_not_array';
                        throw error;
                    }
                    if (_.isArray(this._permissions) && !this._permissions.includes('spend')) {
                        error = new Error('no spend permission on this wallet');
                        error.code = 'user_not_allowed_to_spend_from_wallet';
                        throw error;
                    }
                    txPrebuildQuery = params.prebuildTx ? Promise.resolve(params.prebuildTx) : this.prebuildTransaction(params);
                    userKeychainQuery = this.baseCoin.keychains().get({ id: this._wallet.keys[0], reqId: params.reqId });
                    return [4 /*yield*/, Promise.all([txPrebuildQuery, userKeychainQuery])];
                case 1:
                    _a = _b.sent(), txPrebuild = _a[0], userKeychain = _a[1];
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 4, , 5]);
                    verificationParams = _.pick(params.verification || {}, ['disableNetworking', 'keychains', 'addresses']);
                    return [4 /*yield*/, this.baseCoin.verifyTransaction({ txParams: params, txPrebuild: txPrebuild, wallet: this, verification: verificationParams, reqId: params.reqId })];
                case 3:
                    _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    e_1 = _b.sent();
                    debug('Transaction prebuild failure:', e_1);
                    console.error('transaction prebuild failed local validation:');
                    throw e_1;
                case 5:
                    signingParams = _.extend({}, params, { txPrebuild: txPrebuild, keychain: userKeychain });
                    _b.label = 6;
                case 6:
                    _b.trys.push([6, 8, , 9]);
                    return [4 /*yield*/, this.signTransaction(signingParams)];
                case 7: return [2 /*return*/, _b.sent()];
                case 8:
                    error_1 = _b.sent();
                    if (error_1.message.includes('insufficient funds')) {
                        error_1.code = 'insufficient_funds';
                        error_1.walletBalances = {
                            balanceString: this.balanceString(),
                            confirmedBalanceString: this.confirmedBalanceString(),
                            spendableBalanceString: this.spendableBalanceString(),
                            balance: this.balance(),
                            confirmedBalance: this.confirmedBalance(),
                            spendableBalance: this.spendableBalance()
                        };
                        error_1.txParams = _.omit(params, ['keychain', 'prv', 'passphrase', 'walletPassphrase', 'key']);
                    }
                    throw error_1;
                case 9: return [2 /*return*/];
            }
        });
    }).call(this).asCallback(callback);
};
Wallet.prototype.accelerateTransaction = function (params, callback) {
    return co(function () {
        var error, error, error, error, error, submitParams, _a, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    // TODO(BG-9349): change the last check to > 0 and the error message once platform allows multiple transactions to
                    //                be bumped in the same CPFP transaction
                    if (_.isUndefined(params.cpfpTxIds) || !Array.isArray(params.cpfpTxIds) || params.cpfpTxIds.length !== 1) {
                        error = new Error('expecting cpfpTxIds to be an array of length 1');
                        error.code = 'cpfptxids_not_array';
                        throw error;
                    }
                    if (_.isUndefined(params.cpfpFeeRate)) {
                        if (params.noCpfpFeeRate !== true) {
                            error = new Error('cpfpFeeRate must be set unless noCpfpFeeRate is set');
                            error.code = 'cpfpfeerate_not_set';
                            throw error;
                        }
                    }
                    else {
                        if (!_.isInteger(params.cpfpFeeRate) || params.cpfpFeeRate < 0) {
                            error = new Error('cpfpFeeRate must be a non-negative integer');
                            error.code = 'cpfpfeerate_not_nonnegative_integer';
                            throw error;
                        }
                    }
                    if (_.isUndefined(params.maxFee)) {
                        if (params.noMaxFee !== true) {
                            error = new Error('maxFee must be set unless noMaxFee is set');
                            error.code = 'maxfee_not_set';
                            throw error;
                        }
                    }
                    else {
                        if (!_.isInteger(params.maxFee) || params.maxFee < 0) {
                            error = new Error('maxFee must be a non-negative integer');
                            error.code = 'maxfee_not_nonnegative_integer';
                            throw error;
                        }
                    }
                    if (params.recipients !== undefined) {
                        if (!Array.isArray(params.recipients) || params.recipients.length !== 0) {
                            throw new Error("invalid value for 'recipients': must be empty array when set");
                        }
                    }
                    params.recipients = [];
                    _b = (_a = Object).assign;
                    _c = [params];
                    return [4 /*yield*/, this.prebuildAndSignTransaction(params)];
                case 1:
                    submitParams = _b.apply(_a, _c.concat([_d.sent()]));
                    return [4 /*yield*/, this.submitTransaction(submitParams)];
                case 2: return [2 /*return*/, _d.sent()];
            }
        });
    }).call(this).asCallback(callback);
};
/**
 * Submits a half-signed transaction to BitGo
 * @param params
 * - txHex: transaction hex to submit
 * - halfSigned: object containing transaction (txHex or txBase64) to submit
 * @param callback
 */
Wallet.prototype.submitTransaction = function (params, callback) {
    common.validateParams(params, [], ['otp', 'txHex'], callback);
    var hasTxHex = !!params.txHex;
    var hasHalfSigned = !!params.halfSigned;
    if ((hasTxHex && hasHalfSigned) || (!hasTxHex && !hasHalfSigned)) {
        throw new Error('must supply either txHex or halfSigned, but not both');
    }
    return this.bitgo.post(this.baseCoin.url('/wallet/' + this.id() + '/tx/send'))
        .send(params)
        .result()
        .nodeify(callback);
};
/**
 * Send coins to a recipient
 * @param params
 * @param params.address - the destination address
 * @param params.amount - the amount in satoshis/wei/base value to be sent
 * @param params.message - optional message to attach to transaction
 * @param params.data - [Ethereum Specific] optional data to pass to transaction
 * @param params.walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
 * @param params.prv - the private key in string form, if walletPassphrase is not available
 * @param params.minConfirms - the minimum confirmation threshold for inputs
 * @param params.enforceMinConfirmsForChange - whether to enforce minConfirms for change inputs
 * @param callback
 * @returns {*}
 */
Wallet.prototype.send = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address'], ['message', 'data'], callback);
    var coin = this.baseCoin;
    var amount = new BigNumber(params.amount);
    if (amount.isNegative()) {
        throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
    }
    if (!coin.valuelessTransferAllowed() && amount.isZero()) {
        throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
    }
    params.recipients = [{
            address: params.address,
            amount: params.amount
        }];
    if (params.data && coin.transactionDataAllowed()) {
        params.recipients[0].data = params.data;
    }
    return this.sendMany(params)
        .nodeify(callback);
};
/**
 * Send money to multiple recipients
 * 1. Gets the user keychain by checking the wallet for a key which has an encrypted prv
 * 2. Decrypts user key
 * 3. Creates the transaction with default fee
 * 4. Signs transaction with decrypted user key
 * 5. Sends the transaction to BitGo
 * @param {object} params
 * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
 * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
 * @param {Number} params.feeRate - the desired feeRate for the transaction in satothis/kB
 * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
 * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
 * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
 * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet
 * @param {String} params.message - optional message to attach to transaction
 * @param {Number} params.minValue - Ignore unspents smaller than this amount of satoshis
 * @param {Number} params.maxValue - Ignore unspents larger than this amount of satoshis
 * @param {Number} params.sequenceId - The sequence ID of the transaction
 * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
 * @param {String} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
 * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
 * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
 * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
 * @param {String} params.comment - Any additional comment to attach to the transaction
 * @param {String} params.otp - Two factor auth code to enable sending the transaction
 * @param {String} params.changeAddress - Specifies the destination of the change output
 * @param {Boolean} params.instant - Send this transaction using coin-specific instant sending method (if available)
 * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
 * @param callback
 * @returns {*}
 */
Wallet.prototype.sendMany = function (params, callback) {
    return co(function () {
        var reqId, coin, halfSignedTransaction, selectParams, finalTxParams;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    params = params || {};
                    common.validateParams(params, [], ['comment', 'otp'], callback);
                    debug('sendMany called');
                    reqId = params.reqId || util.createRequestId();
                    params.reqId = reqId;
                    coin = this.baseCoin;
                    if (_.isObject(params.recipients)) {
                        params.recipients.map(function (recipient) {
                            var amount = new BigNumber(recipient.amount);
                            if (amount.isNegative()) {
                                throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
                            }
                            if (!coin.valuelessTransferAllowed() && amount.isZero()) {
                                throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
                            }
                        });
                    }
                    return [4 /*yield*/, this.prebuildAndSignTransaction(params)];
                case 1:
                    halfSignedTransaction = _a.sent();
                    selectParams = _.pick(params, [
                        'recipients', 'numBlocks', 'feeRate', 'maxFeeRate', 'minConfirms',
                        'enforceMinConfirmsForChange', 'targetWalletUnspents',
                        'message', 'minValue', 'maxValue', 'sequenceId',
                        'lastLedgerSequence', 'ledgerSequenceDelta', 'gasPrice',
                        'noSplitChange', 'unspents', 'comment', 'otp', 'changeAddress',
                        'instant', 'memo'
                    ]);
                    finalTxParams = _.extend({}, halfSignedTransaction, selectParams);
                    this.bitgo._reqId = reqId;
                    return [2 /*return*/, this.bitgo.post(this.url('/tx/send'))
                            .send(finalTxParams)
                            .result()];
            }
        });
    }).call(this).asCallback(callback);
};
/**
 * Recover an unsupported token from a BitGo multisig wallet
 * params are validated in Eth.prototype.recoverToken
 * @param params
 * @param params.tokenContractAddress the contract address of the unsupported token
 * @param params.recipient the destination address recovered tokens should be sent to
 * @param params.walletPassphrase the wallet passphrase
 * @param params.prv the xprv
 */
Wallet.prototype.recoverToken = function (params, callback) {
    return co(function () {
        return __generator(this, function (_a) {
            if (this.baseCoin.getFamily() !== 'eth') {
                throw new Error('token recovery only supported for eth wallets');
            }
            return [2 /*return*/, this.baseCoin.recoverToken(_.merge(params, { wallet: this }))];
        });
    }).call(this).asCallback(callback);
};
/**
 * Get transaction metadata for the oldest transaction that is still pending or attempted
 * @param callback
 * @param params.walletId [Optional] The ID of the wallet (must provide one of walletId and enterpriseId)
 * @param params.enterpriseId [Optional] The ID of the enterprise (must provide one of walletId and enterpriseId)
 * @returns {Object} Object with txid, walletId, tx, and fee (if supported for coin)
 */
Wallet.prototype.getFirstPendingTransaction = function (params, callback) {
    return co(function () {
        var query;
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, [], [], callback);
            query = { walletId: this.id() };
            return [2 /*return*/, internal.getFirstPendingTransaction(query, this.baseCoin, this.bitgo)];
        });
    }).call(this).asCallback(callback);
};
/**
 * Change the fee on the pending transaction that corresponds to the given txid to the given new fee
 * @param {String} params.txid The transaction Id corresponding to the transaction whose fee is to be changed
 * @param {Integer} params.fee The new fee to apply to the denoted transaction
 * @param callback
 * @returns {String} The transaction ID of the new transaction that contains the new fee rate
 */
Wallet.prototype.changeFee = function (params, callback) {
    return co(function () {
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, ['txid', 'fee'], [], callback);
            return [2 /*return*/, this.bitgo.post(this.baseCoin.url('/wallet/' + this.id() + '/tx/changeFee'))
                    .send(params)
                    .result()];
        });
    }).call(this).asCallback(callback);
};
/**
 * Fetch info from merchant server
 * @param {Object} params The params passed into the function
 * @param {String} params.url The Url to retrieve info from
 * @param callback
 * @returns {Object} The info returned from the merchant server
 */
Wallet.prototype.getPaymentInfo = function (params, callback) {
    return co(function coGetPaymentInfo() {
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, ['url'], [], callback);
            return [2 /*return*/, this.bitgo.get(this.url('/paymentInfo'))
                    .query(params)
                    .result()];
        });
    }).call(this).asCallback(callback);
};
/**
 * Send json payment response
 * @param {Object} params The params passed into the function
 * @param {String} params.paymentUrl - The url to send the fully signed transaction to
 * @param {String} params.txHex - The transaction hex of the payment
 * @param {String} params.memo {String} - A memo supplied by the merchant, to be inserted into the transfer as the comment
 * @param {String} params.expires {String} - ISO Date format of when the payment request expires
 * @param callback
 * @returns {Object} The info returned from the merchant server Payment Ack
 */
Wallet.prototype.sendPaymentResponse = function (params, callback) {
    return co(function coSendPaymentResponse() {
        return __generator(this, function (_a) {
            return [2 /*return*/, this.bitgo.post(this.url('/sendPayment'))
                    .send(params)
                    .result()];
        });
    }).call(this).asCallback(callback);
};
/**
 * Create a policy rule
 * @param params
 * @param params.condition condition object
 * @param params.action action object
 * @param callback
 * @returns {*}
 */
Wallet.prototype.createPolicyRule = function (params, callback) {
    return co(function () {
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, ['id', 'type'], ['message'], callback);
            if (!_.isObject(params.condition)) {
                throw new Error('missing parameter: conditions object');
            }
            if (!_.isObject(params.action)) {
                throw new Error('missing parameter: action object');
            }
            return [2 /*return*/, this.bitgo.post(this.url('/policy/rule'))
                    .send(params)
                    .result()];
        });
    }).call(this).asCallback(callback);
};
/**
 * Update a policy rule
 * @param params
 * @param params.condition condition object
 * @param params.action action object
 * @param callback
 * @returns {*}
 */
Wallet.prototype.setPolicyRule = function (params, callback) {
    return co(function () {
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, ['id', 'type'], ['message'], callback);
            if (!_.isObject(params.condition)) {
                throw new Error('missing parameter: conditions object');
            }
            if (!_.isObject(params.action)) {
                throw new Error('missing parameter: action object');
            }
            return [2 /*return*/, this.bitgo.put(this.url('/policy/rule'))
                    .send(params)
                    .result()];
        });
    }).call(this).asCallback(callback);
};
/**
 * Remove Policy Rule
 * @param params
 * @param callback
 * @returns {*}
 */
Wallet.prototype.removePolicyRule = function (params, callback) {
    return co(function () {
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, ['id'], ['message'], callback);
            return [2 /*return*/, this.bitgo.del(this.url('/policy/rule'))
                    .send(params)
                    .result()];
        });
    }).call(this).asCallback(callback);
};
/**
 * Remove Wallet
 * @param params
 * @param callback
 * @returns {*}
 */
Wallet.prototype.remove = function (params, callback) {
    return co(function () {
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, [], [], callback);
            return [2 /*return*/, this.bitgo.del(this.url())
                    .result()];
        });
    }).call(this).asCallback(callback);
};
/**
 * Creates and downloads PDF keycard for wallet (requires response from wallets.generateWallet)
 * @param params
 *   * jsPDF - an instance of the jsPDF library
 *   * QRCode - an instance of the QRious library
 *   * userKeychain - a wallet's private user keychain
 *   * backupKeychain - a wallet's private backup keychain
 *   * bitgoKeychain - a wallet's private bitgo keychain
 *   * passphrase - the wallet passphrase
 *   * passcodeEncryptionCode - the encryption secret used for Box D
 *   * activationCode - a randomly generated six-digit activation code
 *   * walletKeyID - the Key ID used for deriving a cold wallet's signing key
 *   * backupKeyID - the Key ID used for deriving a cold wallet's backup key
 * @param callback
 * @returns {*}
 */
Wallet.prototype.downloadKeycard = function (params, callback) {
    var _this = this;
    var getKeyData = function (coinShortName, passphrase, passcodeEncryptionCode, walletKeyID, backupKeyID) {
        // When using just 'generateWallet', we get back an unencrypted prv for the backup keychain
        // If the user passes in their passphrase, we can encrypt it
        if (params.backupKeychain.prv && passphrase) {
            params.backupKeychain.encryptedPrv = _this.bitgo.encrypt({
                input: params.backupKeychain.prv,
                password: passphrase
            });
        }
        // If we have the passcode encryption code, create a box D with the encryptedWalletPasscode
        if (passphrase && passcodeEncryptionCode) {
            params.encryptedWalletPasscode = _this.bitgo.encrypt({
                input: passphrase,
                password: passcodeEncryptionCode
            });
        }
        // PDF QR Code data
        var qrData = {
            user: {
                title: 'A: User Key',
                desc: 'This is your private key, encrypted with your passcode.',
                data: params.userKeychain.encryptedPrv
            },
            backup: {
                title: 'B: Backup Key',
                desc: 'This is your backup private key, encrypted with your passcode.',
                data: params.backupKeychain.encryptedPrv
            },
            bitgo: {
                title: 'C: BitGo Public Key',
                desc: 'This is the public part of the key that BitGo will use to ' +
                    'co-sign transactions\r\nwith you on your wallet.',
                data: params.bitgoKeychain.pub
            },
            passcode: {
                title: 'D: Encrypted Wallet Password',
                desc: 'This is the wallet  password, encrypted client-side ' +
                    'with a key held by\r\nBitGo.',
                data: params.encryptedWalletPasscode
            }
        };
        if (walletKeyID) {
            qrData.user.keyID = walletKeyID;
        }
        if (backupKeyID) {
            qrData.backup.keyID = backupKeyID;
        }
        if (!params.userKeychain.encryptedPrv) {
            // User provided their own key - this is a cold wallet
            qrData.user.title = 'A: Provided User Key';
            qrData.user.desc = 'This is the public key you provided for your wallet.';
            qrData.user.data = params.userKeychain.pub;
            // The user provided their own public key, we can remove box D
            delete qrData.passcode;
        }
        else if (!params.encryptedWalletPasscode) {
            delete qrData.passcode;
        }
        if (params.backupKeychain.provider) {
            var backupKeyProviderName = params.backupKeychain.provider;
            // Backup key held with KRS
            qrData.backup = {
                title: 'B: Backup Key',
                desc: 'This is the public key held at ' + backupKeyProviderName +
                    ', an ' + coinShortName + ' recovery service. If you lose\r\nyour key, ' + backupKeyProviderName +
                    ' will be able to sign transactions to recover funds.',
                data: params.backupKeychain.pub
            };
        }
        else if (!params.backupKeychain.encryptedPrv) {
            // User supplied the xpub
            qrData.backup = {
                title: 'B: Backup Key',
                desc: 'This is the public portion of your backup key, which you provided.',
                data: params.backupKeychain.pub
            };
        }
        return qrData;
    };
    var generateQuestions = function (coin) {
        return [
            {
                q: 'What is the KeyCard?',
                a: [
                    'The KeyCard contains important information which can be used to recover the ' + coin + ' ',
                    'from your wallet in several situations. Each BitGo wallet' +
                        ' has its own, unique KeyCard. ',
                    'If you have created multiple wallets, you should retain the KeyCard for each of them.'
                ]
            },
            {
                q: 'What should I do with it?',
                a: [
                    'You should print the KeyCard and/or save the PDF to an offline storage device. The print-out ',
                    'or USB stick should be kept in a safe place, such as a bank vault or home safe. It\'s a good idea ',
                    'to keep a second copy in a different location.',
                    '',
                    'Important: If you haven\'t provided an external backup key, then the original PDF should be ',
                    'deleted from any machine where the wallet will be regularly accessed to prevent malware from ',
                    'capturing both the KeyCard and your wallet passcode.'
                ]
            },
            {
                q: 'What should I do if I lose it?',
                a: [
                    'If you have lost or damaged all copies of your KeyCard, your ' + coin + ' is still safe, but this ',
                    'wallet should be considered at risk for loss. As soon as is convenient, you should use BitGo ',
                    'to empty the wallet into a new wallet',
                    ', and discontinue use of the old wallet.'
                ]
            },
            {
                q: 'What if someone sees my KeyCard?',
                a: [
                    'Don\'t panic! All sensitive information on the KeyCard is encrypted with your passcode, or with a',
                    'key which only BitGo has. But, in general, you should make best efforts to keep your ',
                    'KeyCard private. If your KeyCard does get exposed or copied in a way that makes you ',
                    'uncomfortable, the best course of action is to empty the corresponding wallet into another ',
                    'wallet and discontinue use of the old wallet.'
                ]
            },
            {
                q: 'What if I forget or lose my wallet password?',
                a: [
                    'BitGo can use the information in QR Code D to help you recover access to your wallet. ',
                    'Without the KeyCard, BitGo is not able to recover funds from a wallet with a lost password.'
                ]
            },
            {
                q: 'What if BitGo becomes inaccessible for an extended period?',
                a: [
                    'Your KeyCard and wallet passcode can be used together with BitGo’s published open ',
                    'source tools at https://github.com/bitgo to recover your ' + coin + '. Note: You should never enter ',
                    'information from your KeyCard into tools other than the tools BitGo has published, or your ',
                    'funds may be at risk for theft.'
                ]
            },
            {
                q: 'Should I write my wallet password on my KeyCard?',
                a: [
                    'No! BitGo’s multi-signature approach to security depends on there not being a single point ',
                    'of attack. But if your wallet password is on your KeyCard, then anyone who gains access to ',
                    'your KeyCard will be able to steal your ' + coin + '.' + ' We recommend keeping your wallet password ',
                    'safe in a secure password manager such as LastPass, 1Password or KeePass.'
                ]
            }
        ];
    };
    return co(function () {
        var jsPDF, QRCode, wallet, userKeychain, backupKeychain, bitgoKeychain, passphrase, passcodeEncryptionCode, walletKeyID, backupKeyID, _a, activationCode, font, color, margin, coinShortName, coinName, width, y, left, moveDown, doc, keyData, qrSize, questions;
        return __generator(this, function (_b) {
            params = params || {};
            common.validateParams(params, [], ['activationCode'], callback);
            if (!window || !window.location) {
                throw new Error('The downloadKeycard function is only callable within a browser.');
            }
            jsPDF = params.jsPDF, QRCode = params.QRCode, wallet = params.wallet, userKeychain = params.userKeychain, backupKeychain = params.backupKeychain, bitgoKeychain = params.bitgoKeychain, passphrase = params.passphrase, passcodeEncryptionCode = params.passcodeEncryptionCode, walletKeyID = params.walletKeyID, backupKeyID = params.backupKeyID, _a = params.activationCode, activationCode = _a === void 0 ? Math.floor(Math.random() * 900000 + 100000).toString() : _a;
            if (!jsPDF || typeof jsPDF !== 'function') {
                throw new Error('Please pass in a valid jsPDF instance');
            }
            // Validate keychains
            if (!userKeychain || typeof userKeychain !== 'object') {
                throw new Error("Wallet keychain must have a 'user' property");
            }
            if (!backupKeychain || typeof backupKeychain !== 'object') {
                throw new Error('Backup keychain is required and must be an object');
            }
            if (!bitgoKeychain || typeof bitgoKeychain !== 'object') {
                throw new Error('Bitgo keychain is required and must be an object');
            }
            if (walletKeyID && typeof walletKeyID !== 'string') {
                throw new Error('walletKeyID must be a string');
            }
            if (backupKeyID && typeof backupKeyID !== 'string') {
                throw new Error('backupKeyID must be a string');
            }
            // Validate activation code if provided
            if (typeof activationCode !== 'string') {
                throw new Error('Activation Code must be a string');
            }
            if (activationCode.length !== 6) {
                throw new Error('Activation code must be six characters');
            }
            font = {
                header: 24,
                subheader: 15,
                body: 12
            };
            color = {
                black: '#000000',
                darkgray: '#4c4c4c',
                gray: '#9b9b9b',
                red: '#e21e1e'
            };
            margin = 30;
            coinShortName = this.baseCoin.type;
            coinName = this.baseCoin.getFullName();
            width = 8.5 * 72;
            y = 0;
            left = function (x) { return margin + x; };
            moveDown = function (yDelta) { y += yDelta; };
            doc = new jsPDF('portrait', 'pt', 'letter');
            doc.setFont('helvetica');
            // PDF Header Area - includes the logo and company name
            // This is data for the BitGo logo in the top left of the PDF
            moveDown(30);
            // We don't currently add an image, since that path is dependent on BitGo frontend
            // doc.addImage(coinUtility.getSelectedCoinObj().keyCardImage, left(0), y + 10);
            // Activation Code
            moveDown(8);
            doc.setFontSize(font.body).setTextColor(color.gray);
            doc.text('Activation Code', left(460), y);
            doc.setFontSize(font.header).setTextColor(color.black);
            moveDown(25);
            doc.text('Your BitGo KeyCard', left(150), y);
            doc.setFontSize(font.header).setTextColor(color.gray);
            doc.text(activationCode.toString(), left(460), y);
            // Subheader
            // titles
            moveDown(margin);
            doc.setFontSize(font.body).setTextColor(color.gray);
            doc.text("Created on " + new Date().toDateString() + " by " + window.location.hostname + " for wallet named " + wallet.label(), left(0), y);
            // copy
            moveDown(25);
            doc.setFontSize(font.subheader).setTextColor(color.black);
            doc.text(params.wallet.label(), left(0), y);
            // Red Bar
            moveDown(20);
            doc.setFillColor(255, 230, 230);
            doc.rect(left(0), y, width - 2 * margin, 32, 'F');
            // warning message
            moveDown(20);
            doc.setFontSize(font.body).setTextColor(color.red);
            doc.text('Print this document, or keep it securely offline. See second page for FAQ.', left(75), y);
            keyData = getKeyData(coinShortName, passphrase, passcodeEncryptionCode, walletKeyID, backupKeyID);
            // Generate the first page's data for the backup PDF
            moveDown(35);
            qrSize = 130;
            // Draw each Box with QR code and description
            Object.keys(keyData).forEach(function (keyType) {
                var key = keyData[keyType];
                var topY = y;
                // Don't indent if we're not producing QR codes
                var textLeft = !!QRCode ? left(qrSize + 15) : left(15);
                // Draw a QR code if library is available
                if (QRCode) {
                    var dataURL = new QRCode({ value: key.data, size: qrSize }).toDataURL('image/jpeg');
                    doc.addImage(dataURL, left(0), y, qrSize, qrSize);
                }
                doc.setFontSize(font.subheader).setTextColor(color.black);
                moveDown(10);
                doc.text(key.title, textLeft, y);
                moveDown(15);
                doc.setFontSize(font.body).setTextColor(color.darkgray);
                doc.text(key.desc, textLeft, y);
                moveDown(30);
                doc.setFontSize(font.body - 2);
                doc.text('Data:', textLeft, y);
                moveDown(15);
                var innerWidth = 72 * 8.5 - textLeft - 30;
                doc.setFont('courier').setFontSize(9).setTextColor(color.black);
                var lines = doc.splitTextToSize(key.data, innerWidth);
                doc.text(lines, textLeft, y);
                // Add key ID (derivation string) if it exists
                if (key.keyID) {
                    var text = 'Key Id: ' + key.keyID;
                    // Gray bar
                    moveDown(45);
                    doc.setFillColor(247, 249, 249); // Gray background
                    doc.setDrawColor(0, 0, 0); // Border
                    doc.rect(textLeft, y, width, 15, 'FD');
                    doc.text(text, textLeft + 5, y + 10);
                }
                doc.setFont('helvetica');
                // Move down the size of the QR code minus accumulated height on the right side, plus buffer
                moveDown(qrSize - (y - topY) + 15);
            });
            // Add a new page (Q + A page)
            doc.addPage();
            // 2nd page title
            y = 0;
            moveDown(55);
            doc.setFontSize(font.header).setTextColor(color.black);
            doc.text('BitGo KeyCard FAQ', left(0), y);
            questions = generateQuestions(coinName);
            // Draw the Q + A data on the second page
            moveDown(30);
            questions.forEach(function (q) {
                doc.setFontSize(font.subheader).setTextColor(color.black);
                doc.text(q.q, left(0), y);
                moveDown(20);
                doc.setFontSize(font.body).setTextColor(color.darkgray);
                q.a.forEach(function (line) {
                    doc.text(line, left(0), y);
                    moveDown(font.body + 3);
                });
                moveDown(22);
            });
            // Save the PDF on the user's browser
            doc.save("BitGo Keycard for " + wallet.label() + ".pdf");
            return [2 /*return*/];
        });
    }).call(this).asCallback(callback);
};
module.exports = Wallet;
//# sourceMappingURL=wallet.js.map