"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var unspents_1 = require("@bitgo/unspents");
var request = require('superagent');
var Promise = require("bluebird");
var co = Promise.coroutine;
var _ = require("lodash");
var bitcoin = require('bitgo-utxo-lib');
/**
 * An instance of the recovery tool, which encapsulates the recovery functions
 * Instantiated with parameters:
 *   - bitgo: an instance of the bitgo SDK
 *   - sourceCoin: the coin that needs to be recovered
 *   - recoveryCoin: the type of address the faulty transaction was sent to
 */
var CrossChainRecoveryTool = /** @class */ (function () {
    function CrossChainRecoveryTool(opts) {
        this.bitgo = opts.bitgo;
        this.sourceCoin = opts.sourceCoin;
        this.recoveryCoin = opts.recoveryCoin;
        this.logging = opts.logging;
        if (!this.bitgo) {
            throw new Error('Please instantiate the recovery tool with a bitgo instance.');
        }
        // List of coins we support. Add modifiers (e.g. segwit) after the dash
        this.supportedCoins = ['btc', 'bch', 'ltc', 'btc-segwit', 'bsv'];
        if (!opts.sourceCoin || !this.supportedCoins.includes(opts.sourceCoin.getFamily())) {
            throw new Error('Please set a valid source coin');
        }
        if (!opts.recoveryCoin || !this.supportedCoins.includes(opts.recoveryCoin.getFamily())) {
            throw new Error('Please set a valid recovery type');
        }
        this.wallet = null;
        this.feeRates = {
            bch: 20,
            tbch: 20,
            bsv: 20,
            tbsv: 20,
            btc: 80,
            tbtc: 80,
            ltc: 100,
            tltc: 100
        };
        this.recoveryTx = new bitcoin.TransactionBuilder(this.sourceCoin.network);
    }
    /**
     * Internal logging function (either uses provided logger or console.log, can be turned off)
     * @param args - the arguments to pass to the logger
     * @private
     */
    CrossChainRecoveryTool.prototype._log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.logging === false) {
            return;
        }
        this.logger ? this.logger.apply(this, args) : console.log.apply(console, args);
    };
    /**
     * Sets the wallet ID of the recoveryCoin wallet. This is needed to find the private keys to sign the transaction.
     * @param walletId {String} wallet ID
     * @param callback
     */
    CrossChainRecoveryTool.prototype.setWallet = function (walletId, callback) {
        return co(function setWallet() {
            var coinType, wallet, e_1, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        coinType = this.recoveryCoin.getChain();
                        if (!coinType) {
                            throw new Error('Please provide coin type');
                        }
                        if (!walletId) {
                            throw new Error('Please provide wallet id');
                        }
                        this._log("Fetching " + coinType + " wallet...");
                        if (this.sourceCoin.type !== coinType && this.recoveryCoin.type !== coinType) {
                            throw new Error('Cannot set a wallet for this coin type - this is not a coin involved in the recovery tx.');
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.bitgo.coin(coinType).wallets().get({ id: walletId })];
                    case 2:
                        wallet = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        if (e_1.status !== 404 && e_1.status !== 400) {
                            throw e_1;
                        }
                        wallet = null;
                        return [3 /*break*/, 4];
                    case 4:
                        if (!(!wallet && coinType.endsWith('btc'))) return [3 /*break*/, 8];
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 7, , 8]);
                        this._log('Could not find v2 wallet. Falling back to v1...');
                        return [4 /*yield*/, this.bitgo.wallets().get({ id: walletId })];
                    case 6:
                        wallet = _a.sent();
                        wallet.isV1 = true;
                        return [3 /*break*/, 8];
                    case 7:
                        e_2 = _a.sent();
                        if (e_2.status !== 404) {
                            throw e_2;
                        }
                        return [3 /*break*/, 8];
                    case 8:
                        if (!wallet) {
                            throw new Error("Cannot find " + coinType + " wallet.");
                        }
                        this.wallet = wallet;
                        return [2 /*return*/];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Retrieves and stores the unspents from the faulty transaction
     * @param faultyTxId {String} the txid of the faulty transaction
     * @param callback
     */
    CrossChainRecoveryTool.prototype.findUnspents = function (faultyTxId, callback) {
        return co(function findUnspents() {
            var TX_INFO_URL, res, faultyTxInfo, txOutputAddresses, outputAddresses, _i, txOutputAddresses_1, address, methodName, walletAddress, e_3, ADDRESS_UNSPENTS_URL, addressRes, unspents;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!faultyTxId) {
                            throw new Error('Please provide a faultyTxId');
                        }
                        this._log('Grabbing info for faulty tx...');
                        this.faultyTxId = faultyTxId;
                        TX_INFO_URL = this.sourceCoin.url("/public/tx/" + faultyTxId);
                        return [4 /*yield*/, request.get(TX_INFO_URL)];
                    case 1:
                        res = _a.sent();
                        faultyTxInfo = res.body;
                        this._log('Getting unspents on output addresses..');
                        txOutputAddresses = faultyTxInfo.outputs.map(function (input) { return input.address; });
                        outputAddresses = [];
                        _i = 0, txOutputAddresses_1 = txOutputAddresses;
                        _a.label = 2;
                    case 2:
                        if (!(_i < txOutputAddresses_1.length)) return [3 /*break*/, 7];
                        address = txOutputAddresses_1[_i];
                        if (this.sourceCoin.getFamily() === 'ltc') {
                            try {
                                address = this.sourceCoin.canonicalAddress(address, 1);
                            }
                            catch (e) {
                                return [3 /*break*/, 6];
                            }
                        }
                        if (this.recoveryCoin.getFamily() === 'ltc') {
                            try {
                                address = this.recoveryCoin.canonicalAddress(address, 2);
                            }
                            catch (e) {
                                return [3 /*break*/, 6];
                            }
                        }
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        methodName = this.wallet.isV1 ? 'address' : 'getAddress';
                        return [4 /*yield*/, this.wallet[methodName]({ address: address })];
                    case 4:
                        walletAddress = _a.sent();
                        outputAddresses.push(walletAddress.address);
                        return [3 /*break*/, 6];
                    case 5:
                        e_3 = _a.sent();
                        this._log("Address " + address + " not found on wallet");
                        return [3 /*break*/, 6];
                    case 6:
                        _i++;
                        return [3 /*break*/, 2];
                    case 7:
                        if (outputAddresses.length === 0) {
                            throw new Error('Could not find tx outputs belonging to the specified wallet. Please check the given parameters.');
                        }
                        if (this.recoveryCoin.getFamily() === 'ltc') {
                            outputAddresses = outputAddresses.map(function (address) { return _this.recoveryCoin.canonicalAddress(address, 1); });
                        }
                        if (this.sourceCoin.getFamily() === 'ltc') {
                            outputAddresses = outputAddresses.map(function (address) { return _this.sourceCoin.canonicalAddress(address, 2); });
                        }
                        this._log("Finding unspents for these output addresses: " + outputAddresses.join(', '));
                        ADDRESS_UNSPENTS_URL = this.sourceCoin.url("/public/addressUnspents/" + outputAddresses.join(','));
                        return [4 /*yield*/, request.get(ADDRESS_UNSPENTS_URL)];
                    case 8:
                        addressRes = _a.sent();
                        unspents = addressRes.body;
                        this.unspents = unspents;
                        return [2 /*return*/, unspents];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Constructs transaction inputs from a set of unspents.
     * @param unspents {Object[]} array of unspents from the faulty transaction
     * @param callback
     * @returns {Object} partial txInfo object with transaction inputs
     */
    CrossChainRecoveryTool.prototype.buildInputs = function (unspents, callback) {
        return co(function buildInputs() {
            var txInfo, totalFound, noSegwit, _i, unspents_2, unspent, searchAddress, unspentAddress, methodName, e_4, _a, txHash, index, inputIndex, hash, inputData, addressInfo, _b, txid, nOut;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        this._log('Building inputs for recovery transaction...');
                        unspents = unspents || this.unspents;
                        if (!unspents || unspents.length === 0) {
                            throw new Error('Could not find unspents. Either supply an argument or call findUnspents');
                        }
                        txInfo = {
                            inputAmount: 0,
                            outputAmount: 0,
                            spendAmount: 0,
                            inputs: [],
                            outputs: [],
                            externalOutputs: [],
                            changeOutputs: [],
                            minerFee: 0,
                            payGoFee: 0
                        };
                        totalFound = 0;
                        noSegwit = this.recoveryCoin.getFamily() === 'btc' && this.sourceCoin.getFamily() === 'bch';
                        _i = 0, unspents_2 = unspents;
                        _c.label = 1;
                    case 1:
                        if (!(_i < unspents_2.length)) return [3 /*break*/, 10];
                        unspent = unspents_2[_i];
                        if (unspent.witnessScript && noSegwit) {
                            throw new Error('Warning! It appears one of the unspents is on a Segwit address. The tool only recovers BCH from non-Segwit BTC addresses. Aborting.');
                        }
                        searchAddress = unspent.address;
                        if (this.sourceCoin.type.endsWith('ltc')) {
                            searchAddress = this.sourceCoin.canonicalAddress(searchAddress, 1);
                        }
                        if (this.recoveryCoin.type.endsWith('ltc')) {
                            searchAddress = this.recoveryCoin.canonicalAddress(searchAddress, 2);
                        }
                        unspentAddress = void 0;
                        _c.label = 2;
                    case 2:
                        _c.trys.push([2, 4, , 5]);
                        methodName = this.wallet.isV1 ? 'address' : 'getAddress';
                        return [4 /*yield*/, this.wallet[methodName]({ address: searchAddress })];
                    case 3:
                        unspentAddress = _c.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_4 = _c.sent();
                        this._log("Could not find address on wallet for " + searchAddress);
                        return [3 /*break*/, 9];
                    case 5:
                        this._log("Found " + unspent.value * 1e-8 + " " + this.sourceCoin.type + " at address " + unspent.address);
                        _a = unspent.id.split(':'), txHash = _a[0], index = _a[1];
                        inputIndex = parseInt(index, 10);
                        hash = new Buffer(txHash, 'hex');
                        hash = new Buffer(Array.prototype.reverse.call(hash));
                        try {
                            this.recoveryTx.addInput(hash, inputIndex);
                        }
                        catch (e) {
                            throw new Error("Error adding unspent " + unspent.id);
                        }
                        inputData = {};
                        if (!this.wallet.isV1) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.wallet.address({ address: unspentAddress.address })];
                    case 6:
                        addressInfo = _c.sent();
                        unspentAddress.path = unspentAddress.path || "/" + unspentAddress.chain + "/" + unspentAddress.index;
                        _b = unspent.id.split(':'), txid = _b[0], nOut = _b[1];
                        inputData = {
                            redeemScript: addressInfo.redeemScript,
                            witnessScript: addressInfo.witnessScript,
                            path: '/0/0' + unspentAddress.path,
                            chainPath: unspentAddress.path,
                            index: unspentAddress.index,
                            chain: unspentAddress.chain,
                            txHash: txid,
                            txOutputN: parseInt(nOut, 10),
                            txValue: unspent.value,
                            value: parseInt(unspent.value, 10)
                        };
                        return [3 /*break*/, 8];
                    case 7:
                        inputData = {
                            redeemScript: unspentAddress.coinSpecific.redeemScript,
                            witnessScript: unspentAddress.coinSpecific.witnessScript,
                            index: unspentAddress.index,
                            chain: unspentAddress.chain,
                            wallet: this.wallet.id(),
                            fromWallet: this.wallet.id()
                        };
                        _c.label = 8;
                    case 8:
                        txInfo.inputs.push(Object.assign({}, unspent, inputData));
                        txInfo.inputAmount += parseInt(unspent.value, 10);
                        totalFound += parseInt(unspent.value, 10);
                        _c.label = 9;
                    case 9:
                        _i++;
                        return [3 /*break*/, 1];
                    case 10:
                        txInfo.unspents = _.clone(txInfo.inputs);
                        // Normalize total found to base unit before we print it out
                        this._log("Found lost " + totalFound * 1e-8 + " " + this.sourceCoin.type + ".");
                        this.txInfo = txInfo;
                        return [2 /*return*/, txInfo];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Sets the txInfo.minerFee field by calculating the size of the transaction and multiplying it by the fee rate for
     * the source coin.
     * @param recoveryTx {Object} recovery transaction containing inputs
     * @returns {Number} recovery fee for the transaction
     */
    CrossChainRecoveryTool.prototype.setFees = function (recoveryTx) {
        recoveryTx = recoveryTx || this.recoveryTx;
        // Determine fee with default fee rate
        var feeRate = this.feeRates[this.sourceCoin.type];
        // Note that we assume one output here (all funds should be recovered to a single address)
        var txSize = unspents_1.VirtualSizes.txP2shInputSize * recoveryTx.tx.ins.length + unspents_1.VirtualSizes.txP2pkhOutputSize +
            unspents_1.VirtualSizes.txOverheadSize;
        var recoveryFee = feeRate * txSize;
        this.txInfo.minerFee = recoveryFee;
        return recoveryFee;
    };
    /**
     * Constructs a single output to the recovery address.
     * @param recoveryAddress {String} address to recover funds to
     * @param outputAmount {Number} amount to send to the recovery address
     * @param recoveryFee {Number} miner fee for the transaction
     */
    CrossChainRecoveryTool.prototype.buildOutputs = function (recoveryAddress, outputAmount, recoveryFee) {
        if (!outputAmount && !this.txInfo) {
            throw new Error('Could not find transaction info. Please provide an output amount, or call buildInputs.');
        }
        this._log("Building outputs for recovery transaction. Funds will be sent to " + recoveryAddress + "...");
        outputAmount = outputAmount || this.txInfo.inputAmount - (recoveryFee || this.txInfo.minerFee);
        this.txInfo.outputAmount = outputAmount;
        this.txInfo.spendAmount = outputAmount;
        if (outputAmount <= 0) {
            throw new Error('This recovery transaction cannot pay its own fees. Aborting.');
        }
        this.recoveryAddress = recoveryAddress;
        this.recoveryAmount = outputAmount;
        this.recoveryTx.addOutput(recoveryAddress, outputAmount);
        var outputData = {
            address: recoveryAddress,
            value: outputAmount,
            valueString: outputAmount.toString(),
            wallet: this.wallet.id(),
            change: false
        };
        this.txInfo.outputs.push(outputData);
        this.txInfo.externalOutputs.push(outputData);
    };
    /**
     * Half-signs the built transaction with the user's private key or keychain
     * @param prv {String} private key
     * @param passphrase {String} wallet passphrase
     * @param keychain {Object} wallet keychain
     * @param callback
     * @returns {Object} half-signed transaction
     */
    CrossChainRecoveryTool.prototype.signTransaction = function (_a, callback) {
        var prv = _a.prv, passphrase = _a.passphrase, keychain = _a.keychain;
        return co(function signTransaction() {
            var transactionHex, txPrebuild;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.txInfo) {
                            throw new Error('Could not find txInfo. Please build a transaction');
                        }
                        this._log('Signing the transaction...');
                        transactionHex = this.recoveryTx.buildIncomplete().toHex();
                        if (!!prv) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getKeys(passphrase)];
                    case 1:
                        prv = _a.sent();
                        _a.label = 2;
                    case 2:
                        txPrebuild = { txHex: transactionHex, txInfo: this.txInfo };
                        this.halfSignedRecoveryTx = this.sourceCoin.signTransaction({ txPrebuild: txPrebuild, prv: prv });
                        return [2 /*return*/, this.halfSignedRecoveryTx];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Gets the wallet's encrypted keychain, then decrypts it with the wallet passphrase
     * @param passphrase {String} wallet passphrase
     * @param callback
     * @returns {String} decrypted wallet private key
     */
    CrossChainRecoveryTool.prototype.getKeys = function (passphrase, callback) {
        return co(function getKeys() {
            var prv, keychain, e_5, encryptedPrv;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.wallet.getEncryptedUserKeychain()];
                    case 1:
                        keychain = _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_5 = _a.sent();
                        if (e_5.status !== 404) {
                            throw e_5;
                        }
                        return [3 /*break*/, 3];
                    case 3:
                        if (!passphrase) {
                            throw new Error('You have an encrypted user keychain - please provide the passphrase to decrypt it');
                        }
                        if (this.wallet.isV1) {
                            if (!keychain) {
                                throw new Error('V1 wallets need a user keychain - could not find the proper keychain. Aborting');
                            }
                        }
                        if (keychain) {
                            try {
                                encryptedPrv = this.wallet.isV1 ? keychain.encryptedXprv : keychain.encryptedPrv;
                                prv = this.bitgo.decrypt({ input: encryptedPrv, password: passphrase });
                            }
                            catch (e) {
                                throw new Error('Error reading private key. Please check that you have the correct wallet passphrase');
                            }
                        }
                        return [2 /*return*/, prv];
                }
            });
        }).call(this).asCallback(callback);
    };
    CrossChainRecoveryTool.prototype.buildTransaction = function (_a, callback) {
        var wallet = _a.wallet, faultyTxId = _a.faultyTxId, recoveryAddress = _a.recoveryAddress;
        return co(function buildTransaction() {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.setWallet(wallet)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.findUnspents(faultyTxId)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.buildInputs()];
                    case 3:
                        _a.sent();
                        this.setFees();
                        this.buildOutputs(recoveryAddress);
                        return [2 /*return*/, this.recoveryTx];
                }
            });
        }).call(this).asCallback(callback);
    };
    CrossChainRecoveryTool.prototype.buildUnsigned = function (callback) {
        return co(function () {
            var incomplete, txInfo, _i, _a, input, feeInfo;
            return __generator(this, function (_b) {
                if (!this.txInfo) {
                    throw new Error('Could not find txInfo. Please build a transaction');
                }
                incomplete = this.recoveryTx.buildIncomplete();
                txInfo = {
                    nP2SHInputs: 0,
                    nSegwitInputs: 0
                };
                for (_i = 0, _a = this.txInfo.inputs; _i < _a.length; _i++) {
                    input = _a[_i];
                    if (input.chain === 10 || input.chain === 11) {
                        txInfo.nSegwitInputs++;
                    }
                    else {
                        txInfo.nP2SHInputs++;
                    }
                }
                txInfo.nOutputs = 1;
                txInfo.unspents = _.map(this.txInfo.inputs, _.partialRight(_.pick, ['chain', 'index', 'redeemScript', 'id', 'address', 'value']));
                txInfo.changeAddresses = [];
                txInfo.walletAddressDetails = {};
                feeInfo = {};
                feeInfo.size = unspents_1.VirtualSizes.txOverheadSize + (unspents_1.VirtualSizes.txP2shInputSize * this.txInfo.inputs.length) +
                    unspents_1.VirtualSizes.txP2pkhOutputSize;
                feeInfo.feeRate = this.feeRates[this.sourceCoin.type];
                feeInfo.fee = Math.round(feeInfo.size / 1000 * feeInfo.feeRate);
                feeInfo.payGoFee = 0;
                feeInfo.payGoFeeString = '0';
                return [2 /*return*/, {
                        txHex: incomplete.toHex(),
                        txInfo: txInfo,
                        feeInfo: feeInfo,
                        walletId: this.wallet.id(),
                        amount: this.recoveryAmount,
                        address: this.recoveryAddress,
                        coin: this.sourceCoin.type
                    }];
            });
        }).call(this).asCallback(callback);
    };
    CrossChainRecoveryTool.prototype.export = function () {
        return {
            version: this.wallet.isV1 ? 1 : 2,
            sourceCoin: this.sourceCoin.type,
            recoveryCoin: this.recoveryCoin.type,
            walletId: this.wallet.id(),
            recoveryAddress: this.recoveryAddress,
            recoveryAmount: this.recoveryAmount,
            txHex: this.halfSignedRecoveryTx.txHex || this.halfSignedRecoveryTx.tx,
            txInfo: this.txInfo
        };
    };
    return CrossChainRecoveryTool;
}());
module.exports = CrossChainRecoveryTool;
//# sourceMappingURL=recovery.js.map