"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var Keychains;
var BigNumber = require('bignumber.js');
var Enterprises;
var PendingApprovals;
var Wallet;
var Wallets;
var Markets;
var Token;
var OFCToken;
var Webhooks;
var coinGenerators;
var bitcoin = require("bitgo-utxo-lib");
var bitcoinMessage = require('bitcoinjs-message');
var Promise = require('bluebird');
var co = Promise.coroutine;
var errors = require('../errors');
var _ = require('lodash');
var BaseCoin = /** @class */ (function () {
    function BaseCoin() {
    }
    BaseCoin.getInstance = function (bitgo, coin) {
        var coinInstance = BaseCoin.initializeCoin(coin, bitgo);
        coinInstance.bitgo = bitgo;
        // Incase of a token, the type is already set
        // We don't want to override it because it can be instantiated with contract hash directly as well
        if (coinInstance.getFullName() !== 'ERC20 Token') {
            coinInstance.type = coin;
        }
        coinInstance.url = function (suffix) {
            return bitgo._baseUrl + '/api/v2/' + coinInstance.getChain() + suffix;
        };
        coinInstance.wallets = function () {
            if (!coinInstance.coinWallets) {
                if (!Wallets) {
                    Wallets = require('./wallets');
                }
                coinInstance.coinWallets = new Wallets(bitgo, coinInstance);
            }
            return coinInstance.coinWallets;
        };
        coinInstance.enterprises = function () {
            if (!coinInstance.coinEnterprises) {
                if (!Enterprises) {
                    Enterprises = require('./enterprises');
                }
                coinInstance.coinEnterprises = new Enterprises(bitgo, coinInstance);
            }
            return coinInstance.coinEnterprises;
        };
        coinInstance.keychains = function () {
            if (!coinInstance.coinKeychains) {
                if (!Keychains) {
                    Keychains = require('./keychains');
                }
                coinInstance.coinKeychains = new Keychains(bitgo, coinInstance);
            }
            return coinInstance.coinKeychains;
        };
        coinInstance.webhooks = function () {
            if (!coinInstance.coinWebhooks) {
                if (!Webhooks) {
                    Webhooks = require('./webhooks');
                }
                coinInstance.coinWebhooks = new Webhooks(bitgo, coinInstance);
            }
            return coinInstance.coinWebhooks;
        };
        coinInstance.pendingApprovals = function () {
            if (!coinInstance.coinPendingApprovals) {
                if (!PendingApprovals) {
                    PendingApprovals = require('./pendingApprovals');
                }
                coinInstance.coinPendingApprovals = new PendingApprovals(bitgo, coinInstance);
            }
            return coinInstance.coinPendingApprovals;
        };
        coinInstance.markets = function () {
            if (!coinInstance.coinMarkets) {
                if (!Markets) {
                    Markets = require('./markets');
                }
                coinInstance.coinMarkets = new Markets(bitgo, this);
            }
            return coinInstance.coinMarkets;
        };
        return coinInstance;
    };
    BaseCoin.setupTokens = function (coins, bitgo) {
        if (!Token) {
            Token = require('./coins/token');
        }
        var tokens = bitgo.getConstants().eth.tokens;
        tokens.forEach(function (tokenConfig) {
            var generatedToken = Token.generateToken(tokenConfig);
            if (!coins[tokenConfig.type]) {
                coins[tokenConfig.type] = generatedToken;
            }
            // users can specify a coin by the token contract hash
            if (!coins[tokenConfig.tokenContractAddress]) {
                coins[tokenConfig.tokenContractAddress] = generatedToken;
            }
        });
    };
    BaseCoin.setupOffchainTokens = function (coins, bitgo) {
        if (!OFCToken) {
            OFCToken = require('./coins/ofcToken');
        }
        var constants = bitgo.getConstants();
        var tokens = _.get(constants, 'ofc.tokens');
        if (tokens) {
            tokens.forEach(function (tokenConfig) {
                var generatedToken = OFCToken.generateToken(tokenConfig);
                if (!coins[tokenConfig.type]) {
                    coins[tokenConfig.type] = generatedToken;
                }
            });
        }
    };
    /**
     * This feature is mostly for browsers where we don't want to have a build with coins that people don't need
     * In order to specify the coins you want, you must pass the env.coins="csv coins"
     * If nothing is passed, all coins are going to be available.
     * In webpack, we have to define via plugin what we want. to exclude but also we want to include the coins if the
     * user didn't specify anything or in node environments
     * @returns {}
     */
    BaseCoin.getCoinsToInitialize = function (bitgo) {
        var coins = {};
        if (process.env.BITGO_EXCLUDE_BTC !== 'exclude') {
            coins.btc = require('./coins/btc');
            coins.tbtc = require('./coins/tbtc');
        }
        if (process.env.BITGO_EXCLUDE_BCH !== 'exclude') {
            coins.bch = require('./coins/bch');
            coins.tbch = require('./coins/tbch');
        }
        if (process.env.BITGO_EXCLUDE_BSV !== 'exclude') {
            coins.bsv = require('./coins/bsv');
            coins.tbsv = require('./coins/tbsv');
        }
        if (process.env.BITGO_EXCLUDE_BTG !== 'exclude') {
            coins.btg = require('./coins/btg');
            coins.tbtg = require('./coins/tbtg');
        }
        if (process.env.BITGO_EXCLUDE_LTC !== 'exclude') {
            coins.ltc = require('./coins/ltc');
            coins.tltc = require('./coins/tltc');
        }
        if (process.env.BITGO_EXCLUDE_ETH !== 'exclude') {
            coins.eth = require('./coins/eth');
            coins.teth = require('./coins/teth');
            // Initialize the tokens
            BaseCoin.setupTokens(coins, bitgo);
        }
        if (process.env.BITGO_EXCLUDE_RMG !== 'exclude') {
            coins.rmg = require('./coins/rmg');
            coins.trmg = require('./coins/trmg');
        }
        if (process.env.BITGO_EXCLUDE_XRP !== 'exclude') {
            coins.xrp = require('./coins/xrp');
            coins.txrp = require('./coins/txrp');
        }
        if (process.env.BITGO_EXCLUDE_XLM !== 'exclude') {
            coins.xlm = require('./coins/xlm');
            coins.txlm = require('./coins/txlm');
        }
        if (process.env.BITGO_EXCLUDE_DASH !== 'exclude') {
            coins.dash = require('./coins/dash');
            coins.tdash = require('./coins/tdash');
        }
        if (process.env.BITGO_EXCLUDE_ZEC !== 'exclude') {
            coins.zec = require('./coins/zec');
            coins.tzec = require('./coins/tzec');
        }
        if (process.env.BITGO_EXCLUDE_OFC !== 'exclude') {
            coins.ofc = require('./coins/ofc');
            // Initialize the tokens
            BaseCoin.setupOffchainTokens(coins, bitgo);
        }
        if (process.env.BITGO_EXCLUDE_SUSD !== 'exclude') {
            coins.susd = require('./coins/susd');
            coins.tsusd = require('./coins/tsusd');
        }
        return coins;
    };
    BaseCoin.initializeCoin = function (coin, bitgo) {
        if (!coinGenerators) {
            // initialization has to be asynchronous to avoid circular dependencies
            coinGenerators = BaseCoin.getCoinsToInitialize(bitgo);
        }
        var CoinGenerator = coinGenerators[coin];
        if (!CoinGenerator && coinGenerators['eth']) {
            var ethCoin = new coinGenerators['eth']();
            if (ethCoin.isValidAddress(coin)) {
                // return a token which we don't support but can sign
                var unknownToken = Token.generateToken({ type: 'unknown', coin: 'eth', network: 'Mainnet', name: 'Unknown', tokenContractAddress: coin, decimalPlaces: 0 });
                return new unknownToken();
            }
        }
        if (!CoinGenerator) {
            throw new errors.UnsupportedCoinError(coin);
        }
        return new CoinGenerator();
    };
    /**
     * Name of the chain which supports this coin (eg, 'btc', 'eth')
     */
    BaseCoin.prototype.getChain = function () {
        throw new Error('Basecoin method not implemented');
    };
    /**
     * Name of the coin family (eg. for tbtc, this would be btc)
     */
    BaseCoin.prototype.getFamily = function () {
        throw new Error('Basecoin method not implemented');
    };
    /**
     * Human readable full name for the coin
     */
    BaseCoin.prototype.getFullName = function () {
        throw new Error('Basecoin method not implemented');
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    BaseCoin.prototype.valuelessTransferAllowed = function () {
        return false;
    };
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    BaseCoin.prototype.transactionDataAllowed = function () {
        return false;
    };
    BaseCoin.prototype.getBaseFactor = function () {
        throw new Error('Basecoin method not implemented');
    };
    /**
     * Convert a currency amount represented in base units (satoshi, wei, atoms, drops, stroops)
     * to big units (btc, eth, rmg, xrp, xlm)
     * @param {string|number} baseUnits
     * @returns {string}
     */
    BaseCoin.prototype.baseUnitsToBigUnits = function (baseUnits) {
        var dividend = this.getBaseFactor();
        var bigNumber = new BigNumber(baseUnits).dividedBy(dividend);
        // set the format so commas aren't added to large coin amounts
        return bigNumber.toFormat(null, null, { groupSeparator: '', decimalSeparator: '.' });
    };
    /**
     * Convert a currency amount represented in big units (btc, eth, rmg, xrp, xlm)
     * to base units (satoshi, wei, atoms, drops, stroops)
     * @param bigUnits
     */
    BaseCoin.prototype.bigUnitsToBaseUnits = function (bigUnits) {
        var multiplier = this.getBaseFactor();
        var bigNumber = new BigNumber(bigUnits).times(multiplier);
        if (!bigNumber.isInteger()) {
            throw new Error("non-integer output resulted from multiplying " + bigUnits + " by " + multiplier);
        }
        return bigNumber.toFixed(0);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    BaseCoin.prototype.signMessage = function (key, message) {
        var privateKey = bitcoin.HDNode.fromBase58(key.prv).getKey();
        var privateKeyBuffer = privateKey.d.toBuffer(32);
        var isCompressed = privateKey.compressed;
        var prefix = bitcoin.networks.bitcoin.messagePrefix;
        return bitcoinMessage.sign(message, privateKeyBuffer, isCompressed, prefix);
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     */
    BaseCoin.prototype.verifyTransaction = function (params, callback) {
        return Promise.resolve(true);
    };
    /**
     * Verify that an address belongs to a wallet
     * @returns {boolean}
     */
    BaseCoin.prototype.verifyAddress = function (params) {
        return true;
    };
    /**
     * Check whether a coin supports blockTarget for transactions to be included in
     * @returns {boolean}
     */
    BaseCoin.prototype.supportsBlockTarget = function () {
        return false;
    };
    /**
     * If a coin needs to add additional parameters to the wallet generation, it does it in this method
     * @param walletParams
     * @return {*}
     */
    BaseCoin.prototype.supplementGenerateWallet = function (walletParams) {
        return Promise.resolve(walletParams);
    };
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    BaseCoin.prototype.postProcessPrebuild = function (prebuildResponse, callback) {
        return Promise.method(function () {
            return prebuildResponse;
        }).call(this).asCallback(callback);
    };
    BaseCoin.prototype.newWalletObject = function (walletParams) {
        if (!Wallet) {
            Wallet = require('./wallet');
        }
        return new Wallet(this.bitgo, this, walletParams);
    };
    BaseCoin.prototype.toJSON = function () {
        return undefined;
    };
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Integer} params.numBlocks The number of blocks to target for conformation (Only works for btc)
     * @param callback
     * @returns {Object} The info returned from the merchant server
     */
    BaseCoin.prototype.feeEstimate = function (params, callback) {
        return co(function coFeeEstimate() {
            var query;
            return __generator(this, function (_a) {
                query = {};
                if (params && params.numBlocks) {
                    query.numBlocks = params.numBlocks;
                }
                return [2 /*return*/, this.bitgo.get(this.url('/tx/fee')).query(query).result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * The cold wallet tool uses this function to derive an extended key that is based on the passed key and seed
     * @param key
     * @param seed
     * @returns {{key: *, derivationPath: string}}
     */
    BaseCoin.prototype.deriveKeyWithSeed = function (_a) {
        var key = _a.key, seed = _a.seed;
        var derivationPathInput = bitcoin.crypto.hash256("" + seed).toString('hex');
        var derivationPathParts = [
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16)
        ];
        var derivationPath = 'm/999999/' + derivationPathParts.join('/');
        var keyNode = bitcoin.HDNode.fromBase58(key);
        var derivedKeyNode = bitcoin.hdPath(keyNode).derive(derivationPath);
        return {
            key: derivedKeyNode.toBase58(),
            derivationPath: derivationPath
        };
    };
    /**
     * Perform additional checks before adding a bitgo key. Base controller
     * is a no-op, but coin-specific controller may do something
     * @param params
     */
    BaseCoin.prototype.preCreateBitGo = function (params) {
        return;
    };
    BaseCoin.prototype.initiateRecovery = function (params) {
        return co(function initiateRecovery() {
            var self, keys, userKey, backupKey, bitgoXpub, destinationAddress, passphrase, isKrsRecovery, validatePassphraseKey, key, backupHDNode, bitgoHDNode;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        self = this;
                        keys = [];
                        userKey = params.userKey;
                        backupKey = params.backupKey;
                        bitgoXpub = params.bitgoKey;
                        destinationAddress = params.recoveryDestination;
                        passphrase = params.walletPassphrase;
                        isKrsRecovery = backupKey.startsWith('xpub') && !userKey.startsWith('xpub');
                        validatePassphraseKey = function (userKey, passphrase) {
                            try {
                                if (!userKey.startsWith('xprv') && !userKey.startsWith('xpub')) {
                                    userKey = self.bitgo.decrypt({
                                        input: userKey,
                                        password: passphrase
                                    });
                                }
                                var userHDNode = bitcoin.HDNode.fromBase58(userKey);
                                return Promise.resolve(userHDNode);
                            }
                            catch (e) {
                                throw new Error('Failed to decrypt user key with passcode - try again!');
                            }
                        };
                        return [4 /*yield*/, validatePassphraseKey(userKey, passphrase)];
                    case 1:
                        key = _a.sent();
                        keys.push(key);
                        // Validate the backup key
                        try {
                            if (!backupKey.startsWith('xprv') && !isKrsRecovery && !backupKey.startsWith('xpub')) {
                                backupKey = self.bitgo.decrypt({
                                    input: backupKey,
                                    password: passphrase
                                });
                            }
                            backupHDNode = bitcoin.HDNode.fromBase58(backupKey);
                            keys.push(backupHDNode);
                        }
                        catch (e) {
                            throw new Error('Failed to decrypt backup key with passcode - try again!');
                        }
                        try {
                            bitgoHDNode = bitcoin.HDNode.fromBase58(bitgoXpub);
                            keys.push(bitgoHDNode);
                        }
                        catch (e) {
                            if (this.getFamily() !== 'xrp') {
                                // in XRP recoveries, the BitGo xpub is optional
                                throw new Error('Failed to parse bitgo xpub!');
                            }
                        }
                        // Validate the destination address
                        if (!this.isValidAddress(destinationAddress)) {
                            throw new Error('Invalid destination address!');
                        }
                        return [2 /*return*/, keys];
                }
            });
        }).call(this);
    };
    // Some coins can have their tx info verified, if a public tx decoder is available
    BaseCoin.prototype.verifyRecoveryTransaction = function (txInfo) {
        // yieldable no-op
        return Promise.reject(new errors.MethodNotImplementedError());
    };
    BaseCoin.prototype.parseTransaction = function (params, callback) {
        return Promise.resolve({});
    };
    /**
     * Generate a key pair on the curve used by the coin
     *
     * @param seed
     */
    BaseCoin.prototype.generateKeyPair = function (seed) {
        throw new Error('abstract method');
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    BaseCoin.prototype.isValidPub = function (pub) {
        throw new Error('Basecoin method not implemented');
    };
    /**
     * Return wether the given m of n wallet signers/ key amounts are valid for the coin
     */
    BaseCoin.prototype.isValidMofNSetup = function (_a) {
        var m = _a.m, n = _a.n;
        return m === 2 && n === 3;
    };
    return BaseCoin;
}());
module.exports = BaseCoin;
//# sourceMappingURL=baseCoin.js.map