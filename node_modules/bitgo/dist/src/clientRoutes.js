"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bodyParser = require("body-parser");
var BitGoJS = require('./index');
var TransactionBuilder = require('./transactionBuilder');
var common = require('./common');
var Promise = require('bluebird');
var co = Promise.coroutine;
var url = require('url');
var _ = require('lodash');
var pjson = require('../package.json');
var debug = require('debug')('bitgo:express');
var util = require('./util');
var errors = require('./errors');
var BITGOEXPRESS_USER_AGENT = 'BitGoExpress/' + pjson.version;
var handlePing = function (req) {
    return req.bitgo.ping();
};
var handlePingExpress = function (req) {
    return {
        status: 'express server is ok!'
    };
};
var handleLogin = function (req) {
    var username = req.body.username || req.body.email;
    var body = req.body;
    body.username = username;
    return req.bitgo.authenticate(body);
};
var handleDecrypt = function (req) {
    return {
        decrypted: req.bitgo.decrypt(req.body)
    };
};
var handleEncrypt = function (req) {
    return {
        encrypted: req.bitgo.encrypt(req.body)
    };
};
var handleVerifyAddress = function (req) {
    return {
        verified: req.bitgo.verifyAddress(req.body)
    };
};
var handleCreateLocalKeyChain = function (req) {
    return req.bitgo.keychains().create(req.body);
};
var handleDeriveLocalKeyChain = function (req) {
    return req.bitgo.keychains().deriveLocal(req.body);
};
var handleCreateWalletWithKeychains = function (req) {
    return req.bitgo.wallets().createWalletWithKeychains(req.body);
};
var handleSendCoins = function (req) {
    return req.bitgo.wallets().get({ id: req.params.id })
        .then(function (wallet) {
        return wallet.sendCoins(req.body);
    })
        .catch(function (err) {
        err.status = 400;
        throw err;
    })
        .then(function (result) {
        if (result.status === 'pendingApproval') {
            throw apiResponse(202, result);
        }
        return result;
    });
};
var handleSendMany = function (req) {
    return req.bitgo.wallets().get({ id: req.params.id })
        .then(function (wallet) {
        return wallet.sendMany(req.body);
    })
        .catch(function (err) {
        err.status = 400;
        throw err;
    })
        .then(function (result) {
        if (result.status === 'pendingApproval') {
            throw apiResponse(202, result);
        }
        return result;
    });
};
var handleCreateTransaction = function (req) {
    return req.bitgo.wallets().get({ id: req.params.id })
        .then(function (wallet) {
        return wallet.createTransaction(req.body);
    })
        .catch(function (err) {
        err.status = 400;
        throw err;
    });
};
var handleSignTransaction = function (req) {
    return req.bitgo.wallets().get({ id: req.params.id })
        .then(function (wallet) {
        return wallet.signTransaction(req.body);
    });
};
var handleShareWallet = function (req) {
    return req.bitgo.wallets().get({ id: req.params.id })
        .then(function (wallet) {
        return wallet.shareWallet(req.body);
    });
};
var handleAcceptShare = function (req) {
    var params = req.body || {};
    params.walletShareId = req.params.shareId;
    return req.bitgo.wallets().acceptShare(params);
};
var handleApproveTransaction = function (req) {
    var params = req.body || {};
    return req.bitgo.pendingApprovals().get({ id: req.params.id })
        .then(function (pendingApproval) {
        if (params.state === 'approved') {
            return pendingApproval.approve(params);
        }
        return pendingApproval.reject(params);
    });
};
var handleConstructApprovalTx = function (req) {
    var params = req.body || {};
    return req.bitgo.pendingApprovals().get({ id: req.params.id })
        .then(function (pendingApproval) {
        return pendingApproval.constructApprovalTx(params);
    });
};
var handleConsolidateUnspents = function (req) {
    return req.bitgo.wallets().get({ id: req.params.id })
        .then(function (wallet) {
        return wallet.consolidateUnspents(req.body);
    });
};
var handleFanOutUnspents = function (req) {
    return req.bitgo.wallets().get({ id: req.params.id })
        .then(function (wallet) {
        return wallet.fanOutUnspents(req.body);
    });
};
var handleCalculateMinerFeeInfo = function (req) {
    return TransactionBuilder.calculateMinerFeeInfo({
        bitgo: req.bitgo,
        feeRate: req.body.feeRate,
        nP2shInputs: req.body.nP2shInputs,
        nP2pkhInputs: req.body.nP2pkhInputs,
        nP2shP2wshInputs: req.body.nP2shP2wshInputs,
        nOutputs: req.body.nOutputs
    });
};
/**
 * Builds the API's URL string, optionally building the querystring if parameters exist
 * @param req
 * @return {string}
 */
var createAPIPath = function (req) {
    var apiPath = '/' + req.params[0];
    if (!_.isEmpty(req.query)) {
        // req.params does not contain the querystring, so we manually add them here
        var urlDetails = url.parse(req.url);
        if (urlDetails.search) {
            // "search" is the properly URL encoded query params, prefixed with "?"
            apiPath += urlDetails.search;
        }
    }
    return apiPath;
};
// handle any other API call
var handleREST = function (req, res, next) {
    var method = req.method;
    var bitgo = req.bitgo;
    var bitgoURL = bitgo.url(createAPIPath(req));
    return redirectRequest(bitgo, method, bitgoURL, req, next);
};
// handle any other API call
var handleV2UserREST = function (req, res, next) {
    var method = req.method;
    var bitgo = req.bitgo;
    var bitgoURL = bitgo.url('/user' + createAPIPath(req), 2);
    return redirectRequest(bitgo, method, bitgoURL, req, next);
};
// handle v2 address validation
var handleV2VerifyAddress = function (req) {
    common.validateParams(req.body, ['address'], []);
    if (req.body.supportOldScriptHashVersion !== undefined &&
        !_.isBoolean(req.body.supportOldScriptHashVersion)) {
        throw new Error('Expected supportOldScriptHashVersion to be a boolean.');
    }
    var supportOldScriptHashVersion = !!req.body.supportOldScriptHashVersion;
    var bitgo = req.bitgo;
    var coin = bitgo.coin(req.params.coin);
    var result = coin.isValidAddress(req.body.address, supportOldScriptHashVersion);
    return {
        isValid: !!result
    };
};
// handle address canonicalization
var handleCanonicalAddress = function (req) {
    var bitgo = req.bitgo;
    var coin = bitgo.coin(req.params.coin);
    if (!['ltc', 'bch', 'bsv'].includes(coin.getFamily())) {
        throw new Error('only Litecoin/Bitcoin Cash/Bitcoin SV address canonicalization is supported');
    }
    var address = req.body.address;
    var fallbackVersion = req.body.scriptHashVersion; // deprecate
    var version = req.body.version;
    return coin.canonicalAddress(address, version || fallbackVersion);
};
// handle new wallet creation
var handleV2GenerateWallet = function (req) {
    var bitgo = req.bitgo;
    var coin = bitgo.coin(req.params.coin);
    return coin.wallets().generateWallet(req.body)
        .then(function (result) {
        return result.wallet._wallet;
    });
};
// handle v2 approve transaction
var handleV2PendingApproval = co(function (req) {
    var bitgo, coin, params, pendingApproval;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                bitgo = req.bitgo;
                coin = bitgo.coin(req.params.coin);
                params = req.body || {};
                return [4 /*yield*/, coin.pendingApprovals().get({ id: req.params.id })];
            case 1:
                pendingApproval = _a.sent();
                if (params.state === 'approved') {
                    return [2 /*return*/, pendingApproval.approve(params)];
                }
                return [2 /*return*/, pendingApproval.reject(params)];
        }
    });
});
// create a keychain
var handleV2CreateLocalKeyChain = function (req) {
    var bitgo = req.bitgo;
    var coin = bitgo.coin(req.params.coin);
    return coin.keychains().create(req.body);
};
// handle wallet share
var handleV2ShareWallet = co(function (req) {
    var bitgo, coin, wallet;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                bitgo = req.bitgo;
                coin = bitgo.coin(req.params.coin);
                return [4 /*yield*/, coin.wallets().get({ id: req.params.id })];
            case 1:
                wallet = _a.sent();
                return [2 /*return*/, wallet.shareWallet(req.body)];
        }
    });
});
// handle accept wallet share
var handleV2AcceptWalletShare = co(function (req) {
    var bitgo, coin, params;
    return __generator(this, function (_a) {
        bitgo = req.bitgo;
        coin = bitgo.coin(req.params.coin);
        params = _.extend({}, req.body, { walletShareId: req.params.id });
        return [2 /*return*/, coin.wallets().acceptShare(params)];
    });
});
// handle wallet sign transaction
var handleV2SignTxWallet = co(function (req) {
    var bitgo, coin, wallet;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                bitgo = req.bitgo;
                coin = bitgo.coin(req.params.coin);
                return [4 /*yield*/, coin.wallets().get({ id: req.params.id })];
            case 1:
                wallet = _a.sent();
                return [2 /*return*/, wallet.signTransaction(req.body)];
        }
    });
});
// handle sign transaction
var handleV2SignTx = function (req) {
    var bitgo = req.bitgo;
    var coin = bitgo.coin(req.params.coin);
    return coin.signTransaction(req.body);
};
// handle wallet recover token
var handleV2RecoverToken = co(function (req) {
    var bitgo, coin, wallet;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                bitgo = req.bitgo;
                coin = bitgo.coin(req.params.coin);
                return [4 /*yield*/, coin.wallets().get({ id: req.params.id })];
            case 1:
                wallet = _a.sent();
                return [2 /*return*/, wallet.recoverToken(req.body)];
        }
    });
});
// handle wallet fanout unspents
var handleV2ConsolidateUnspents = co(function (req) {
    var bitgo, coin, wallet;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                bitgo = req.bitgo;
                coin = bitgo.coin(req.params.coin);
                return [4 /*yield*/, coin.wallets().get({ id: req.params.id })];
            case 1:
                wallet = _a.sent();
                return [2 /*return*/, wallet.consolidateUnspents(req.body)];
        }
    });
});
// handle wallet fanout unspents
var handleV2FanOutUnspents = co(function (req) {
    var bitgo, coin, wallet;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                bitgo = req.bitgo;
                coin = bitgo.coin(req.params.coin);
                return [4 /*yield*/, coin.wallets().get({ id: req.params.id })];
            case 1:
                wallet = _a.sent();
                return [2 /*return*/, wallet.fanoutUnspents(req.body)];
        }
    });
});
// handle wallet sweep
var handleV2Sweep = co(function handleV2Sweep(req) {
    var bitgo, coin, wallet;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                bitgo = req.bitgo;
                coin = bitgo.coin(req.params.coin);
                return [4 /*yield*/, coin.wallets().get({ id: req.params.id })];
            case 1:
                wallet = _a.sent();
                return [2 /*return*/, wallet.sweep(req.body)];
        }
    });
});
// handle CPFP accelerate transaction creation
var handleV2AccelerateTransaction = co(function handleV2AccelerateTransaction(req) {
    var bitgo, coin, wallet;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                bitgo = req.bitgo;
                coin = bitgo.coin(req.params.coin);
                return [4 /*yield*/, coin.wallets().get({ id: req.params.id })];
            case 1:
                wallet = _a.sent();
                return [2 /*return*/, wallet.accelerateTransaction(req.body)];
        }
    });
});
// handle send one
var handleV2SendOne = function (req) {
    var bitgo = req.bitgo;
    var coin = bitgo.coin(req.params.coin);
    var reqId = util.createRequestId();
    return coin.wallets().get({ id: req.params.id, reqId: reqId })
        .then(function (wallet) {
        req.body.reqId = reqId;
        return wallet.send(req.body);
    })
        .catch(function (err) {
        err.status = 400;
        throw err;
    })
        .then(function (result) {
        if (result.status === 'pendingApproval') {
            throw apiResponse(202, result);
        }
        return result;
    });
};
// handle send many
var handleV2SendMany = function (req) {
    var bitgo = req.bitgo;
    var coin = bitgo.coin(req.params.coin);
    var reqId = util.createRequestId();
    return coin.wallets().get({ id: req.params.id, reqId: reqId })
        .then(function (wallet) {
        req.body.reqId = reqId;
        return wallet.sendMany(req.body);
    })
        .catch(function (err) {
        err.status = 400;
        throw err;
    })
        .then(function (result) {
        if (result.status === 'pendingApproval') {
            throw apiResponse(202, result);
        }
        return result;
    });
};
// handle any other API call
var handleV2CoinSpecificREST = function (req, res, next) {
    var method = req.method;
    var bitgo = req.bitgo;
    try {
        var coin = bitgo.coin(req.params.coin);
        var coinURL = coin.url(createAPIPath(req));
        return redirectRequest(bitgo, method, coinURL, req, next);
    }
    catch (e) {
        if (e instanceof errors.UnsupportedCoinError) {
            var queryParams = _.transform(req.query, function (acc, value, key) {
                for (var _i = 0, _a = _.castArray(value); _i < _a.length; _i++) {
                    var val = _a[_i];
                    acc.push(key + "=" + val);
                }
            }, []);
            var baseUrl = bitgo.url(req.baseUrl.replace(/^\/api\/v2/, ''), 2);
            var url_1 = _.isEmpty(queryParams) ? baseUrl : baseUrl + "?" + queryParams.join('&');
            debug("coin " + req.params.coin + " not supported, attempting to handle as a coinless route with url " + url_1);
            return redirectRequest(bitgo, method, url_1, req, next);
        }
        throw e;
    }
};
var redirectRequest = function (bitgo, method, url, req, next) {
    switch (method) {
        case 'GET':
            return bitgo.get(url).result().nodeify();
        case 'POST':
            return bitgo.post(url).send(req.body).result().nodeify();
        case 'PUT':
            return bitgo.put(url).send(req.body).result().nodeify();
        case 'DELETE':
            return bitgo.del(url).send(req.body).result().nodeify();
    }
    // something has presumably gone wrong
    next();
};
var apiResponse = function (status, result, message) {
    if (message === void 0) { message = null; }
    var err = new Error(message);
    err.status = status;
    err.result = result;
    return err;
};
var expressJSONParser = bodyParser.json({ limit: '20mb' });
// Perform body parsing here only on routes we want
var parseBody = function (req, res, next) {
    // Set the default Content-Type, in case the client doesn't set it.  If
    // Content-Type isn't specified, Express silently refuses to parse the
    // request body.
    req.headers['content-type'] = req.headers['content-type'] || 'application/json';
    return expressJSONParser(req, res, next);
};
// Create the bitgo object in the request
var prepareBitGo = function (args) {
    var params = { env: args.env };
    if (args.customrooturi) {
        params.customRootURI = args.customrooturi;
    }
    if (args.custombitcoinnetwork) {
        params.customBitcoinNetwork = args.custombitcoinnetwork;
    }
    return function (req, res, next) {
        // Get access token
        var accessToken;
        if (req.headers.authorization) {
            var authSplit = req.headers.authorization.split(' ');
            if (authSplit.length === 2 && authSplit[0].toLowerCase() === 'bearer') {
                accessToken = authSplit[1];
            }
        }
        var userAgent = req.headers['user-agent'] ? BITGOEXPRESS_USER_AGENT + ' ' + req.headers['user-agent'] : BITGOEXPRESS_USER_AGENT;
        params.accessToken = accessToken;
        params.userAgent = userAgent;
        req.bitgo = new BitGoJS.BitGo(params);
        req.bitgo._promise.longStackSupport = true;
        next();
    };
};
// Promise handler wrapper to handle sending responses and error cases
var promiseWrapper = function (promiseRequestHandler, args) {
    return function (req, res, next) {
        debug("handle: " + req.method + " " + req.originalUrl);
        Promise.try(promiseRequestHandler, req, res, next)
            .then(function (result) {
            var status = 200;
            if (result.__redirect) {
                res.redirect(result.url);
                status = 302;
            }
            else if (result.__render) {
                res.render(result.template, result.params);
            }
            else {
                res.status(status).send(result);
            }
        })
            .catch(function (caught) {
            var err;
            if (caught instanceof Error) {
                err = caught;
            }
            else if (typeof caught === 'string') {
                err = new Error('(string_error) ' + caught);
            }
            else {
                err = new Error('(object_error) ' + JSON.stringify(caught));
            }
            var message = err.message || 'local error';
            // use attached result, or make one
            var result = err.result || { error: message };
            result = _.extend({}, result);
            result.message = err.message;
            var status = err.status || 500;
            if (!(status >= 200 && status < 300)) {
                console.log('error %s: %s', status, err.message);
            }
            if (status === 500) {
                console.log(err.stack);
            }
            res.status(status).send(result);
        })
            .done();
    };
};
exports = module.exports = function (app, args) {
    // When adding new routes to BitGo Express make sure that you also add the exact same routes to the server. Since
    // some customers were confused when calling a BitGo Express route on the BitGo server, we now handle all BitGo
    // Express routes on the BitGo server and return an error message that says that one should call BitGo Express
    // instead.
    // V1 routes should be added to www/config/routes.js
    // V2 routes should be added to www/config/routesV2.js
    // ping
    // /api/v[12]/pingexpress is the only exception to the rule above, as it explicitly checks the health of the
    // express server without running into rate limiting with the BitGo server.
    app.get('/api/v[12]/ping', prepareBitGo(args), promiseWrapper(handlePing, args));
    app.get('/api/v[12]/pingexpress', promiseWrapper(handlePingExpress, args));
    // auth
    app.post('/api/v[12]/user/login', parseBody, prepareBitGo(args), promiseWrapper(handleLogin, args));
    app.post('/api/v[12]/decrypt', parseBody, prepareBitGo(args), promiseWrapper(handleDecrypt, args));
    app.post('/api/v[12]/encrypt', parseBody, prepareBitGo(args), promiseWrapper(handleEncrypt, args));
    app.post('/api/v[12]/verifyaddress', parseBody, prepareBitGo(args), promiseWrapper(handleVerifyAddress, args));
    app.post('/api/v[12]/calculateminerfeeinfo', parseBody, prepareBitGo(args), promiseWrapper(handleCalculateMinerFeeInfo, args));
    app.post('/api/v1/keychain/local', parseBody, prepareBitGo(args), promiseWrapper(handleCreateLocalKeyChain, args));
    app.post('/api/v1/keychain/derive', parseBody, prepareBitGo(args), promiseWrapper(handleDeriveLocalKeyChain, args));
    app.post('/api/v1/wallets/simplecreate', parseBody, prepareBitGo(args), promiseWrapper(handleCreateWalletWithKeychains, args));
    app.post('/api/v1/wallet/:id/sendcoins', parseBody, prepareBitGo(args), promiseWrapper(handleSendCoins, args));
    app.post('/api/v1/wallet/:id/sendmany', parseBody, prepareBitGo(args), promiseWrapper(handleSendMany, args));
    app.post('/api/v1/wallet/:id/createtransaction', parseBody, prepareBitGo(args), promiseWrapper(handleCreateTransaction, args));
    app.post('/api/v1/wallet/:id/signtransaction', parseBody, prepareBitGo(args), promiseWrapper(handleSignTransaction, args));
    app.post('/api/v1/wallet/:id/simpleshare', parseBody, prepareBitGo(args), promiseWrapper(handleShareWallet, args));
    app.post('/api/v1/walletshare/:shareId/acceptShare', parseBody, prepareBitGo(args), promiseWrapper(handleAcceptShare, args));
    app.put('/api/v1/pendingapprovals/:id/express', parseBody, prepareBitGo(args), promiseWrapper(handleApproveTransaction, args));
    app.put('/api/v1/pendingapprovals/:id/constructTx', parseBody, prepareBitGo(args), promiseWrapper(handleConstructApprovalTx, args));
    app.put('/api/v1/wallet/:id/consolidateunspents', parseBody, prepareBitGo(args), promiseWrapper(handleConsolidateUnspents, args));
    app.put('/api/v1/wallet/:id/fanoutunspents', parseBody, prepareBitGo(args), promiseWrapper(handleFanOutUnspents, args));
    // any other API call
    app.use('/api/v[1]/*', parseBody, prepareBitGo(args), promiseWrapper(handleREST, args));
    // API v2
    // create keychain
    app.post('/api/v2/:coin/keychain/local', parseBody, prepareBitGo(args), promiseWrapper(handleV2CreateLocalKeyChain, args));
    // generate wallet
    app.post('/api/v2/:coin/wallet/generate', parseBody, prepareBitGo(args), promiseWrapper(handleV2GenerateWallet, args));
    // share wallet
    app.post('/api/v2/:coin/wallet/:id/share', parseBody, prepareBitGo(args), promiseWrapper(handleV2ShareWallet, args));
    app.post('/api/v2/:coin/walletshare/:id/acceptshare', parseBody, prepareBitGo(args), promiseWrapper(handleV2AcceptWalletShare, args));
    // sign transaction
    app.post('/api/v2/:coin/signtx', parseBody, prepareBitGo(args), promiseWrapper(handleV2SignTx, args));
    app.post('/api/v2/:coin/wallet/:id/signtx', parseBody, prepareBitGo(args), promiseWrapper(handleV2SignTxWallet, args));
    app.post('/api/v2/:coin/wallet/:id/recovertoken', parseBody, prepareBitGo(args), promiseWrapper(handleV2RecoverToken, args));
    // send transaction
    app.post('/api/v2/:coin/wallet/:id/sendcoins', parseBody, prepareBitGo(args), promiseWrapper(handleV2SendOne, args));
    app.post('/api/v2/:coin/wallet/:id/sendmany', parseBody, prepareBitGo(args), promiseWrapper(handleV2SendMany, args));
    // unspent changes
    app.post('/api/v2/:coin/wallet/:id/consolidateunspents', parseBody, prepareBitGo(args), promiseWrapper(handleV2ConsolidateUnspents, args));
    app.post('/api/v2/:coin/wallet/:id/fanoutunspents', parseBody, prepareBitGo(args), promiseWrapper(handleV2FanOutUnspents, args));
    app.post('/api/v2/:coin/wallet/:id/sweep', parseBody, prepareBitGo(args), promiseWrapper(handleV2Sweep, args));
    // CPFP
    app.post('/api/v2/:coin/wallet/:id/acceleratetx', parseBody, prepareBitGo(args), promiseWrapper(handleV2AccelerateTransaction, args));
    // Miscellaneous
    app.post('/api/v2/:coin/canonicaladdress', parseBody, prepareBitGo(args), promiseWrapper(handleCanonicalAddress, args));
    app.post('/api/v2/:coin/verifyaddress', parseBody, prepareBitGo(args), promiseWrapper(handleV2VerifyAddress, args));
    app.put('/api/v2/:coin/pendingapprovals/:id', parseBody, prepareBitGo(args), promiseWrapper(handleV2PendingApproval, args));
    // any other API v2 call
    app.use('/api/v2/user/*', parseBody, prepareBitGo(args), promiseWrapper(handleV2UserREST, args));
    app.use('/api/v2/:coin/*', parseBody, prepareBitGo(args), promiseWrapper(handleV2CoinSpecificREST, args));
};
//# sourceMappingURL=clientRoutes.js.map